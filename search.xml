<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python面试题实录</title>
      <link href="/computer-science/python/basic/100.Python%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E5%BD%95/"/>
      <url>/computer-science/python/basic/100.Python%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="python面试题实录"><a class="anchor" href="#python面试题实录">#</a> Python 面试题实录</h2><blockquote><p><strong>温馨提示</strong>：请访问我的另一个项目<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9QeXRob24tSW50ZXJ2aWV3LUJpYmxl"> “Python 面试宝典”</span>。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化-2</title>
      <link href="/computer-science/python/basic/76.%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-2/"/>
      <url>/computer-science/python/basic/76.%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-2/</url>
      
        <content type="html"><![CDATA[<h2 id="数据可视化-2"><a class="anchor" href="#数据可视化-2">#</a> 数据可视化 - 2</h2><p>通过前面的学习，我们已经对数据可视化工具 matplotlib 有一个初步的认知。大家可能也会发现了，matplotlib 提供的函数虽然强大，但是参数太多，要想对图表进行深度的定制就需要修改一系列的参数，这一点对新手并不友好。另一方面，使用 matplotlib 定制的统计图是静态图表，可能在某些需要交互效果的场景下并不合适。为了解决这两个问题，我们为大家介绍两个新的可视化工具，一个是 seaborn，一个是 pyecharts。</p><h3 id="seaborn"><a class="anchor" href="#seaborn">#</a> Seaborn</h3><p>Seaborn 是建立在 matplotlib 之上的数据可视化工具，它相当于是对 matplotlib 进行了更高级的封装，而且 seaborn 也能跟 pandas 无缝整合，让我们可以用更少的代码构建出更好的统计图表，帮助我们探索和理解数据。Seaborn 包含但不局限于以下描述的功能：</p><ol><li>面向数据集的 API，可用于检查多个变量之间的关系。</li><li>支持使用分类变量来显示观察结果或汇总统计数据。</li><li>能够可视化单变量或双变量分布以及在数据子集之间进行比较的选项</li><li>各类因变量线性回归模型的自动估计与作图。</li><li>集成调色板和主题，轻松定制统计图表的视觉效果。</li></ol><p>可以使用 Python 的包管理工具 pip 来安装 seaborn。</p><pre><code class="language-Bash">pip install seaborn</code></pre><p>在 Jupyter 中，可以直接使用魔法指令进行安装，如下所示。</p><pre><code class="language-Bash">%pip install seaborn</code></pre><p>下面，我们用 seaborn 自带的数据集为例，为大家简单的展示 seaborn 的用法和强大之处，想要深入研究 seaborn 的读者可以自行阅读官方<span class="exturl" data-url="aHR0cHM6Ly9zZWFib3JuLnB5ZGF0YS5vcmcvdHV0b3JpYWwuaHRtbA==">文档</span>和并查看官方作品集中的<span class="exturl" data-url="aHR0cHM6Ly9zZWFib3JuLnB5ZGF0YS5vcmcvZXhhbXBsZXMvaW5kZXguaHRtbA==">示例。</span>根据官方示例来编写自己的代码是一个不错的选择，简单的说就是保留官方代码，将数据换成自己的数据即可。下图展示了 seaborn 绘制图表的函数，可以看出，seaborn 的这些函数主要支持我们通过绘制图表来探索数据的关系、分布和分类。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTE1MDA1LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502115005.png</span>&quot; style=&quot;zoom:75%;&quot;&gt;</p><p>使用 seaborn，首先需要导入该库并设置主题，代码如下所示。</p><pre><code class="language-Python">import seaborn as snssns.set_theme()</code></pre><p>如果需要在图表上显示中文，还需要用之前讲过的方法修改 matplotlib 的配置参数，代码如下所示。</p><pre><code class="language-Python">import matplotlib.pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei', ]plt.rcParams['axes.unicode_minus'] = False</code></pre><blockquote><p><strong>注意</strong>：上面的代码必须放在调用 set_theme 函数之后，否则调用 set_theme 函数时又会重新修改 matplotlib 配置参数中的字体设置。</p></blockquote><p>加载官方的 Tips 数据集（就餐小费数据）。</p><pre><code class="language-Python">tips_df = sns.load_dataset('tips')tips_df.info()</code></pre><p>运行结果如下所示，其中 total_bill 表示账单总金额，tip 表示小费的金额，sex 是顾客的性别，smoker 表示顾客是否抽样，day 代表星期几，time 代表是午餐还是晚餐，size 是就餐人数。</p><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 244 entries, 0 to 243Data columns (total 7 columns): #   Column      Non-Null Count  Dtype   ---  ------      --------------  -----    0   total_bill  244 non-null    float64  1   tip         244 non-null    float64  2   sex         244 non-null    category 3   smoker      244 non-null    category 4   day         244 non-null    category 5   time        244 non-null    category 6   size        244 non-null    int64   dtypes: category(4), float64(2), int64(1)memory usage: 7.4 KB</code></pre><p>由于数据集是联网加载的，上述代码可能因为 SSL 的原因无法获取到数据，可以尝试先运行下面的代码，然后再加载数据集。</p><pre><code class="language-Python">import sslssl._create_default_https_context = ssl._create_unverified_context</code></pre><p>如果我们希望了解账单金额的分布，可以使用下面的代码来绘制分布图。</p><pre><code class="language-Python">sns.histplot(data=tips_df, x='total_bill', kde=True)</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTE1NTMxLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502115531.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>如果想了解变量之间的两两关系，我们可以绘制点对图，代码和效果如下所示。</p><pre><code class="language-Python">sns.pairplot(data=tips_df, hue='sex')</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTIwMjM2LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502120236.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>如果对上面图表的颜色不满意，还可以通过 palette 参数选择 seaborn 自带的 “调色板” 来修改颜色，这种方式相比于自行指定颜色或使用随机颜色方便和靠谱了很多，下图为大家展示了部分 seaborn 自带的 “调色板”。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTIwNzQ5LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502120749.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>我们可以将上面的代码稍作修改，看看运行结果有什么差别。</p><pre><code class="language-Python">sns.pairplot(data=tips_df, hue='sex', palette='Dark2')</code></pre><p>接下来，我们为 total_bill 和 tip 两组数据绘制联合分布图，代码如下所示。</p><pre><code class="language-Python">sns.jointplot(data=tips_df, x='total_bill', y='tip', hue='sex')</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTIxMjI2LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502121226.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>上面清晰的展示了，total_bill 和 tip 之间存在正相关关系，这一点我们也可以通过 DataFrame 对象的 corr 方法进行验证。接下来，我们可以建立回归模型来拟合这些数据点，而 seaborn 的线性回归模型图已经帮我们实现了这项功能，代码如下所示。</p><pre><code class="language-Python">sns.lmplot(data=tips_df, x='total_bill', y='tip', hue='sex')</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTIxNjU2LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502121656.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>如果我们希望了解账单金额的集中和离散趋势，可以绘制箱线图或小提琴图，代码如下所示，我们将数据按星期四、星期五、星期六和星期天分别进行展示。</p><pre><code class="language-Python">sns.boxplot(data=tips_df, x='day', y='total_bill')</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTIyMTA2LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502122106.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><pre><code class="language-Python">sns.violinplot(data=tips_df, x='day', y='total_bill')</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTIyMTQ0LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502122144.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><blockquote><p><strong>说明</strong>：相较于箱线图，小提琴图没有标注异常点而是显示了数据的整个范围，另一方面，小提琴图很好的展示了数据的分布（密度轨迹）。</p></blockquote><h3 id="pyecharts"><a class="anchor" href="#pyecharts">#</a> Pyecharts</h3><p>Echarts 原来是百度开发的一个前端图表库，2018 年 1 月 16 日，ECharts 进入 Apache Incubator 进行孵化，目前已经是 Apache 软件基金会的顶级项目。凭借着良好的交互性和精巧的图表设计，ECharts 得到了众多开发者的认可，而 pyecharts 就是基于 Python 语言对 ECharts 进行了包装，让 Python 开发者也可以使用 ECharts 绘制外观精美且交互性强的统计图表。</p><p>可以使用 Python 的包管理工具 pip 来安装 pyecharts。</p><pre><code class="language-Bash">pip install pyecharts</code></pre><p>在 Jupyter 中，可以直接使用魔法指令进行安装，如下所示。</p><pre><code class="language-Bash">%pip install pyecharts</code></pre><p>接下来，我们通过来自于 pyecharts 官方网站新手教程中的一个例子，来认识 pyecharts。当然，我们对官网的例子进行一些调整，代码如下所示。</p><pre><code class="language-Python">from pyecharts.charts import Barfrom pyecharts import optionsfrom pyecharts.globals import ThemeType# 创建柱状图对象并设置初始参数（宽度、高度、主题）bar = Bar(init_opts=options.InitOpts(    width='600px',    height='450px',    theme=ThemeType.CHALK))# 设置横轴数据bar.add_xaxis([&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;])# 设置纵轴数据（第一组）bar.add_yaxis(    &quot;商家A&quot;,    [25, 20, 36, 10, 75, 90],)# 设置纵轴数据（第二组）bar.add_yaxis(    &quot;商家B&quot;,    [15, 12, 30, 20, 45, 60])# 设置纵轴数据（第三组）bar.add_yaxis(    &quot;商家C&quot;,    [12, 32, 40, 52, 35, 26])# 添加全局配置参数bar.set_global_opts(    # 横轴相关的参数    xaxis_opts=options.AxisOpts(        axislabel_opts=options.LabelOpts(            color='white'        )    ),    # 纵轴相关的参数（标签、最小值、最大值、间隔）    yaxis_opts=options.AxisOpts(        axislabel_opts=options.LabelOpts(            color='white'        ),        min_=0,        max_=100,        interval=10    ),    # 标题相关的参数（内容、链接、位置、文本样式）    title_opts=options.TitleOpts(        title='2021年销售数据展示',        title_link='http://www.qfedu.com',        pos_left='2%',        title_textstyle_opts=options.TextStyleOpts(            color='white',            font_size=16,            font_family='SimHei',            font_weight='bold'        )    ),    # 工具箱相关的参数    toolbox_opts=options.ToolboxOpts(        orient='vertical',        pos_left='right'    ))# 在Jupyter Notebook中渲染图表bar.render_notebook()</code></pre><p>上面代码的运行效果如下图所示。值得一提的是，下图中的标题、图例、右侧的工具箱都是可以点击的，大家可以点击它们看看会有什么样的效果，ECharts 的魅力就在于它的交互效果，大家一定要试一试。如果要将下面的统计图表保存成一个网页，可以将上面最后一行代码修改为 <code>bar.render('index.html')</code>  即可。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTg1NjUwLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502185650.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>接下来，我们也是通过一个官方示例，看看如何绘制饼图。</p><pre><code class="language-Python">import pyecharts.options as optsfrom pyecharts.charts import Pie# 准备饼图需要的数据x_data = [&quot;直接访问&quot;, &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot;, &quot;搜索引擎&quot;]y_data = [335, 310, 234, 135, 1548]data = [(x, y) for x, y in zip(x_data, y_data)]# 创建饼图对象并设置初始化参数pie = Pie(init_opts=opts.InitOpts(width=&quot;800px&quot;, height=&quot;400px&quot;))# 向饼图添加数据pie.add(    '',     data_pair=data,    radius=[&quot;50%&quot;, &quot;75%&quot;],    label_opts=opts.LabelOpts(is_show=False),)# 设置全局配置项pie.set_global_opts(    # 配置图例相关的参数    legend_opts=opts.LegendOpts(        pos_left=&quot;legft&quot;,        orient=&quot;vertical&quot;    ))# 设置数据系列配置参数pie.set_series_opts(    # 设置不显示工具提示    tooltip_opts=opts.TooltipOpts(is_show=False),    # 设置饼图标签的样式    label_opts=opts.LabelOpts(formatter=&quot;&#123;b&#125;(&#123;c&#125;): &#123;d&#125;%&quot;))pie.render_notebook()</code></pre><p>运行上面的代码，效果如下图所示。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTkwNTU4LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502190558.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>需要提醒大家注意的是，pyecharts 并不能直接使用 NumPy 的 ndarray 和 Pandas 的 Series、DataFrame 为其提供数据，它需要的是 Python 原生的数据类型。可能大家也注意到了，上面的代码中，我们使用的都是列表、元组这样的数据类型。</p><p>最后，我们来看看如何绘制地图，绘制地图首先需要安装额外的依赖库来获取地图相关信息，命令如下所示。</p><pre><code class="language-Bash">pip install echarts-countries-pypkg echarts-china-provinces-pypkg echarts-china-cities-pypkg echarts-china-counties-pypkg</code></pre><p>在 Jupyter 中，可以直接使用魔法指令进行安装，如下所示。</p><pre><code class="language-Bash">%pip install echarts-countries-pypkg%pip install echarts-china-provinces-pypkg%pip install echarts-china-cities-pypkg%pip install echarts-china-counties-pypkg</code></pre><blockquote><p><strong>说明</strong>：上面的四个库分别包含了世界各国、中国省级行政区域、中国市级行政区域、中国区 / 县级行政区域的数据。</p></blockquote><p>然后，我们将全国各省抖音大 V 的数据放在一个列表中，代码如下所示。</p><pre><code class="language-Python">data = [    ('广东', 594), ('浙江', 438), ('四川', 316), ('北京', 269), ('山东', 248),    ('江苏', 234), ('湖南', 196), ('福建', 166), ('河南', 153), ('辽宁', 152),    ('上海', 138), ('河北', 86), ('安徽', 79), ('湖北', 75), ('黑龙江', 70),     ('陕西', 63), ('吉林', 59), ('江西', 56), ('重庆', 46), ('贵州', 39),    ('山西', 37), ('云南', 33), ('广西', 24), ('天津', 22), ('新疆', 21),    ('海南', 18), ('内蒙古', 14), ('台湾', 11), ('甘肃', 7), ('广西壮族自治区', 4),    ('香港', 4), ('青海', 3), ('新疆维吾尔自治区', 3), ('内蒙古自治区', 3), ('宁夏', 1)]</code></pre><p>接下来，我们使用 pyecharts 在地图上标记各省抖音大 V 人数。</p><pre><code class="language-Python">from pyecharts.charts import Mapmap_chart = Map()map_chart.add('', data, 'china', is_roam=False)map_chart.render_notebook()</code></pre><p>代码的运行效果如下图所示，将鼠标置于地图上时，会高亮对应的省并看到相关的信息。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMTkyMTQyLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502192142.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>和 seaborn 一样，我们建议大家参考官方提供的示例来使用 pyecharts，我们可以在 pyecharts <span class="exturl" data-url="aHR0cHM6Ly9weWVjaGFydHMub3JnLyMvemgtY24v">官方网站</span>的左侧导航栏中找到 “图表类型” 选项，下面每种类型的图表都有对应的官方示例，很多代码是可以直接使用的，我们需要做的就是将数据换成自己的数据。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化-1</title>
      <link href="/computer-science/python/basic/75.%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-1/"/>
      <url>/computer-science/python/basic/75.%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-1/</url>
      
        <content type="html"><![CDATA[<h2 id="数据可视化-1"><a class="anchor" href="#数据可视化-1">#</a> 数据可视化 - 1</h2><p>在完成了对数据的透视之后，我们可以将数据透视的结果通过可视化的方式呈现出来，简单的说，就是将数据变成漂亮的统计图表，然后进一步发现和解读数据背后隐藏的商业价值。在之前的课程中，我们已经为大家展示过用使用 <code>Series</code>  或 <code>DataFrame</code>  对象的 <code>plot</code>  方法生成可视化图表的操作，本章我们为大家讲解 <code>plot</code>  方法的基石，它就是大名鼎鼎的 <code>matplotlib</code>  库。</p><h3 id="常用的图表类型"><a class="anchor" href="#常用的图表类型">#</a> 常用的图表类型</h3><p>常用的图表类型及其应用场景如下图所示。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwMzE1MTkzMzI2LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220315193326.png</span>&quot; style=&quot;zoom:65%&quot;&gt;</p><h3 id="matplotlib-的安装和导入"><a class="anchor" href="#matplotlib-的安装和导入">#</a> Matplotlib 的安装和导入</h3><p>如果还没有安装 <code>matplotlib</code>  库，可以使用 Python 的包管理工具 pip 来安装，命令如下所示。</p><pre><code class="language-Shell">pip install matplotlib</code></pre><p>在 Notebook 中，我们可以用下面的方式导入 <code>matplotlib</code> 。为了解决图表中文显示的问题，我们可以通过 <code>pyplot</code>  模块的 <code>rcParams</code>  属性修改配置参数，具体的操作如下所示。</p><pre><code class="language-Python">import matplotlib.pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei', 'Songti SC']plt.rcParams['axes.unicode_minus'] = False</code></pre><blockquote><p><strong>说明</strong>：上面代码中的 <code>SimHei</code>  是字体名称，大家可以通过百度云盘下载并安装该字体，链接地址：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXJRdWpsNVJRbjlSN1BhZEIyWjVnX2clRUYlQkMlOEMlRTYlOEYlOTAlRTUlOEYlOTYlRTclQTAlODE6ZTdiNCVFRiVCQyU5Qg==">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g，提取码:e7b4；</span> <code>Songti SC</code>  是我的 macOS 上自带的字体，对于 macOS 或 Windows 系统，字体的名字都可以在用户主目录下的 <code>.matplotlib</code>  文件夹下的 <code>fontlist-v330.json</code>  文件中找到。值得注意的是，使用中文字体后坐标轴上的负号会显示不出来，所以需要将 <code>axes.unicode_minus</code>  参数设置为 <code>False</code> ，这样才能让坐标轴上的负号正常显示。</p></blockquote><p>通过下面的魔法指令，我们可以在绘图时生成<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTlGJUEyJUU5JTg3JThGJUU1JTlCJUJFJUU1JUJEJUEy">矢量图</span>（SVG - Scalable Vector Graphics）。</p><pre><code class="language-Python">%config InlineBackend.figure_format='svg'</code></pre><h3 id="绘图的流程"><a class="anchor" href="#绘图的流程">#</a> 绘图的流程</h3><h4 id="创建画布"><a class="anchor" href="#创建画布">#</a> 创建画布</h4><p><code>pyplot</code>  模块的 <code>figure</code>  函数可以用来创建画布，创建画布时，可以通过 <code>figsize</code>  参数指定画布的尺寸（默认值是 <code>[6.4, 4.8]</code> ）；可以通过 <code>dpi</code>  参数设置绘图的分辨率，因为 <code>dpi</code>  代表了每英寸的像素点数量。除此之外，还可以通过 <code>facecolor</code>  参数设置画布的背景色。 <code>figure</code>  函数的返回值是一个 <code>Figure</code>  对象，它代表了绘图使用的画布，我们可以基于画布来创建绘图使用的坐标系。</p><pre><code class="language-Python">plt.figure(figsize=(8, 4), dpi=120, facecolor='darkgray')</code></pre><h4 id="创建坐标系"><a class="anchor" href="#创建坐标系">#</a> 创建坐标系</h4><p>可以直接使用 <code>pyplot</code>  模块的 <code>subplot</code>  函数来创建坐标系，该函数会返回 <code>Axes</code>  对象。 <code>subplot</code>  的前三个参数分别用来指定整个画布分成几行几列以及当前坐标系的索引，这三个参数的默认值都是 <code>1</code> 。如果需要在画布上创建多个坐标系，就需要使用该函数，否则就直接使用默认的也是唯一的坐标系。当然，也可以通过上面创建的 <code>Figure</code>  对象的 <code>add_subplot</code>  方法或 <code>add_axes</code>  方法来创建坐标系，前者跟 <code>subplot</code>  函数的作用一致，后者会产生嵌套的坐标系。</p><pre><code class="language-Python">plt.subplot(2, 2, 1)</code></pre><h4 id="绘制图像"><a class="anchor" href="#绘制图像">#</a> 绘制图像</h4><h5 id="折线图"><a class="anchor" href="#折线图">#</a> 折线图</h5><p>在绘图时，如果没有先调用 <code>figure</code>  函数和 <code>subplot</code>  函数，我们将使用默认的画布和坐标系，如果要绘制折线图，可以使用 <code>pyplot</code>  模块的 <code>plot</code>  函数，并指定横轴和纵轴的数据。折线图最适合用来观察数据的趋势，尤其是当横坐标代表时间的情况下。我们可以使用 <code>plot</code>  函数的 <code>color</code>  参数来定制折线的颜色，可以使用 <code>marker</code>  参数来定制数据点的标记（例如： <code>*</code>  表示五角星， <code>^</code>  表示三角形， <code>o</code>  表示小圆圈等），可以使用 <code>linestyle</code>  参数来定制折线的样式（例如： <code>-</code>  表示实线， <code>--</code>  表示虚线， <code>:</code>  表示点线等），可以使用 <code>linewidth</code>  参数来定制折线的粗细。 下面的代码绘制了一条正弦曲线，其中 <code>marker='*'</code>  会将数据点的标记设置为五角星形状，而 <code>color='red'</code>  会将折线绘制为红色。</p><pre><code class="language-Python">import numpy as npx = np.linspace(-2 * np.pi, 2 * np.pi, 120)y = np.sin(x)# 创建画布plt.figure(figsize=(8, 4), dpi=120)# 绘制折线图plt.plot(x, y, linewidth=2, marker='*', color='red')# 显示绘图plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAxMTczMzQ0LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220501173344.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>如果要在一个坐标系上同时绘制正弦和余弦曲线，可以对上面的代码稍作修改。</p><pre><code class="language-Python">x = np.linspace(-2 * np.pi, 2 * np.pi, 120)y1, y2 = np.sin(x), np.cos(x)plt.figure(figsize=(8, 4), dpi=120)plt.plot(x, y1, linewidth=2, marker='*', color='red')plt.plot(x, y2, linewidth=2, marker='^', color='blue')# 定制图表的标注，其中的arrowprops是定制箭头样式的参数plt.annotate('sin(x)', xytext=(0.5, -0.75), xy=(0, -0.25), fontsize=12, arrowprops=&#123;    'arrowstyle': '-&gt;', 'color': 'darkgreen', 'connectionstyle': 'angle3, angleA=90, angleB=0'&#125;)plt.annotate('cos(x)', xytext=(-3, 0.75), xy=(-1.25, 0.5), fontsize=12, arrowprops=&#123;    'arrowstyle': '-&gt;', 'color': 'darkgreen', 'connectionstyle': 'arc3, rad=0.35'&#125;)plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMDk1OTQ5LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502095949.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>如果要使用两个坐标系分别绘制正弦和余弦，可以用上面提到的 <code>subplot</code>  函数来创建坐标系，然后再绘图。</p><pre><code class="language-Python">plt.figure(figsize=(8, 4), dpi=120)# 创建坐标系（第1个图）plt.subplot(2, 1, 1)plt.plot(x, y1, linewidth=2, marker='*', color='red')# 创建坐标系（第2个图）plt.subplot(2, 1, 2)plt.plot(x, y2, linewidth=2, marker='^', color='blue')plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAxMTczNDQ2LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220501173446.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>当然也可以像下面这么做，大家可以运行代码看看跟上面的图有什么区别。</p><pre><code class="language-Python">plt.figure(figsize=(8, 4), dpi=120)plt.subplot(1, 2, 1)plt.plot(x, y1, linewidth=2, marker='*', color='red')plt.subplot(1, 2, 2)plt.plot(x, y2, linewidth=2, marker='^', color='blue')plt.show()</code></pre><p>然后，再试一试下面这个代码，看看运行效果如何。</p><pre><code class="language-Python">fig = plt.figure(figsize=(10, 4), dpi=120)plt.plot(x, y1, linewidth=2, marker='*', color='red')# 用Figure对象的add_axes方法在现有坐标系中嵌套一个新的坐标系# 该方法的参数是一个四元组，代表了新坐标系在原坐标系中的位置# 前两个值是左下角的位置，后两个值是坐标系的宽度和高度ax = fig.add_axes((0.595, 0.6, 0.3,0.25))ax.plot(x, y2, marker='^', color='blue')ax = fig.add_axes((0.155, 0.2, 0.3,0.25))ax.plot(x, y2, marker='^', color='green')plt.show()</code></pre><h5 id="散点图"><a class="anchor" href="#散点图">#</a> 散点图</h5><p>散点图可以帮助我们了解两个变量的关系，如果需要了解三个变量的关系，可以将散点图升级为气泡图。下面的代码中， <code>x</code>  和 <code>y</code>  两个数组分别表示每个月的收入和每个月网购的支出，如果我们想了解 <code>x</code>  和 <code>y</code>  是否存在相关关系，就可以绘制如下所示的散点图。</p><pre><code class="language-Python">x = np.array([5550,7500,10500,15000,20000,25000,30000,40000])y = np.array([800,1800,1250,2000,1800,2100,2500,3500])plt.figure(figsize=(6, 4), dpi=120)plt.scatter(x, y)plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAxMTczMDM0LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220501173034.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><h5 id="柱状图"><a class="anchor" href="#柱状图">#</a> 柱状图</h5><p>在对比数据的差异时，柱状图是非常棒的选择，我们可以使用 <code>pyplot</code>  模块的 <code>bar</code>  函数来生成柱状图，也可以使用 <code>barh</code>  函数来生成水平柱状图。我们先为柱状图准备一些数据，代码如下所示。</p><pre><code class="language-Python">x = np.arange(4)y1 = np.random.randint(20, 50, 4)y2 = np.random.randint(10, 60, 4)</code></pre><p>绘制柱状图的代码。</p><pre><code class="language-Python">plt.figure(figsize=(6, 4), dpi=120)# 通过横坐标的偏移，让两组数据对应的柱子分开# width参数控制柱子的粗细，label参数为柱子添加标签plt.bar(x - 0.1, y1, width=0.2, label='销售A组')plt.bar(x + 0.1, y2, width=0.2, label='销售B组')# 定制横轴的刻度plt.xticks(x, labels=['Q1', 'Q2', 'Q3', 'Q4'])# 定制显示图例plt.legend()plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAxMTczNTU3LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220501173557.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>如果想绘制堆叠柱状图，可以对上面的代码稍作修改，如下所示。</p><pre><code class="language-Python">labels = ['Q1', 'Q2', 'Q3', 'Q4']plt.figure(figsize=(6, 4), dpi=120)plt.bar(labels, y1, width=0.4, label='销售A组')# 注意：堆叠柱状图的关键是将之前的柱子作为新柱子的底部# 可以通过bottom参数指定底部数据，新柱子绘制在底部数据之上plt.bar(labels, y2, width=0.4, bottom=y1, label='销售B组')plt.legend(loc='lower right')plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAxMTczNjQ1LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220501173645.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><h5 id="饼状图"><a class="anchor" href="#饼状图">#</a> 饼状图</h5><p>饼状图通常简称为饼图，是一个将数据划分为几个扇形区域的统计图表，它主要用于描述数量、频率等之间的相对关系。在饼图中，每个扇形区域的大小就是其所表示的数量的比例，这些扇形区域合在一起刚好是一个完整的饼。在需要展示数据构成的场景下，饼状图、树状图和瀑布图是不错的选择，我们可以使用 <code>pyplot</code>  模块的 <code>pie</code>  函数来绘制饼图，代码如下所示。</p><pre><code class="language-Python">data = np.random.randint(100, 500, 7)labels = ['苹果', '香蕉', '桃子', '荔枝', '石榴', '山竹', '榴莲']plt.figure(figsize=(5, 5), dpi=120)plt.pie(    data,    # 自动显示百分比    autopct='%.1f%%',    # 饼图的半径    radius=1,    # 百分比到圆心的距离    pctdistance=0.8,    # 颜色（随机生成）    colors=np.random.rand(7, 3),    # 分离距离    # explode=[0.05, 0, 0.1, 0, 0, 0, 0],    # 阴影效果    # shadow=True,    # 字体属性    textprops=dict(fontsize=8, color='black'),    # 楔子属性（生成环状饼图的关键）    wedgeprops=dict(linewidth=1, width=0.35),    # 标签    labels=labels)# 定制图表的标题plt.title('水果销售额占比')plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMDk0MTI4LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502094128.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><blockquote><p><strong>说明</strong>：大家可以试一试将上面代码中被注释的部分恢复，看看有什么样的效果。</p></blockquote><h5 id="直方图"><a class="anchor" href="#直方图">#</a> 直方图</h5><p>在统计学中，直方图是一种展示数据分布情况的图形，是一种二维统计图表，它的两个坐标分别是统计样本和该样本对应的某个属性的度量。下面的数据是某学校 100 名男学生的身高，如果我们想知道数据的分布，就可以使用直方图。</p><pre><code class="language-Python">heights = np.array([    170, 163, 174, 164, 159, 168, 165, 171, 171, 167,     165, 161, 175, 170, 174, 170, 174, 170, 173, 173,     167, 169, 173, 153, 165, 169, 158, 166, 164, 173,     162, 171, 173, 171, 165, 152, 163, 170, 171, 163,     165, 166, 155, 155, 171, 161, 167, 172, 164, 155,     168, 171, 173, 169, 165, 162, 168, 177, 174, 178,     161, 180, 155, 155, 166, 175, 159, 169, 165, 174,     175, 160, 152, 168, 164, 175, 168, 183, 166, 166,     182, 174, 167, 168, 176, 170, 169, 173, 177, 168,     172, 159, 173, 185, 161, 170, 170, 184, 171, 172])</code></pre><p>可以使用 <code>pyplot</code>  模块的 <code>hist</code>  函数来绘制直方图，代码如下所示。</p><pre><code class="language-Python"># 将身高数据分到以下8个组中bins = np.array([150, 155, 160, 165, 170, 175, 180, 185, 190])plt.figure(figsize=(6, 4), dpi=120)# density参数默认值为False，表示纵轴显示频数# 将density参数设置为True，纵轴会显示概率密度plt.hist(heights, bins, density=True)# 定制横轴标签plt.xlabel('身高')# 定制纵轴标签plt.ylabel('概率密度')plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAyMDkzOTI0LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220502093924.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><h5 id="箱线图"><a class="anchor" href="#箱线图">#</a> 箱线图</h5><p>箱线图又叫箱型图或盒须图，是一种用于展示一组数据分散情况的统计图表，如下所示。因图形如箱子，而且在上下四分位数之外有线条像胡须延伸出去而得名。在箱线图中，箱子的上边界是上四分位数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">Q_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的位置，箱子的下边界是下四分位数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Q_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的位置，箱子中间的线条是中位数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Q_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的位置，而箱子的长度就是四分位距离（IQR）。除此之外，箱子上方线条的边界是最大值，箱子下方线条的边界是最小值，这两条线之外的点就是离群值（outlier）。所谓离群值，是指数据小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>1</mn></msub><mo>−</mo><mn>1.5</mn><mo>×</mo><mi>I</mi><mi>Q</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">Q_1 - 1.5 \times IQR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">Q</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 或数据大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>3</mn></msub><mo>+</mo><mn>1.5</mn><mo>×</mo><mi>I</mi><mi>Q</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">Q_3 + 1.5 \times IQR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">Q</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 的值，公式中的 <code>1.5</code>  还可以替换为 <code>3</code>  来发现极端离群值（extreme outlier），而介于 <code>1.5</code>  到 <code>3</code>  之间的离群值通常称之为适度离群值（mild outlier）。</p><p>可以使用 <code>pyplot</code>  模块的 <code>boxplot</code>  函数来绘制箱线图，代码如下所示。</p><pre><code class="language-Python"># 数组中有47个[0, 100)范围的随机数data = np.random.randint(0, 100, 47)# 向数组中添加三个可能是离群点的数据data = np.append(data, 160)data = np.append(data, 200)data = np.append(data, -50)plt.figure(figsize=(6, 4), dpi=120)# whis参数的默认值是1.5，将其设置为3可以检测极端离群值# showmeans=True表示在图中标记均值的位置plt.boxplot(data, whis=1.5, showmeans=True, notch=True)# 定制纵轴的取值范围plt.ylim([-100, 250])# 定制横轴的刻度plt.xticks([1], labels=['data'])plt.show()</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjIwNTAxMTcyODAyLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20220501172802.png</span>&quot; style=&quot;zoom:50%;&quot; /&gt;</p><blockquote><p><strong>说明</strong>：由于数据是随机生成的，所以大家运行上面的代码生成的图可能跟我这里并不相同。</p></blockquote><h4 id="显示或保存图像"><a class="anchor" href="#显示或保存图像">#</a> 显示或保存图像</h4><p>可以使用 <code>pyplot</code>  模块的 <code>show</code>  函数来显示绘制的图表，我们在上面的代码中使用过这个函数。如果希望保存图表，可以使用 <code>savefig</code>  函数。需要注意的是，如果要同时显示和保存图表，应该先执行 <code>savefig</code>  函数，再执行 <code>show</code>  函数，因为在调用 <code>show</code>  函数时，图表已经被释放，位于 <code>show</code>  函数之后的 <code>savefig</code>  保存的只是一个空白的区域。</p><pre><code class="language-Python">plt.savefig('chart.png')plt.show()</code></pre><h3 id="其他图表"><a class="anchor" href="#其他图表">#</a> 其他图表</h3><p>使用 matplotlib，我们还可以绘制出其他的统计图表（如：雷达图、玫瑰图、热力图等），但实际工作中，使用频率最高的几类图表我们在上面已经为大家完整的展示出来了。此外，matplotlib 还有很多对统计图表进行定制的细节，例如定制坐标轴、定制图表上的文字和标签等。如果想了解如何用 matplotlib 绘制和定制更多的统计图表，可以直接查看 matplotlib 官方网站上的<span class="exturl" data-url="aHR0cHM6Ly9tYXRwbG90bGliLm9yZy9zdGFibGUvdHV0b3JpYWxzL2luZGV4Lmh0bWw=">文档</span>和<span class="exturl" data-url="aHR0cHM6Ly9tYXRwbG90bGliLm9yZy9zdGFibGUvZ2FsbGVyeS9pbmRleC5odG1s">示例</span>。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas的应用-5</title>
      <link href="/computer-science/python/basic/74.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-5/"/>
      <url>/computer-science/python/basic/74.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-5/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas的应用-5"><a class="anchor" href="#pandas的应用-5">#</a> Pandas 的应用 - 5</h2><h3 id="dataframe的应用"><a class="anchor" href="#dataframe的应用">#</a> DataFrame 的应用</h3><h4 id="窗口计算"><a class="anchor" href="#窗口计算">#</a> 窗口计算</h4><p><code>DataFrame</code>  对象的 <code>rolling</code>  方法允许我们将数据置于窗口中，然后就可以使用函数对窗口中的数据进行运算和处理。例如，我们获取了某只股票近期的数据，想制作 5 日均线和 10 日均线，那么就需要先设置窗口再进行运算。我们可以使用三方库 <code>pandas-datareader</code>  来获取指定的股票在某个时间段内的数据，具体的操作如下所示。</p><p>安装 <code>pandas-datareader</code>  三方库。</p><pre><code class="language-Bash">pip install pandas-datareader</code></pre><p>通过 <code>pandas-datareader</code>  提供的 <code>get_data_stooq</code>  从 Stooq 网站获取百度（股票代码：BIDU）近期股票数据。</p><pre><code class="language-Python">import pandas_datareader as pdrbaidu_df = pdr.get_data_stooq('BIDU', start='2021-11-22', end='2021-12-7')baidu_df.sort_index(inplace=True)baidu_df</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjA1NzEwLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208205710.png</span>&quot; style=&quot;zoom:38%;&quot;&gt;</p><p>上面的 <code>DataFrame</code>  有 <code>Open</code> 、 <code>High</code> 、 <code>Low</code> 、 <code>Close</code> 、 <code>Volume</code>  五个列，分别代码股票的开盘价、最高价、最低价、收盘价和成交量，接下来我们对百度的股票数据进行窗口计算。</p><pre><code class="language-Python">baidu_df.rolling(5).mean()</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjA1OTMyLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208205932.png</span>&quot; style=&quot;zoom:38%;&quot;&gt;</p><p>上面的 <code>Close</code>  列的数据就是我们需要的 5 日均线，当然，我们也可以用下面的方法，直接在 <code>Close</code>  列对应的 <code>Series</code>  对象上计算 5 日均线。</p><pre><code class="language-Python">baidu_df.Close.rolling(5).mean()</code></pre><p>输出：</p><pre><code>Date2021-11-22        NaN2021-11-23        NaN2021-11-24        NaN2021-11-26        NaN2021-11-29    150.6082021-11-30    151.0142021-12-01    150.6822021-12-02    150.1962021-12-03    147.0622021-12-06    146.5342021-12-07    146.544Name: Close, dtype: float64</code></pre><h4 id="相关性判定"><a class="anchor" href="#相关性判定">#</a> 相关性判定</h4><p>在统计学中，我们通常使用协方差（covariance）来衡量两个随机变量的联合变化程度。如果变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的较大值主要与另一个变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的较大值相对应，而两者较小值也相对应，那么两个变量倾向于表现出相似的行为，协方差为正。如果一个变量的较大值主要对应于另一个变量的较小值，则两个变量倾向于表现出相反的行为，协方差为负。简单的说，协方差的正负号显示着两个变量的相关性。方差是协方差的一种特殊情况，即变量与自身的协方差。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>Y</mi><mo>−</mo><mi>υ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo>⋅</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>μ</mi><mi>υ</mi></mrow><annotation encoding="application/x-tex">cov(X,Y) = E((X - \mu)(Y - \upsilon)) = E(X \cdot Y) - \mu\upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">μ</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">υ</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span><span class="mord mathnormal" style="margin-right:0.03588em;">υ</span></span></span></span></span></p><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 是统计独立的，那么二者的协方差为 0，这是因为在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 独立的情况下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo>⋅</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>μ</mi><mi>υ</mi></mrow><annotation encoding="application/x-tex">E(X \cdot Y) = E(X) \cdot E(Y) = \mu\upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span><span class="mord mathnormal" style="margin-right:0.03588em;">υ</span></span></span></span></span></p><p>协方差的数值大小取决于变量的大小，通常是不容易解释的，但是正态形式的协方差大小可以显示两变量线性关系的强弱。在统计学中，皮尔逊积矩相关系数就是正态形式的协方差，它用于度量两个变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 之间的相关程度（线性相关），其值介于 <code>-1</code>  到 <code>1</code>  之间。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>ρ</mi><mrow><mi>X</mi><mo separator="true">,</mo><mi>Y</mi></mrow><mo>=</mo><mfrac><mrow><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>σ</mi><mi>X</mi></msub><msub><mi>σ</mi><mi>Y</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\rho{X,Y} = \frac {cov(X, Y)} {\sigma_{X}\sigma_{Y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ρ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.263em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>估算样本的协方差和标准差，可以得到样本皮尔逊系数，通常用希腊字母 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ρ</span></span></span></span> 表示。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>ρ</mi><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><mi>X</mi><mo>ˉ</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><mi>Y</mi><mo>ˉ</mo></mover><mo stretchy="false">)</mo></mrow><mrow><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><mi>X</mi><mo>ˉ</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><mi>Y</mi><mo>ˉ</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">\rho = \frac {\sum_{i=1}^{n}(X_i - \bar{X})(Y_i - \bar{Y})} {\sqrt{\sum_{i=1}^{n}(X_i - \bar{X})^2} \sqrt{\sum_{i=1}^{n}(Y_i - \bar{Y})^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2398200000000004em;vertical-align:-1.7300000000000004em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.50982em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.2452em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2452em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2051999999999996em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5948000000000001em;"><span></span></span></span></span></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2452em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2051999999999996em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5948000000000001em;"><span></span></span></span></span></span></span></span><span style="top:-3.4752em;"><span class="pstrut" style="height:3.2452em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.9349100000000004em;"><span class="pstrut" style="height:3.2452em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7300000000000004em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>我们用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ρ</span></span></span></span> 值判断指标的相关性时遵循以下两个步骤。</p><ol><li>判断指标间是正相关、负相关，还是不相关。<ul><li>当 $ \rho \gt 0 $，认为变量之间是正相关，也就是两者的趋势一致。</li><li>当 $ \rho \lt 0 $，认为变量之间是负相关，也就是两者的趋势相反。</li><li>当 $ \rho = 0 $，认为变量之间是不相关的，但并不代表两个指标是统计独立的。</li></ul></li><li>判断指标间的相关程度。<ul><li>当 $ \rho $ 的绝对值在 $ [0.6,1] $ 之间，认为变量之间是强相关的。</li><li>当 $ \rho $ 的绝对值在 $ [0.1,0.6) $ 之间，认为变量之间是弱相关的。</li><li>当 $ \rho $ 的绝对值在 $ [0,0.1) $ 之间，认为变量之间没有相关性。</li></ul></li></ol><p>皮尔逊相关系数适用于：</p><ol><li>两个变量之间是线性关系，都是连续数据。</li><li>两个变量的总体是正态分布，或接近正态的单峰分布。</li><li>两个变量的观测值是成对的，每对观测值之间相互独立。</li></ol><p><code>DataFrame</code>  对象的 <code>cov</code>  方法和 <code>corr</code>  方法分别用于计算协方差和相关系数， <code>corr</code>  方法的第一个参数 <code>method</code>  的默认值是 <code>pearson</code> ，表示计算皮尔逊相关系数；除此之外，还可以指定 <code>kendall</code>  或 <code>spearman</code>  来获得肯德尔系数或斯皮尔曼等级相关系数。</p><p>接下来，我们从名为 <code>boston_house_price.csv</code>  的文件中获取著名的<span class="exturl" data-url="aHR0cHM6Ly93d3cuaGV5d2hhbGUuY29tL213L2RhdGFzZXQvNTkwYmQ1OTU4MTJlZGUzMmI3M2Y1NWYy">波士顿房价数据集</span>来创建一个 <code>DataFrame</code> ，我们通过 <code>corr</code>  方法计算可能影响房价的 <code>13</code>  个因素中，哪些跟房价是正相关或负相关的，代码如下所示。</p><pre><code class="language-Python">boston_df = pd.read_csv('data/csv/boston_house_price.csv')boston_df.corr()</code></pre><blockquote><p><strong>说明</strong>：如果需要上面例子中的 CSV 文件，可以通过下面的百度云盘地址进行获取，数据在《从零开始学数据分析》目录中。链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXJRdWpsNVJRbjlSN1BhZEIyWjVnX2c=">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</span>，提取码：e7b4。</p></blockquote><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjEzMzI1LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208213325.png</span>&quot;&gt;</p><p>斯皮尔曼相关系数对数据条件的要求没有皮尔逊相关系数严格，只要两个变量的观测值是成对的等级评定资料，或者是由连续变量观测资料转化得到的等级资料，不论两个变量的总体分布形态、样本容量的大小如何，都可以用斯皮尔曼等级相关系数来进行研究。我们通过下面的方式来计算斯皮尔曼相关系数。</p><pre><code class="language-Python">boston_df.corr('spearman')</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjEzNTE4LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208213518.png</span>&quot;&gt;</p><p>在 Notebook 或 JupyterLab 中，我们可以为 <code>PRICE</code>  列添加渐变色，用颜色直观的展示出跟房价负相关、正相关、不相关的列， <code>DataFrame</code>  对象 <code>style</code>  属性的 <code>background_gradient</code>  方法可以完成这个操作，代码如下所示。</p><pre><code class="language-Python">boston_df.corr('spearman').style.background_gradient('RdYlBu', subset=['PRICE'])</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjE1MjI4LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208215228.png</span>&quot;&gt;</p><p>上面代码中的 <code>RdYlBu</code>  代表的颜色如下所示，相关系数的数据值越接近 <code>1</code> ，颜色越接近红色；数据值越接近 <code>1</code> ，颜色越接近蓝色；数据值在 <code>0</code>  附件则是黄色。</p><pre><code class="language-Python">plt.get_cmap('RdYlBu')</code></pre><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjE1MDU3LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208215057.png</span>&quot;&gt;</p><h3 id="index的应用"><a class="anchor" href="#index的应用">#</a> Index 的应用</h3><p>我们再来看看 <code>Index</code>  类型，它为 <code>Series</code>  和 <code>DataFrame</code>  对象提供了索引服务，常用的 <code>Index</code>  有以下几种。</p><h4 id="范围索引rangeindex"><a class="anchor" href="#范围索引rangeindex">#</a> 范围索引（RangeIndex）</h4><p>代码：</p><pre><code class="language-Python">sales_data = np.random.randint(400, 1000, 12)month_index = pd.RangeIndex(1, 13, name='月份')ser = pd.Series(data=sales_data, index=month_index)ser</code></pre><p>输出：</p><pre><code>月份1     7032     7053     5574     9435     9616     6157     7888     9859     92110    95111    87412    609dtype: int64</code></pre><h4 id="分类索引categoricalindex"><a class="anchor" href="#分类索引categoricalindex">#</a> 分类索引（CategoricalIndex）</h4><p>代码：</p><pre><code class="language-Python">cate_index = pd.CategoricalIndex(    ['苹果', '香蕉', '苹果', '苹果', '桃子', '香蕉'],    ordered=True,    categories=['苹果', '香蕉', '桃子'])ser = pd.Series(data=amount, index=cate_index)ser</code></pre><p>输出：</p><pre><code>苹果    6香蕉    6苹果    7苹果    6桃子    8香蕉    6dtype: int64</code></pre><p>代码：</p><pre><code class="language-Python">ser.groupby(level=0).sum()</code></pre><p>输出：</p><pre><code>苹果    19香蕉    12桃子     8dtype: int64</code></pre><h4 id="多级索引multiindex"><a class="anchor" href="#多级索引multiindex">#</a> 多级索引（MultiIndex）</h4><p>代码：</p><pre><code class="language-Python">ids = np.arange(1001, 1006)sms = ['期中', '期末']index = pd.MultiIndex.from_product((ids, sms), names=['学号', '学期'])courses = ['语文', '数学', '英语']scores = np.random.randint(60, 101, (10, 3))df = pd.DataFrame(data=scores, columns=courses, index=index)df</code></pre><blockquote><p><strong>说明</strong>：上面的代码使用了 <code>MultiIndex</code>  的类方法 <code>from_product</code> ，该方法通过 <code>ids</code>  和 <code>sms</code>  两组数据的笛卡尔积构造了多级索引。</p></blockquote><p>输出：</p><pre><code>             语文 数学 英语学号学期1001  期中937760      期末9398841002  期中647871      期末7071971003  期中728897      期末99100631004  期中807161      期末9162721005  期中829567      期末847886</code></pre><p>代码：</p><pre><code class="language-Python"># 计算每个学生的成绩，期中占25%，期末占75%df.groupby(level=0).agg(lambda x: x.values[0] * 0.25 + x.values[1] * 0.75)</code></pre><p>输出：</p><pre><code>        语文    数学    英语学号100193.0092.7578.00100268.5072.7590.50100392.2597.0071.50100488.2564.2569.25100583.5082.2581.25</code></pre><h4 id="日期时间索引datetimeindex"><a class="anchor" href="#日期时间索引datetimeindex">#</a> 日期时间索引（DatetimeIndex）</h4><ol><li><p>通过 <code>date_range()</code>  函数，我们可以创建日期时间索引，代码如下所示。</p><p>代码：</p><pre><code class="language-Python">pd.date_range('2021-1-1', '2021-6-1', periods=10)</code></pre><p>输出：</p><pre><code>DatetimeIndex(['2021-01-01 00:00:00', '2021-01-17 18:40:00',               '2021-02-03 13:20:00', '2021-02-20 08:00:00',               '2021-03-09 02:40:00', '2021-03-25 21:20:00',               '2021-04-11 16:00:00', '2021-04-28 10:40:00',               '2021-05-15 05:20:00', '2021-06-01 00:00:00'],              dtype='datetime64[ns]', freq=None)</code></pre><p>代码：</p><pre><code class="language-Python">pd.date_range('2021-1-1', '2021-6-1', freq='W')</code></pre><p>输出：</p><pre><code>DatetimeIndex(['2021-01-03', '2021-01-10', '2021-01-17', '2021-01-24',               '2021-01-31', '2021-02-07', '2021-02-14', '2021-02-21',               '2021-02-28', '2021-03-07', '2021-03-14', '2021-03-21',               '2021-03-28', '2021-04-04', '2021-04-11', '2021-04-18',               '2021-04-25', '2021-05-02', '2021-05-09', '2021-05-16',               '2021-05-23', '2021-05-30'],              dtype='datetime64[ns]', freq='W-SUN')</code></pre></li><li><p>通过 <code>DateOffset</code>  类型，我们可以设置时间差并和 <code>DatetimeIndex</code>  进行运算，具体的操作如下所示。</p><p>代码：</p><pre><code class="language-Python">index = pd.date_range('2021-1-1', '2021-6-1', freq='W')index - pd.DateOffset(days=2)</code></pre><p>输出：</p><pre><code>DatetimeIndex(['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22',               '2021-01-29', '2021-02-05', '2021-02-12', '2021-02-19',               '2021-02-26', '2021-03-05', '2021-03-12', '2021-03-19',               '2021-03-26', '2021-04-02', '2021-04-09', '2021-04-16',               '2021-04-23', '2021-04-30', '2021-05-07', '2021-05-14',               '2021-05-21', '2021-05-28'],              dtype='datetime64[ns]', freq=None)</code></pre><p>代码：</p><pre><code class="language-Python">index + pd.DateOffset(days=2)</code></pre><p>输出：</p><pre><code>DatetimeIndex(['2021-01-05', '2021-01-12', '2021-01-19', '2021-01-26',               '2021-02-02', '2021-02-09', '2021-02-16', '2021-02-23',               '2021-03-02', '2021-03-09', '2021-03-16', '2021-03-23',               '2021-03-30', '2021-04-06', '2021-04-13', '2021-04-20',               '2021-04-27', '2021-05-04', '2021-05-11', '2021-05-18',               '2021-05-25', '2021-06-01'],              dtype='datetime64[ns]', freq=None)</code></pre></li><li><p>可以使用 <code>DatatimeIndex</code>  类型的相关方法来处理数据，具体包括：</p><ul><li><p><code>shift()</code>  方法：通过时间前移或后移数据，我们仍然以上面百度股票数据为例，代码如下所示。</p><p>代码：</p><pre><code class="language-Python">baidu_df.shift(3, fill_value=0)</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjIwNTUxLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208220551.png</span>&quot; style=&quot;zoom:150%;&quot;&gt;</p><p>代码：</p><pre><code class="language-Python">baidu_df.shift(-1, fill_value=0)</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjIwNzEzLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208220713.png</span>&quot; style=&quot;zoom:150%;&quot;&gt;</p></li><li><p><code>asfreq()</code>  方法：指定一个时间频率抽取对应的数据，代码如下所示。</p><p>代码：</p><pre><code class="language-Python">baidu_df.asfreq('5D')</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjIxMjAyLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208221202.png</span>&quot;&gt;</p><p>代码：</p><pre><code class="language-Python">baidu_df.asfreq('5D', method='ffill')</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjIxMjQ5LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208221249.png</span>&quot; style=&quot;zoom:150%;&quot;&gt;</p></li><li><p><code>resample()</code>  方法：基于时间对数据进行重采样，相当于根据时间周期对数据进行了分组操作，代码如下所示。</p><p>代码：</p><pre><code class="language-Python">baidu_df.resample('1M').mean()</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjIxNDI5LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208221429.png</span>&quot;&gt;</p></li></ul><blockquote><p><strong>说明</strong>：上面的代码中， <code>W</code>  表示一周， <code>5D</code>  表示 <code>5</code>  天， <code>1M</code>  表示 <code>1</code>  个月。</p></blockquote></li><li><p>时区转换</p><ul><li><p>获取时区信息。</p><pre><code class="language-Python">import pytzpytz.common_timezones</code></pre></li><li><p><code>tz_localize()</code>  方法：将日期时间本地化。</p><p>代码：</p><pre><code class="language-Python">baidu_df = baidu_df.tz_localize('Asia/Chongqing')baidu_df</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjIxOTQ3LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208221947.png</span>&quot;&gt;</p></li><li><p><code>tz_convert()</code>  方法：转换时区。</p><p>代码：</p><pre><code class="language-Python">baidu_df.tz_convert('America/New_York')</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMjA4MjIyNDA0LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211208222404.png</span>&quot;&gt;</p></li></ul></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas的应用-4</title>
      <link href="/computer-science/python/basic/73.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-4/"/>
      <url>/computer-science/python/basic/73.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-4/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas的应用-4"><a class="anchor" href="#pandas的应用-4">#</a> Pandas 的应用 - 4</h2><h3 id="dataframe的应用"><a class="anchor" href="#dataframe的应用">#</a> DataFrame 的应用</h3><h4 id="数据分析"><a class="anchor" href="#数据分析">#</a> 数据分析</h4><p>经过前面的学习，我们已经将数据准备就绪而且变成了我们想要的样子，接下来就是最为重要的数据分析阶段了。当我们拿到一大堆数据的时候，如何从数据中迅速的解读出有价值的信息，这就是数据分析要解决的问题。首先，我们可以获取数据的描述性统计信息，通过描述性统计信息，我们可以了解数据的集中趋势和离散趋势。</p><p>例如，我们有如下所示的学生成绩表。</p><pre><code class="language-Python">import numpy as npimport pandas as pdscores = np.random.randint(50, 101, (5, 3))names = ('关羽', '张飞', '赵云', '马超', '黄忠')courses = ('语文', '数学', '英语')df = pd.DataFrame(data=scores, columns=courses, index=names)df</code></pre><p>输出：</p><pre><code>     语文   数学   英语关羽  96    72    73张飞  72    7097赵云  74    5179马超  100   5454黄忠  89    10088</code></pre><p>我们可以通过 <code>DataFrame</code>  对象的方法 <code>mean</code> 、 <code>max</code> 、 <code>min</code> 、 <code>std</code> 、 <code>var</code>  等方法分别获取每个学生或每门课程的平均分、最高分、最低分、标准差、方差等信息，也可以直接通过 <code>describe</code>  方法直接获取描述性统计信息，代码如下所示。</p><p>计算每门课程成绩的平均分。</p><pre><code class="language-Python">df.mean()</code></pre><p>输出：</p><pre><code>语文    86.2数学    69.4英语    78.2dtype: float64</code></pre><p>计算每个学生成绩的平均分。</p><pre><code class="language-Python">df.mean(axis=1)</code></pre><p>输出：</p><pre><code>关羽    80.333333张飞    79.666667赵云    68.000000马超    69.333333黄忠    92.333333dtype: float64</code></pre><p>计算每门课程成绩的方差。</p><pre><code class="language-Python">df.var()</code></pre><p>输出：</p><pre><code>语文    161.2数学    379.8英语    265.7dtype: float64</code></pre><blockquote><p><strong>说明</strong>：通过方差可以看出，数学成绩波动最大，最不稳定。</p></blockquote><p>获取每门课程的描述性统计信息。</p><pre><code class="language-Python">df.describe()</code></pre><p>输出：</p><pre><code>        语文        数学         英语count   5.0000005.0000005.000000mean    86.20000069.40000078.200000std     12.69645619.48845816.300307min     72.00000051.00000054.00000025%     74.00000054.00000073.00000050%     89.00000070.00000079.00000075%     96.00000072.00000088.000000max     100.000000100.00000097.000000</code></pre><h5 id="排序和top-n"><a class="anchor" href="#排序和top-n">#</a> 排序和 Top-N</h5><p>如果需要对数据进行排序，可以使用 <code>DataFrame</code>  对象的 <code>sort_values</code>  方法，该方法的 <code>by</code>  参数可以指定根据哪个列或哪些列进行排序，而 <code>ascending</code>  参数可以指定升序或是降序。例如，下面的代码展示了如何将学生表按语文成绩排降序。</p><pre><code class="language-Python">df.sort_values(by='语文', ascending=False)</code></pre><p>输出：</p><pre><code>      语文   数学   英语马超100    54  54关羽96     72     73黄忠89     100    88赵云74     51     79张飞72     70     97</code></pre><p>如果 <code>DataFrame</code>  数据量很大，排序将是一个非常耗费时间的操作。有的时候我们只需要获得排前 N 名或后 N 名的数据，这个时候其实没有必要对整个数据进行排序，而是直接利用堆结构找出 Top-N 的数据。 <code>DataFrame</code>  的 <code>nlargest</code>  和 <code>nsmallest</code>  方法就提供对 Top-N 操作的支持，代码如下所示。</p><p>找出语文成绩前 3 名的学生信息。</p><pre><code class="language-Python">df.nlargest(3, '语文')</code></pre><p>输出：</p><pre><code>      语文   数学   英语马超100    54  54关羽96     72     73黄忠89     100    88</code></pre><p>找出数学成绩最低的 3 名学生的信息。</p><pre><code class="language-Python">df.nsmallest(3, '数学')</code></pre><p>输出：</p><pre><code>      语文  数学  英语赵云  74    5179马超  100   5454张飞  72    7097</code></pre><h5 id="分组聚合操作"><a class="anchor" href="#分组聚合操作">#</a> 分组聚合操作</h5><p>我们先从 Excel 文件中读取一组销售数据，然后再为大家演示如何进行分组聚合操作。</p><pre><code class="language-Python">df = pd.read_excel('2020年销售数据.xlsx')df.head()</code></pre><blockquote><p><strong>说明</strong>：如果需要上面例子中的 Excel 文件，可以通过百度云盘进行获取。链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMU5oV3RZY3BGekY3MmN4Y3NvRG9YalE/cHdkPXN3ZzElRUYlQkMlOEMlRTYlOEYlOTAlRTUlOEYlOTYlRTclQTAlODElRUYlQkMlOUFzd2cxJUUzJTgwJTgy">https://pan.baidu.com/s/1NhWtYcpFzF72cxcsoDoXjQ?pwd=swg1，提取码：swg1。</span></p></blockquote><p>输出：</p><pre><code>    销售日期 销售区域   销售渠道  销售订单     品牌    售价  销售数量0   2020-01-01  上海       拼多多    182894-455  八匹马  99    831   2020-01-01  上海       抖音      205635-402  八匹马  219   292   2020-01-01  上海       天猫      205654-021  八匹马  169   853   2020-01-01  上海       天猫      205654-519  八匹马  169   144   2020-01-01  上海       天猫      377781-010  皮皮虾  249   61</code></pre><p>如果我们要统计每个销售区域的销售总额，可以先通过 “售价” 和 “销售数量” 计算出销售额，为 <code>DataFrame</code>  添加一个列，代码如下所示。</p><pre><code class="language-Python">df['销售额'] = df['售价'] * df['销售数量']df.head()</code></pre><p>输出：</p><pre><code>    销售日期 销售区域   销售渠道  销售订单     品牌    售价  销售数量  销售额0   2020-01-01  上海       拼多多    182894-455  八匹马  99    83        82171   2020-01-01  上海       抖音      205635-402  八匹马  219   29        63512   2020-01-01  上海       天猫      205654-021  八匹马  169   85        143653   2020-01-01  上海       天猫      205654-519  八匹马  169   14        23664   2020-01-01  上海       天猫      377781-010  皮皮虾  249   61        15189</code></pre><p>然后再根据 “销售区域” 列对数据进行分组，这里我们使用的是 <code>DataFrame</code>  对象的 <code>groupby</code>  方法。分组之后，我们取 “销售额” 这个列在分组内进行求和处理，代码和结果如下所示。</p><pre><code class="language-Python">df.groupby('销售区域').销售额.sum()</code></pre><p>输出：</p><pre><code>销售区域上海    11610489北京    12477717南京     1767301安徽      895463广东     1617949江苏      537079浙江      687862福建    10178227Name: 销售额, dtype: int64</code></pre><p>如果我们要统计每个月的销售总额，我们可以将 “销售日期” 作为 groupby` 方法的参数，当然这里需要先将 “销售日期” 处理成月，代码和结果如下所示。</p><pre><code class="language-Python">df.groupby(df['销售日期'].dt.month).销售额.sum()</code></pre><p>输出：</p><pre><code>销售日期1     54098552     46084553     41649724     39967705     32390056     28179367     35013048     29481899     263296010    237538511    238528312    1691973Name: 销售额, dtype: int64</code></pre><p>接下来我们将难度升级，统计每个销售区域每个月的销售总额，这又该如何处理呢？事实上， <code>groupby</code>  方法的第一个参数可以是一个列表，列表中可以指定多个分组的依据，大家看看下面的代码和输出结果就明白了。</p><pre><code class="language-Python">df.groupby(['销售区域', df['销售日期'].dt.month]).销售额.sum()</code></pre><p>输出：</p><pre><code>销售区域  销售日期上海      1       1679125          2       1689527          3       1061193          4       1082187          5        841199          6        785404          7        863906          8        734937          9       1107693         10       412108         11       825169         12       528041北京     1       1878234         2       1807787         3       1360666         4       1205989         5        807300         6       1216432         7       1219083         8        645727         9        390077        10       671608        11       678668        12       596146南京     7        841032        10       710962        12       215307安徽     4        341308         5        554155广东     3        388180         8        469390         9        365191        11       395188江苏     4        537079浙江     3        248354         8        439508福建     1       1852496         2       1111141         3       1106579         4        830207         5       1036351         6        816100         7        577283         8        658627         9        769999        10       580707        11       486258        12       352479Name: 销售额, dtype: int64</code></pre><p>如果希望统计出每个区域的销售总额以及每个区域单笔金额的最高和最低，我们可以在 <code>DataFrame</code>  或 <code>Series</code>  对象上使用 <code>agg</code>  方法并指定多个聚合函数，代码和结果如下所示。</p><pre><code class="language-Python">df.groupby('销售区域').销售额.agg(['sum', 'max', 'min'])</code></pre><p>输出：</p><pre><code>          sum        max        min销售区域上海      11610489   116303     948北京      12477717   133411     690南京      1767301    87527      1089安徽      895463     68502      1683广东      1617949    120807     990江苏      537079     114312     3383浙江      687862     90909      3927福建      10178227   87527      897</code></pre><p>如果希望自定义聚合后的列的名字，可以使用如下所示的方法。</p><pre><code class="language-Python">df.groupby('销售区域').销售额.agg(销售总额='sum', 单笔最高='max', 单笔最低='min')</code></pre><p>输出：</p><pre><code>          销售总额   单笔最高    单笔最低销售区域上海      11610489   116303     948北京      12477717   133411     690南京      1767301    87527      1089安徽      895463     68502      1683广东      1617949    120807     990江苏      537079     114312     3383浙江      687862     90909      3927福建      10178227   87527      897</code></pre><p>如果需要对多个列使用不同的聚合函数，例如 “统计每个销售区域销售额的平均值以及销售数量的最低值和最高值”，我们可以按照下面的方式来操作。</p><pre><code class="language-Python">df.groupby('销售区域')[['销售额', '销售数量']].agg(&#123;    '销售额': 'mean', '销售数量': ['max', 'min']&#125;)</code></pre><p>输出：</p><pre><code>         销售额        销售数量         mean          max    min销售区域上海     20622.538188  100    10北京     20125.350000  100    10南京     22370.898734  100    11安徽     26337.147059  98     16广东     32358.980000  98     10江苏     29837.722222  98     15浙江     27514.480000  95     20福建     18306.163669  100    10</code></pre><h5 id="透视表和交叉表"><a class="anchor" href="#透视表和交叉表">#</a> 透视表和交叉表</h5><p>上面的例子中，“统计每个销售区域每个月的销售总额” 会产生一个看起来很长的结果，在实际工作中我们通常把那些行很多列很少的表成为 “窄表”，如果我们不想得到这样的一个 “窄表”，可以使用 <code>DataFrame</code>  的 <code>pivot_table</code>  方法或者是 <code>pivot_table</code>  函数来生成透视表。透视表的本质就是对数据进行分组聚合操作，<strong>根据 A 列对 B 列进行统计</strong>，如果大家有使用 Excel 的经验，相信对透视表这个概念一定不会陌生。例如，我们要 “统计每个销售区域的销售总额”，那么 “销售区域” 就是我们的 A 列，而 “销售额” 就是我们的 B 列，在 <code>pivot_table</code>  函数中分别对应 <code>index</code>  和 <code>values</code>  参数，这两个参数都可以是单个列或者多个列。</p><pre><code class="language-Python">pd.pivot_table(df, index='销售区域', values='销售额', aggfunc='sum')</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMTA2MTgwOTEyLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211106180912.png</span>&quot; style=&quot;zoom:50%&quot;&gt;</p><blockquote><p><strong>注意</strong>：上面的结果操作跟之前用 <code>groupby</code>  的方式得到的结果有一些区别， <code>groupby</code>  操作后，如果对单个列进行聚合，得到的结果是一个 <code>Series</code>  对象，而上面的结果是一个 <code>DataFrame</code>  对象。</p></blockquote><p>如果要统计每个销售区域每个月的销售总额，也可以使用 <code>pivot_table</code>  函数，代码如下所示。</p><pre><code class="language-Python">pd.pivot_table(df, index=['销售区域', df['销售日期'].dt.month], values='销售额', aggfunc='sum')</code></pre><p>上面的操作结果是一个 <code>DataFrame</code> ，但也是一个长长的 “窄表”，如果希望做成一个行比较少列比较多的 “宽表”，可以将 <code>index</code>  参数中的列放到 <code>columns</code>  参数中，代码如下所示。</p><pre><code class="language-Python">pd.pivot_table(    df, index='销售区域', columns=df['销售日期'].dt.month,     values='销售额', aggfunc='sum', fill_value=0)</code></pre><blockquote><p><strong>说明</strong>： <code>pivot_table</code>  函数的 <code>fill_value=0</code>  会将空值处理为 <code>0</code> 。</p></blockquote><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMTA2MTA0NTUxLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211106104551.png</span>&quot; style=&quot;zoom:50%&quot;&gt;</p><p>使用 <code>pivot_table</code>  函数时，还可以通过添加 <code>margins</code>  和 <code>margins_name</code>  参数对分组聚合的结果做一个汇总，具体的操作和效果如下所示。</p><pre><code class="language-Python">df['月份'] = df['销售日期'].dt.monthpd.pivot_table(    df, index='销售区域', columns='月份',    values='销售额', aggfunc='sum', fill_value=0,     margins=True, margins_name='总计')</code></pre><p>输出：</p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211106181707.png" alt="image-20211106181707655" /></p><p>交叉表就是一种特殊的透视表，它不需要先构造一个 <code>DataFrame</code>  对象，而是直接通过数组或 <code>Series</code>  对象指定两个或多个因素进行运算得到统计结果。例如，我们要统计每个销售区域的销售总额，也可以按照如下所示的方式来完成，我们先准备三组数据。</p><pre><code class="language-Python">sales_area, sales_month, sales_amount = df['销售区域'], df['月份'], df['销售额']</code></pre><p>使用 <code>crosstab</code>  函数生成交叉表。</p><pre><code class="language-Python">pd.crosstab(    index=sales_area, columns=sales_month, values=sales_amount, aggfunc='sum').fillna(0).applymap(int)</code></pre><blockquote><p><strong>说明</strong>：上面的代码使用了 <code>DataFrame</code>  对象的 <code>fillna</code>  方法将空值处理为 0，再使用 <code>applymap</code>  方法将数据类型处理成整数。</p></blockquote><h4 id="数据可视化"><a class="anchor" href="#数据可视化">#</a> 数据可视化</h4><p>一图胜千言，我们对数据进行透视的结果，最终要通过图表的方式呈现出来，因为图表具有极强的表现力，能够让我们迅速的解读数据中隐藏的价值。和 <code>Series</code>  一样， <code>DataFrame</code>  对象提供了 <code>plot</code>  方法来支持绘图，底层仍然是通过 <code>matplotlib</code>  库实现图表的渲染。关于 <code>matplotlib</code>  的内容，我们在下一个章节进行详细的探讨，这里我们只简单的讲解 <code>plot</code>  方法的用法。</p><p>例如，我们想通过一张柱状图来比较 “每个销售区域的销售总额”，可以直接在透视表上使用 <code>plot</code>  方法生成柱状图。我们先导入 <code>matplotlib.pyplot</code>  模块，通过修改绘图的参数使其支持中文显示。</p><pre><code class="language-Python">import matplotlib.pyplot as pltplt.rcParams['font.sans-serif'] = 'FZJKai-Z03S'</code></pre><blockquote><p><strong>说明</strong>：上面的 <code>FZJKai-Z03S</code>  是我电脑上已经安装的一种支持中文的字体的名称，字体的名称可以通过查看用户主目录下 <code>.matplotlib</code>  文件夹下名为 <code>fontlist-v330.json</code>  的文件来获得，而这个文件在执行上面的命令后就会生成。</p></blockquote><p>使用魔法指令配置生成矢量图。</p><pre><code class="language-Python">%config InlineBackend.figure_format = 'svg'</code></pre><p>绘制 “每个销售区域销售总额” 的柱状图。</p><pre><code class="language-Python">temp = pd.pivot_table(df, index='销售区域', values='销售额', aggfunc='sum')temp.plot(figsize=(8, 4), kind='bar')plt.xticks(rotation=0)plt.show()</code></pre><blockquote><p><strong>说明</strong>：上面的第 3 行代码会将横轴刻度上的文字旋转到 0 度，第 4 行代码会显示图像。</p></blockquote><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMTA2MTk1MDQwLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211106195040.png</span>&quot; style=&quot;zoom:50%&quot;&gt;</p><p>如果要绘制饼图，可以修改 <code>plot</code>  方法的 <code>kind</code>  参数为 <code>pie</code> ，然后使用定制饼图的参数对图表加以定制，代码如下所示。</p><pre><code class="language-Python">temp.sort_values(by='销售额', ascending=False).plot(    figsize=(6, 6), kind='pie', y='销售额',     autopct='%.2f%%', pctdistance=0.8,    wedgeprops=dict(linewidth=1, width=0.35))plt.legend(loc='center')plt.show()</code></pre><p>输出：</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMTA2MjAxNTUwLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211106201550.png</span>&quot; style=&quot;zoom:50%&quot;&gt;</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas的应用-3</title>
      <link href="/computer-science/python/basic/72.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-3/"/>
      <url>/computer-science/python/basic/72.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-3/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas的应用-3"><a class="anchor" href="#pandas的应用-3">#</a> Pandas 的应用 - 3</h2><h3 id="dataframe的应用"><a class="anchor" href="#dataframe的应用">#</a> DataFrame 的应用</h3><h4 id="数据清洗"><a class="anchor" href="#数据清洗">#</a> 数据清洗</h4><p>通常，我们从 Excel、CSV 或数据库中获取到的数据并不是非常完美的，里面可能因为系统或人为的原因混入了重复值或异常值，也可能在某些字段上存在缺失值；再者， <code>DataFrame</code>  中的数据也可能存在格式不统一、量纲不统一等各种问题。因此，在开始数据分析之前，对数据进行清洗就显得特别重要。</p><h5 id="缺失值"><a class="anchor" href="#缺失值">#</a> 缺失值</h5><p>可以使用 <code>DataFrame</code>  对象的 <code>isnull</code>  或 <code>isna</code>  方法来找出数据表中的缺失值，如下所示。</p><pre><code class="language-Python">emp_df.isnull()</code></pre><p>或者</p><pre><code class="language-Python">emp_df.isna()</code></pre><p>输出：</p><pre><code>        ename   job    mgr     sal     comm    dnoeno1359FalseFalseFalseFalseFalseFalse2056FalseFalseFalseFalseFalseFalse3088FalseFalseFalseFalseFalseFalse3211FalseFalseFalseFalseTrueFalse3233FalseFalseFalseFalseTrueFalse3244FalseFalseFalseFalseTrueFalse3251FalseFalseFalseFalseTrueFalse3344FalseFalseFalseFalseFalseFalse3577FalseFalseFalseFalseTrueFalse3588FalseFalseFalseFalseTrueFalse4466FalseFalseFalseFalseTrueFalse5234FalseFalseFalseFalseTrueFalse5566FalseFalseFalseFalseFalseFalse7800FalseFalseTrueFalseFalseFalse</code></pre><p>相对应的， <code>notnull</code>  和 <code>notna</code>  方法可以将非空的值标记为 <code>True</code> 。如果想删除这些缺失值，可以使用 <code>DataFrame</code>  对象的 <code>dropna</code>  方法，该方法的 <code>axis</code>  参数可以指定沿着 0 轴还是 1 轴删除，也就是说当遇到空值时，是删除整行还是删除整列，默认是沿 0 轴进行删除的，代码如下所示。</p><pre><code class="language-Python">emp_df.dropna()</code></pre><p>输出：</p><pre><code>        ename   job      mgr sal    comm     dnoeno1359胡一刀  销售员3344.01800   200.0302056乔峰    架构师 7800.0 50001500.0 203088李莫愁  设计师2056.03500   800.0203344黄蓉    销售主管7800.03000   800.0305566宋远桥  会计师7800.04000   1000.010</code></pre><p>如果要沿着 1 轴进行删除，可以使用下面的代码。</p><pre><code class="language-Python">emp_df.dropna(axis=1)</code></pre><p>输出：</p><pre><code>        ename    job      sal    dnoeno1359胡一刀   销售员    1800302056乔峰     架构师  5000 203088李莫愁   设计师    3500203211张无忌   程序员    3200203233丘处机   程序员    3400203244欧阳锋   程序员    3200203251张翠山   程序员    4000203344黄蓉     销售主管  3000303577杨过     会计   2200  103588朱九真   会计  2500 104466苗人凤   销售员 2500   305234郭靖     出纳      2000   105566宋远桥   会计师    4000   107800张三丰   总裁      9000   20</code></pre><blockquote><p><strong>注意</strong>： <code>DataFrame</code>  对象的很多方法都有一个名为 <code>inplace</code>  的参数，该参数的默认值为 <code>False</code> ，表示我们的操作不会修改原来的 <code>DataFrame</code>  对象，而是将处理后的结果通过一个新的 <code>DataFrame</code>  对象返回。如果将该参数的值设置为 <code>True</code> ，那么我们的操作就会在原来的 <code>DataFrame</code>  上面直接修改，方法的返回值为 <code>None</code> 。简单的说，上面的操作并没有修改 <code>emp_df</code> ，而是返回了一个新的 <code>DataFrame</code>  对象。</p></blockquote><p>在某些特定的场景下，我们可以对空值进行填充，对应的方法是 <code>fillna</code> ，填充空值时可以使用指定的值（通过 <code>value</code>  参数进行指定），也可以用表格中前一个单元格（通过设置参数 <code>method=ffill</code> ）或后一个单元格（通过设置参数 <code>method=bfill</code> ）的值进行填充，当代码如下所示。</p><pre><code class="language-Python">emp_df.fillna(value=0)</code></pre><blockquote><p><strong>注意</strong>：填充的值如何选择也是一个值得探讨的话题，实际工作中，可能会使用某种统计量（如：均值、众数等）进行填充，或者使用某种插值法（如：随机插值法、拉格朗日插值法等）进行填充，甚至有可能通过回归模型、贝叶斯模型等对缺失数据进行填充。</p></blockquote><p>输出：</p><pre><code>        ename    job        mgr      sal     comm    dnoeno1359胡一刀    销售员   3344.01800200.0302056乔峰    分析师    7800.0 5000 1500.0 203088李莫愁   设计师   2056.03500800.0203211张无忌   程序员   2056.032000.0     203233丘处机   程序员   2056.034000.0    203244欧阳锋   程序员   3088.032000.0     203251张翠山   程序员   2056.040000.0    203344黄蓉    销售主管   7800.03000800.0303577杨过    会计     5566.0  2200  0.0  103588朱九真   会计    5566.0 2500 0.0 104466苗人凤   销售员   3344.025000.0    305234郭靖    出纳     5566.0  2000  0.0  105566宋远桥   会计师   7800.040001000.0107800张三丰   总裁    0.0      9000 1200.0 20</code></pre><h5 id="重复值"><a class="anchor" href="#重复值">#</a> 重复值</h5><p>接下来，我们先给之前的部门表添加两行数据，让部门表中名为 “研发部” 和 “销售部” 的部门各有两个。</p><pre><code class="language-Python">dept_df.loc[50] = &#123;'dname': '研发部', 'dloc': '上海'&#125;dept_df.loc[60] = &#123;'dname': '销售部', 'dloc': '长沙'&#125;dept_df</code></pre><p>输出:</p><pre><code>    dname  dlocdno10会计部北京20研发部成都30销售部重庆40运维部天津50研发部上海60销售部长沙</code></pre><p>现在，我们的数据表中有重复数据了，我们可以通过 <code>DataFrame</code>  对象的 <code>duplicated</code>  方法判断是否存在重复值，该方法在不指定参数时默认判断行索引是否重复，我们也可以指定根据部门名称 <code>dname</code>  判断部门是否重复，代码如下所示。</p><pre><code class="language-Python">dept_df.duplicated('dname')</code></pre><p>输出：</p><pre><code>dno10    False20    False30    False40    False50     True60     Truedtype: bool</code></pre><p>从上面的输出可以看到， <code>50</code>  和 <code>60</code>  两个部门从部门名称上来看是重复的，如果要删除重复值，可以使用 <code>drop_duplicates</code>  方法，该方法的 <code>keep</code>  参数可以控制在遇到重复值时，保留第一项还是保留最后一项，或者多个重复项一个都不用保留，全部删除掉。</p><pre><code class="language-Python">dept_df.drop_duplicates('dname')</code></pre><p>输出：</p><pre><code>dnamedlocdno10会计部北京20研发部成都30销售部重庆40运维部天津</code></pre><p>将 <code>keep</code>  参数的值修改为 <code>last</code> 。</p><pre><code class="language-Python">dept_df.drop_duplicates('dname', keep='last')</code></pre><p>输出：</p><pre><code>dnamedlocdno10会计部北京40运维部天津50研发部上海60销售部长沙</code></pre><h5 id="异常值"><a class="anchor" href="#异常值">#</a> 异常值</h5><p>异常值在统计学上的全称是疑似异常值，也称作离群点（outlier），异常值的分析也称作离群点分析。异常值是指样本中出现的 “极端值”，数据值看起来异常大或异常小，其分布明显偏离其余的观测值。实际工作中，有些异常值可能是由系统或人为原因造成的，但有些异常值却不是，它们能够重复且稳定的出现，属于正常的极端值，例如很多游戏产品中头部玩家的数据往往都是离群的极端值。所以，我们既不能忽视异常值的存在，也不能简单地把异常值从数据分析中剔除。重视异常值的出现，分析其产生的原因，常常成为发现问题进而改进决策的契机。</p><p>异常值的检测有 Z-score 方法、IQR 方法、DBScan 聚类、孤立森林等，这里我们对前两种方法做一个简单的介绍。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMDA0MTkyODU4LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211004192858.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>如果数据服从正态分布，依据 3σ 法则，异常值被定义与平均值的偏差超过三倍标准差的值。在正态分布下，距离平均值 3σ 之外的值出现的概率为 $ P (|x-\mu|&gt;3\sigma)&lt;0.003 $，属于小概率事件。如果数据不服从正态分布，那么可以用远离平均值的多少倍的标准差来描述，这里的倍数就是 Z-score。Z-score 以标准差为单位去度量某一原始分数偏离平均值的距离，公式如下所示。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>z</mi><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></mrow><annotation encoding="application/x-tex">z = \frac {X - \mu} {\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0463299999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603299999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">μ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>Z-score 需要根据经验和实际情况来决定，通常把远离标准差 <code>3</code>  倍距离以上的数据点视为离群点，下面的代给出了如何通过 Z-score 方法检测异常值。</p><pre><code class="language-Python">import numpy as npdef detect_outliers_zscore(data, threshold=3):    avg_value = np.mean(data)    std_value = np.std(data)    z_score = np.abs((data - avg_value) / std_value)    return data[z_score &gt; threshold]</code></pre><p>IQR 方法中的 IQR（Inter-Quartile Range）代表四分位距离，即上四分位数（Q3）和下四分位数（Q1）的差值。通常情况下，可以认为小于 $ Q1 - 1.5 \times IQR $ 或大于 $ Q3 + 1.5 \times IQR $ 的就是异常值，而这种检测异常值的方法也是箱线图（后面会讲到）默认使用的方法。下面的代给出了如何通过 IQR 方法检测异常值。</p><pre><code class="language-Python">import numpy as npdef detect_outliers_iqr(data, whis=1.5):    q1, q3 = np.quantile(data, [0.25, 0.75])    iqr = q3 - q1    lower, upper = q1 - whis * iqr, q3 + whis * iqr    return data[(data &lt; lower) | (data &gt; upper)]</code></pre><p>如果要删除异常值，可以使用 <code>DataFrame</code>  对象的 <code>drop</code>  方法，该方法可以根据行索引或列索引删除指定的行或列。例如我们认为月薪低于 <code>2000</code>  或高于 <code>8000</code>  的是员工表中的异常值，可以用下面的代码删除对应的记录。</p><pre><code class="language-Python">emp_df.drop(emp_df[(emp_df.sal &gt; 8000) | (emp_df.sal &lt; 2000)].index)</code></pre><p>如果要替换掉异常值，可以通过给单元格赋值的方式来实现，也可以使用 <code>replace</code>  方法将指定的值替换掉。例如我们要将月薪为 <code>1800</code>  和 <code>9000</code>  的替换为月薪的平均值，补贴为 <code>800</code>  的替换为 <code>1000</code> ，代码如下所示。</p><pre><code class="language-Python">avg_sal = np.mean(emp_df.sal).astype(int)emp_df.replace(&#123;'sal': [1800, 9000], 'comm': 800&#125;, &#123;'sal': avg_sal, 'comm': 1000&#125;)</code></pre><h5 id="预处理"><a class="anchor" href="#预处理">#</a> 预处理</h5><p>对数据进行预处理也是一个很大的话题，它包含了对数据的拆解、变换、归约、离散化等操作。我们先来看看数据的拆解。如果数据表中的数据是一个时间日期，我们通常都需要从年、季度、月、日、星期、小时、分钟等维度对其进行拆解，如果时间日期是用字符串表示的，可以先通过 <code>pandas</code>  的 <code>to_datetime</code>  函数将其处理成时间日期。</p><p>在下面的例子中，我们先读取 Excel 文件，获取到一组销售数据，其中第一列就是销售日期，我们将其拆解为 “月份”、“季度” 和 “星期”，代码如下所示。</p><pre><code class="language-Python">sales_df = pd.read_excel(    '2020年销售数据.xlsx',    usecols=['销售日期', '销售区域', '销售渠道', '品牌', '销售额'])sales_df.info()</code></pre><blockquote><p><strong>说明</strong>：如果需要上面例子中的 Excel 文件，可以通过下面的百度云盘地址进行获取，数据在《从零开始学数据分析》目录中。链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXJRdWpsNVJRbjlSN1BhZEIyWjVnX2clRUYlQkMlOEMlRTYlOEYlOTAlRTUlOEYlOTYlRTclQTAlODElRUYlQkMlOUFlN2I0JUUzJTgwJTgy">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g，提取码：e7b4。</span></p></blockquote><p>输出：</p><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 1945 entries, 0 to 1944Data columns (total 5 columns): #   Column  Non-Null Count  Dtype         ---  ------  --------------  -----          0   销售日期    1945 non-null   datetime64[ns] 1   销售区域    1945 non-null   object         2   销售渠道    1945 non-null   object         3   品牌        1945 non-null   object         4   销售额      1945 non-null   int64         dtypes: datetime64[ns](1), int64(1), object(3)memory usage: 76.1+ KB</code></pre><pre><code class="language-Python">sales_df['月份'] = sales_df['销售日期'].dt.monthsales_df['季度'] = sales_df['销售日期'].dt.quartersales_df['星期'] = sales_df['销售日期'].dt.weekdaysales_df</code></pre><p>输出：</p><pre><code>    销售日期 销售区域销售渠道品牌  销售额月份季度星期0    2020-01-01上海     拼多多 八匹马   8217    1 1   21    2020-01-01上海     抖音      八匹马6351 1  1    22    2020-01-01上海     天猫      八匹马14365 1  1    23    2020-01-01上海     天猫       八匹马2366 1  1     24    2020-01-01上海     天猫   皮皮虾15189 1  1     2...     ...         ...        ...       ...      ...     ...  ...   ...1940    2020-12-30北京     京东      花花姑娘 6994     12 4   21941    2020-12-30福建     实体      八匹马7663 12  4    21942    2020-12-31福建     实体      花花姑娘 14795    12 4   31943    2020-12-31福建     抖音      八匹马3481 12  4    31944    2020-12-31福建     天猫      八匹马2673 12  4    3</code></pre><p>在上面的代码中，通过日期时间类型的 <code>Series</code>  对象的 <code>dt</code>  属性，获得一个访问日期时间的对象，通过该对象的 <code>year</code> 、 <code>month</code> 、 <code>quarter</code> 、 <code>hour</code>  等属性，就可以获取到年、月、季度、小时等时间信息，获取到的仍然是一个 <code>Series</code>  对象，它包含了一组时间信息，所以我们通常也将这个 <code>dt</code>  属性称为 “日期时间向量”。</p><p>我们再来说一说字符串类型的数据的处理，我们先从指定的 Excel 文件中读取某招聘网站的招聘数据。</p><pre><code class="language-Python">jobs_df = pd.read_csv(    '某招聘网站招聘数据.csv',    usecols=['city', 'companyFullName', 'positionName', 'salary'])jobs_df.info()</code></pre><blockquote><p><strong>说明</strong>：如果需要上面例子中的 Excel 文件，可以通过下面的百度云盘地址进行获取，数据在《从零开始学数据分析》目录中。链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXJRdWpsNVJRbjlSN1BhZEIyWjVnX2clRUYlQkMlOEMlRTYlOEYlOTAlRTUlOEYlOTYlRTclQTAlODElRUYlQkMlOUFlN2I0JUUzJTgwJTgy">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g，提取码：e7b4。</span></p></blockquote><p>输出：</p><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 3140 entries, 0 to 3139Data columns (total 4 columns): #   Column           Non-Null Count  Dtype ---  ------           --------------  -----  0   city             3140 non-null   object 1   companyFullName  3140 non-null   object 2   positionName     3140 non-null   object 3   salary           3140 non-null   objectdtypes: object(4)memory usage: 98.2+ KB</code></pre><p>查看前 <code>5</code>  条数据。</p><pre><code class="language-Python">jobs_df.head()</code></pre><p>输出：</p><pre><code>    city    companyFullName              positionName    salary0   北京  达疆网络科技（上海）有限公司    数据分析岗       15k-30k1   北京  北京音娱时光科技有限公司        数据分析        10k-18k2   北京  北京千喜鹤餐饮管理有限公司     数据分析        20k-30k3   北京  吉林省海生电子商务有限公司     数据分析        33k-50k4   北京  韦博网讯科技（北京）有限公司数据分析        10k-15k</code></pre><p>上面的数据表一共有 <code>3140</code>  条数据，但并非所有的职位都是 “数据分析” 的岗位，如果要筛选出数据分析的岗位，可以通过检查 <code>positionName</code>  字段是否包含 “数据分析” 这个关键词，这里需要模糊匹配，应该如何实现呢？我们可以先获取 <code>positionName</code>  列，因为这个 <code>Series</code>  对象的 <code>dtype</code>  是字符串，所以可以通过 <code>str</code>  属性获取对应的字符串向量，然后就可以利用我们熟悉的字符串的方法来对其进行操作，代码如下所示。</p><pre><code class="language-Python">jobs_df = jobs_df[jobs_df.positionName.str.contains('数据分析')]jobs_df.shape</code></pre><p>输出：</p><pre><code>(1515, 4)</code></pre><p>可以看出，筛选后的数据还有 <code>1515</code>  条。接下来，我们还需要对 <code>salary</code>  字段进行处理，如果我们希望统计所有岗位的平均工资或每个城市的平均工资，首先需要将用范围表示的工资处理成其中间值，代码如下所示。</p><pre><code class="language-Python">jobs_df.salary.str.extract(r'(\d+)[kK]?-(\d+)[kK]?')</code></pre><blockquote><p><strong>说明</strong>：上面的代码通过正则表达式捕获组从字符串中抽取出两组数字，分别对应工资的下限和上限，对正则表达式不熟悉的读者，可以阅读我的知乎专栏 “从零开始学 Python” 中的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNTg5Mjk3Njc=">《正则表达式的应用》</span>一文。</p></blockquote><p>输出：</p><pre><code>        0     10    15    301    10  182       20    303       33    504       10    15...     ...   ...3065    8     103069    6     103070    2     43071    6     123088    8     12</code></pre><p>需要提醒大家的是，抽取出来的两列数据都是字符串类型的值，我们需要将其转换成 <code>int</code>  类型，才能计算平均值，对应的方法是 <code>DataFrame</code>  对象的 <code>applymap</code>  方法，该方法的参数是一个函数，而该函数会作用于 <code>DataFrame</code>  中的每个元素。完成这一步之后，我们就可以使用 <code>apply</code>  方法将上面的 <code>DataFrame</code>  处理成中间值， <code>apply</code>  方法的参数也是一个函数，可以通过指定 <code>axis</code>  参数使其作用于 <code>DataFrame</code>  对象的行或列，代码如下所示。</p><pre><code class="language-Python">temp_df = jobs_df.salary.str.extract(r'(\d+)[kK]?-(\d+)[kK]?').applymap(int)temp_df.apply(np.mean, axis=1)</code></pre><p>输出：</p><pre><code>0       22.51       14.02       25.03       41.54       12.5        ... 3065    9.03069    8.03070    3.03071    9.03088    10.0Length: 1515, dtype: float64</code></pre><p>接下来，我们可以用上面的结果替换掉原来的 <code>salary</code>  列或者增加一个新的列来表示职位对应的工资，完整的代码如下所示。</p><pre><code class="language-Python">temp_df = jobs_df.salary.str.extract(r'(\d+)[kK]?-(\d+)[kK]?').applymap(int)jobs_df['salary'] = temp_df.apply(np.mean, axis=1)jobs_df.head()</code></pre><p>输出：</p><pre><code>    city    companyFullName              positionName    salary0   北京  达疆网络科技（上海）有限公司    数据分析岗       22.51   北京  北京音娱时光科技有限公司        数据分析        14.02   北京  北京千喜鹤餐饮管理有限公司     数据分析        25.03   北京  吉林省海生电子商务有限公司     数据分析        41.54   北京  韦博网讯科技（北京）有限公司数据分析        12.5</code></pre><p><code>applymap</code>  和 <code>apply</code>  两个方法在数据预处理的时候经常用到， <code>Series</code>  对象也有 <code>apply</code>  方法，也是用于数据的预处理，但是 <code>DataFrame</code>  对象还有一个名为 <code>transform</code>  的方法，也是通过传入的函数对数据进行变换，类似 <code>Series</code>  对象的 <code>map</code>  方法。需要强调的是， <code>apply</code>  方法具有归约效果的，简单的说就是能将较多的数据处理成较少的数据或一条数据；而 <code>transform</code>  方法没有归约效果，只能对数据进行变换，原来有多少条数据，处理后还是有多少条数据。</p><p>如果要对数据进行深度的分析和挖掘，字符串、日期时间这样的非数值类型都需要处理成数值，因为非数值类型没有办法计算相关性，也没有办法进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>χ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">χ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 检验等操作。对于字符串类型，通常可以其分为以下三类，再进行对应的处理。</p><ol><li>有序变量（Ordinal Variable）：字符串表示的数据有顺序关系，那么可以对字符串进行序号化处理。</li><li>分类变量（Categorical Variable）/ 名义变量（Nominal Variable）：字符串表示的数据没有大小关系和等级之分，那么就可以使用独热编码的方式处理成哑变量（虚拟变量）矩阵。</li><li>定距变量（Scale Variable）：字符串本质上对应到一个有大小高低之分的数据，而且可以进行加减运算，那么只需要将字符串处理成对应的数值即可。</li></ol><p>对于第 1 类和第 3 类，我们可以用上面提到的 <code>apply</code>  或 <code>transform</code>  方法来处理，也可以利用 <code>scikit-learn</code>  中的 <code>OrdinalEncoder</code>  处理第 1 类字符串，这个我们在后续的课程中会讲到。对于第 2 类字符串，可以使用 <code>pandas</code>  的 <code>get_dummies()</code>  函数来生成哑变量（虚拟变量）矩阵，代码如下所示。</p><pre><code class="language-Python">persons_df = pd.DataFrame(    data=&#123;        '姓名': ['关羽', '张飞', '赵云', '马超', '黄忠'],        '职业': ['医生', '医生', '程序员', '画家', '教师'],        '学历': ['研究生', '大专', '研究生', '高中', '本科']    &#125;)persons_df</code></pre><p>输出：</p><pre><code>姓名职业学历0关羽医生研究生1张飞医生大专2赵云程序员研究生3马超画家高中4黄忠教师本科</code></pre><p>将职业处理成哑变量矩阵。</p><pre><code class="language-Python">pd.get_dummies(persons_df['职业'])</code></pre><p>输出：</p><pre><code>    医生 教师  画家  程序员01    0    0    011    0    0    020    0    0    130    0    1    040    1    0    0</code></pre><p>将学历处理成大小不同的值。</p><pre><code class="language-Python">def handle_education(x):    edu_dict = &#123;'高中': 1, '大专': 3, '本科': 5, '研究生': 10&#125;    return edu_dict.get(x, 0)persons_df['学历'].apply(handle_education)</code></pre><p>输出：</p><pre><code>0    101     32    103     14     5Name: 学历, dtype: int64</code></pre><p>我们再来说说数据离散化。离散化也叫分箱，如果变量的取值是连续值，那么它的取值有无数种可能，在进行数据分组的时候就会非常的不方便，这个时候将连续变量离散化就显得非常重要。之所以把离散化叫做分箱，是因为我们可以预先设置一些箱子，每个箱子代表了数据取值的范围，这样就可以将连续的值分配到不同的箱子中，从而实现离散化。下面的例子读取了 2018 年北京积分落户数据，我们可以根据落户积分对数据进行分组，具体的做法如下所示。</p><pre><code class="language-Python">luohu_df = pd.read_csv('data/2018年北京积分落户数据.csv', index_col='id')luohu_df.score.describe()</code></pre><p>输出：</p><pre><code>count    6019.000000mean       95.654552std         4.354445min        90.75000025%        92.33000050%        94.46000075%        97.750000max       122.590000Name: score, dtype: float64</code></pre><p>可以看出，落户积分的最大值是 <code>122.59</code> ，最小值是 <code>90.75</code> ，那么我们可以构造一个从 <code>90</code>  分到 <code>125</code>  分，每 <code>5</code>  分一组的 <code>7</code>  个箱子， <code>pandas</code>  的 <code>cut</code>  函数可以帮助我们首先数据分箱，代码如下所示。</p><pre><code class="language-Python">bins = np.arange(90, 126, 5)pd.cut(luohu_df.score, bins, right=False)</code></pre><blockquote><p><strong>说明</strong>： <code>cut</code>  函数的 <code>right</code>  参数默认值为 <code>True</code> ，表示箱子左开右闭；修改为 <code>False</code>  可以让箱子的右边界为开区间，左边界为闭区间，大家看看下面的输出就明白了。</p></blockquote><p>输出：</p><pre><code>id1       [120, 125)2       [120, 125)3       [115, 120)4       [115, 120)5       [115, 120)           ...    6015      [90, 95)6016      [90, 95)6017      [90, 95)6018      [90, 95)6019      [90, 95)Name: score, Length: 6019, dtype: categoryCategories (7, interval[int64, left]): [[90, 95) &lt; [95, 100) &lt; [100, 105) &lt; [105, 110) &lt; [110, 115) &lt; [115, 120) &lt; [120, 125)]</code></pre><p>我们可以根据分箱的结果对数据进行分组，然后使用聚合函数对每个组进行统计，这是数据分析中经常用到的操作，下一个章节会为大家介绍。除此之外， <code>pandas</code>  还提供了一个名为 <code>qcut</code>  的函数，可以指定分位数对数据进行分箱，有兴趣的读者可以自行研究。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas的应用-2</title>
      <link href="/computer-science/python/basic/71.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-2/"/>
      <url>/computer-science/python/basic/71.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-2/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas的应用-2"><a class="anchor" href="#pandas的应用-2">#</a> Pandas 的应用 - 2</h2><h3 id="dataframe的应用"><a class="anchor" href="#dataframe的应用">#</a> DataFrame 的应用</h3><h4 id="创建dataframe对象"><a class="anchor" href="#创建dataframe对象">#</a> 创建 DataFrame 对象</h4><h5 id="通过二维数组创建dataframe对象"><a class="anchor" href="#通过二维数组创建dataframe对象">#</a> 通过二维数组创建 <code>DataFrame</code>  对象</h5><p>代码：</p><pre><code class="language-Python">scores = np.random.randint(60, 101, (5, 3))courses = ['语文', '数学', '英语']ids = [1001, 1002, 1003, 1004, 1005]df1 = pd.DataFrame(data=scores, columns=courses, index=ids)df1</code></pre><p>输出：</p><pre><code>语文数学英语1001    69    80791002    71  601001003    94    81931004    88  88671005    82  66    60</code></pre><h5 id="通过字典创建dataframe对象"><a class="anchor" href="#通过字典创建dataframe对象">#</a> 通过字典创建 <code>DataFrame</code>  对象</h5><p>代码：</p><pre><code class="language-Python">scores = &#123;    '语文': [62, 72, 93, 88, 93],    '数学': [95, 65, 86, 66, 87],    '英语': [66, 75, 82, 69, 82],&#125;ids = [1001, 1002, 1003, 1004, 1005]df2 = pd.DataFrame(data=scores, index=ids)df2</code></pre><p>输出：</p><pre><code>语文数学英语1001    69    80791002    71  601001003    94    81931004    88  88671005    82  66    60</code></pre><h5 id="读取-csv-文件创建dataframe对象"><a class="anchor" href="#读取-csv-文件创建dataframe对象">#</a> 读取 CSV 文件创建 <code>DataFrame</code>  对象</h5><p>可以通过 <code>pandas</code>  模块的 <code>read_csv</code>  函数来读取 CSV 文件， <code>read_csv</code>  函数的参数非常多，下面接受几个比较重要的参数。</p><ul><li><code>sep</code>  /  <code>delimiter</code> ：分隔符，默认是 <code>,</code> 。</li><li><code>header</code> ：表头（列索引）的位置，默认值是 <code>infer</code> ，用第一行的内容作为表头（列索引）。</li><li><code>index_col</code> ：用作行索引（标签）的列。</li><li><code>usecols</code> ：需要加载的列，可以使用序号或者列名。</li><li><code>true_values</code>  /  <code>false_values</code> ：哪些值被视为布尔值 <code>True</code>  /  <code>False</code> 。</li><li><code>skiprows</code> ：通过行号、索引或函数指定需要跳过的行。</li><li><code>skipfooter</code> ：要跳过的末尾行数。</li><li><code>nrows</code> ：需要读取的行数。</li><li><code>na_values</code> ：哪些值被视为空值。</li></ul><p>代码：</p><pre><code class="language-Python">df3 = pd.read_csv('2018年北京积分落户数据.csv', index_col='id')df3</code></pre><p>输出：</p><pre><code>     name   birthday    company       scoreid1    杨x    1972-12    北京利德xxxx  122.592    纪x    1974-12    北京航天xxxx  121.253    王x    1974-05  品牌联盟xxxx    118.964    杨x    1975-07  中科专利xxxx    118.215    张x    1974-11  北京阿里xxxx    117.79...  ...    ...        ...            ...6015 孙x    1978-08  华为海洋xxxx  90.756016 刘x    1976-11  福斯流体xxxx    90.756017 周x    1977-10  赢创德固xxxx    90.756018 赵x   1979-07  澳科利耳xxxx    90.756019 贺x   1981-06  北京宝洁xxxx    90.756019 rows × 4 columns</code></pre><blockquote><p><strong>说明</strong>：如果需要上面例子中的 CSV 文件，可以通过下面的百度云盘地址进行获取，数据在《从零开始学数据分析》目录中。链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXJRdWpsNVJRbjlSN1BhZEIyWjVnX2clRUYlQkMlOEMlRTYlOEYlOTAlRTUlOEYlOTYlRTclQTAlODElRUYlQkMlOUFlN2I0JUUzJTgwJTgy">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g，提取码：e7b4。</span></p></blockquote><h5 id="读取excel文件创建dataframe对象"><a class="anchor" href="#读取excel文件创建dataframe对象">#</a> 读取 Excel 文件创建 <code>DataFrame</code>  对象</h5><p>可以通过 <code>pandas</code>  模块的 <code>read_excel</code>  函数来读取 Exce l 文件，该函数与上面的 <code>read_csv</code>  非常相近，多了一个 <code>sheet_name</code>  参数来指定数据表的名称，但是不同于 CSV 文件，没有 <code>sep</code>  或 <code>delimiter</code>  这样的参数。下面的代码中， <code>read_excel</code>  函数的 <code>skiprows</code>  参数是一个 Lambda 函数，通过该 Lambda 函数指定只读取 Excel 文件的表头和其中 10% 的数据，跳过其他的数据。</p><p>代码：</p><pre><code class="language-Python">import randomdf4 = pd.read_excel(    io='小宝剑大药房2018年销售数据.xlsx',    usecols=['购药时间', '社保卡号', '商品名称', '销售数量', '应收金额', '实收金额'],    skiprows=lambda x: x &gt; 0 and random.random() &gt; 0.1)df4</code></pre><blockquote><p><strong>说明</strong>：如果需要上面例子中的 Excel 文件，可以通过下面的百度云盘地址进行获取，数据在《从零开始学数据分析》目录中。链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXJRdWpsNVJRbjlSN1BhZEIyWjVnX2clRUYlQkMlOEMlRTYlOEYlOTAlRTUlOEYlOTYlRTclQTAlODElRUYlQkMlOUFlN2I0JUUzJTgwJTgy">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g，提取码：e7b4。</span></p></blockquote><p>输出：</p><pre><code>    购药时间社保卡号    商品名称    销售数量应收金额实收金额02018-03-23 星期三10012157328强力xx片 113.813.8012018-07-12 星期二108207828    强力xx片 1        13.813.8022018-01-17 星期日13358228    清热xx液 1    28.028.0032018-07-11 星期一10031402228三九xx灵 5149.0130.0042018-01-20 星期三10013340328三九xx灵 384.073.92.....................6182018-03-05 星期六10066059228开博xx通 256.049.286192018-03-22 星期二10035514928开博xx通 128.025.006202018-04-15 星期五1006668328    开博xx通 256.050.006212018-04-24 星期日10073294128高特xx灵 15.65.606222018-04-24 星期日10073294128高特xx灵 1056.056.0623 rows × 6 columns</code></pre><h5 id="通过sql从数据库读取数据创建dataframe对象"><a class="anchor" href="#通过sql从数据库读取数据创建dataframe对象">#</a> 通过 SQL 从数据库读取数据创建 <code>DataFrame</code>  对象</h5><p><code>pandas</code>  模块的 <code>read_sql</code>  函数可以通过 SQL 语句从数据库中读取数据创建 <code>DataFrame</code>  对象，该函数的第二个参数代表了需要连接的数据库。对于 MySQL 数据库，我们可以通过 <code>pymysql</code>  或 <code>mysqlclient</code>  来创建数据库连接，得到一个 <code>Connection</code>  对象，而这个对象就是 <code>read_sql</code>  函数需要的第二个参数，代码如下所示。</p><p>代码：</p><pre><code class="language-Python">import pymysql# 创建一个MySQL数据库的连接对象conn = pymysql.connect(    host='47.104.31.138', port=3306,    user='guest', password='Guest.618',    database='hrs', charset='utf8mb4')# 通过SQL从数据库读取数据创建DataFramedf5 = pd.read_sql('select * from tb_emp', conn, index_col='eno')df5</code></pre><blockquote><p><strong>提示</strong>：执行上面的代码需要先安装 <code>pymysql</code>  库，如果尚未安装，可以先在 Notebook 的单元格中先执行 <code>!pip install pymysql</code> ，然后再运行上面的代码。上面的代码连接的是我部署在阿里云上的 MySQL 数据库，公网 IP 地址： <code>47.104.31.138</code> ，用户名： <code>guest</code> ，密码： <code>Guest.618</code> ，数据库： <code>hrs</code> ，表名： <code>tb_emp</code> ，字符集： <code>utf8mb4</code> ，大家可以使用这个数据库，但是不要进行恶意的访问。</p></blockquote><p>输出：</p><pre><code>        ename    job     mgr      sal    comm    dnoeno1359胡一刀   销售员3344.0   1800   200.0   302056乔峰   分析师 7800.0   5000   1500.0 203088李莫愁  设计师2056.0   3500   800.0   203211张无忌  程序员2056.0   3200   NaN     203233丘处机  程序员2056.0   3400NaN     203244欧阳锋  程序员3088.0   3200NaN     203251张翠山  程序员2056.0   4000NaN     203344黄蓉   销售主管7800.0   3000800.0   303577杨过   会计  5566.0   2200   NaN  103588朱九真  会计 5566.0   2500   NaN 104466苗人凤  销售员3344.0   2500NaN     305234郭靖   出纳  5566.0   2000   NaN  105566宋远桥  会计师7800.0   4000   1000.0  107800张三丰  总裁 NaN      9000   1200.0  20</code></pre><h4 id="基本属性和方法"><a class="anchor" href="#基本属性和方法">#</a> 基本属性和方法</h4><p>在开始讲解 <code>DataFrame</code>  的属性和方法前，我们先从之前提到的 <code>hrs</code>  数据库中读取三张表的数据，创建出三个 <code>DataFrame</code>  对象，代码如下所示。</p><pre><code class="language-Python">import pymysqlconn = pymysql.connect(    host='47.104.31.138', port=3306,     user='guest', password='Guest.618',     database='hrs', charset='utf8mb4')dept_df = pd.read_sql('select * from tb_dept', conn, index_col='dno')emp_df = pd.read_sql('select * from tb_emp', conn, index_col='eno')emp2_df = pd.read_sql('select * from tb_emp2', conn, index_col='eno')</code></pre><p>得到的三个 <code>DataFrame</code>  对象如下所示。</p><p>部门表（ <code>dept_df</code> ），其中 <code>dno</code>  是部门的编号， <code>dname</code>  和 <code>dloc</code>  分别是部门的名称和所在地。</p><pre><code>    dname  dlocdno10会计部北京20研发部成都30销售部重庆40运维部天津</code></pre><p>员工表（ <code>emp_df</code> ），其中 <code>eno</code>  是员工编号， <code>ename</code> 、 <code>job</code> 、 <code>mgr</code> 、 <code>sal</code> 、 <code>comm</code>  和 <code>dno</code>  分别代表员工的姓名、职位、主管编号、月薪、补贴和部门编号。</p><pre><code>        ename    job        mgr      sal     comm    dnoeno1359胡一刀    销售员   3344.01800200.0302056乔峰    分析师    7800.0 5000 1500.0 203088李莫愁   设计师   2056.03500800.0203211张无忌   程序员   2056.03200NaN     203233丘处机   程序员   2056.03400NaN    203244欧阳锋   程序员   3088.03200NaN     203251张翠山   程序员   2056.04000NaN    203344黄蓉    销售主管   7800.03000800.0303577杨过    会计     5566.0  2200  NaN  103588朱九真   会计    5566.0 2500 NaN 104466苗人凤   销售员   3344.02500NaN    305234郭靖    出纳     5566.0  2000  NaN  105566宋远桥   会计师   7800.040001000.0107800张三丰   总裁    NaN      9000 1200.0 20</code></pre><blockquote><p><strong>说明</strong>：在数据库中 <code>mgr</code>  和 <code>comm</code>  两个列的数据类型是 <code>int</code> ，但是因为有缺失值（空值），读取到 <code>DataFrame</code>  之后，列的数据类型变成了 <code>float</code> ，因为我们通常会用 <code>float</code>  类型的 <code>NaN</code>  来表示空值。</p></blockquote><p>员工表（ <code>emp2_df</code> ），跟上面的员工表结构相同，但是保存了不同的员工数据。</p><pre><code>        ename    job    mgr     sal      comm    dnoeno9800骆昊   架构师780030000 5000 209900王小刀  程序员  9800   100001200209700王大锤  程序员  9800    8000 600    20</code></pre><p><code>DataFrame</code>  对象的属性如下表所示。</p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><code>at</code>  /  <code>iat</code></td><td>通过标签获取 <code>DataFrame</code>  中的单个值。</td></tr><tr><td><code>columns</code></td><td><code>DataFrame</code>  对象列的索引</td></tr><tr><td><code>dtypes</code></td><td><code>DataFrame</code>  对象每一列的数据类型</td></tr><tr><td><code>empty</code></td><td><code>DataFrame</code>  对象是否为空</td></tr><tr><td><code>loc</code>  /  <code>iloc</code></td><td>通过标签获取 <code>DataFrame</code>  中的一组值。</td></tr><tr><td><code>ndim</code></td><td><code>DataFrame</code>  对象的维度</td></tr><tr><td><code>shape</code></td><td><code>DataFrame</code>  对象的形状（行数和列数）</td></tr><tr><td><code>size</code></td><td><code>DataFrame</code>  对象中元素的个数</td></tr><tr><td><code>values</code></td><td><code>DataFrame</code>  对象的数据对应的二维数组</td></tr></tbody></table><p>关于 <code>DataFrame</code>  的方法，首先需要了解的是 <code>info()</code>  方法，它可以帮助我们了解 <code>DataFrame</code>  的相关信息，如下所示。</p><p>代码：</p><pre><code class="language-Python">emp_df.info()</code></pre><p>输出：</p><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;Int64Index: 14 entries, 1359 to 7800Data columns (total 6 columns): #   Column  Non-Null Count  Dtype  ---  ------  --------------  -----   0   ename   14 non-null     object  1   job     14 non-null     object  2   mgr     13 non-null     float64 3   sal     14 non-null     int64   4   comm    6 non-null      float64 5   dno     14 non-null     int64  dtypes: float64(2), int64(2), object(2)memory usage: 1.3+ KB</code></pre><p>如果需要查看 <code>DataFrame</code>  的头部或尾部的数据，可以使用 <code>head()</code>  或 <code>tail()</code>  方法，这两个方法的默认参数是 <code>5</code> ，表示获取 <code>DataFrame</code>  最前面 5 行或最后面 5 行的数据，如下所示。</p><pre><code class="language-Python">emp_df.head()</code></pre><p>输出：</p><pre><code>        ename    job    mgr    sal    comm  dnoeno1359胡一刀   销售员3344   1800  200   302056乔峰   分析师 7800   5000  1500203088李莫愁  设计师2056   3500  800   203211张无忌  程序员2056   3200  NaN   203233丘处机  程序员2056   3400 NaN   20</code></pre><h4 id="获取数据"><a class="anchor" href="#获取数据">#</a> 获取数据</h4><h5 id="索引和切片"><a class="anchor" href="#索引和切片">#</a> 索引和切片</h5><p>如果要获取 <code>DataFrame</code>  的某一列，例如取出上面 <code>emp_df</code>  的 <code>ename</code>  列，可以使用下面的两种方式。</p><pre><code class="language-Python">emp_df.ename</code></pre><p>或者</p><pre><code class="language-Python">emp_df['ename']</code></pre><p>执行上面的代码可以发现，我们获得的是一个 <code>Series</code>  对象。事实上， <code>DataFrame</code>  对象就是将多个 <code>Series</code>  对象组合到一起的结果。</p><p>如果要获取 <code>DataFrame</code>  的某一行，可以使用整数索引或我们设置的索引，例如取出员工编号为 <code>2056</code>  的员工数据，代码如下所示。</p><pre><code class="language-Python">emp_df.iloc[1]</code></pre><p>或者</p><pre><code class="language-Python">emp_df.loc[2056]</code></pre><p>通过执行上面的代码我们发现，单独取 <code>DataFrame</code>  的某一行或某一列得到的都是 <code>Series</code>  对象。我们当然也可以通过花式索引来获取多个行或多个列的数据，花式索引的结果仍然是一个 <code>DataFrame</code>  对象。</p><p>获取多个列：</p><pre><code class="language-Python">emp_df[['ename', 'job']]</code></pre><p>获取多个行：</p><pre><code class="language-Python">emp_df.loc[[2056, 7800, 3344]]</code></pre><p>如果要获取或修改 <code>DataFrame</code>  对象某个单元格的数据，需要同时指定行和列的索引，例如要获取员工编号为 <code>2056</code>  的员工的职位信息，代码如下所示。</p><pre><code class="language-Python">emp_df['job'][2056]</code></pre><p>或者</p><pre><code class="language-Python">emp_df.loc[2056]['job']</code></pre><p>或者</p><pre><code class="language-Python">emp_df.loc[2056, 'job']</code></pre><p>我们推荐大家使用第三种做法，因为它只做了一次索引运算。如果要将该员工的职位修改为 “架构师”，可以使用下面的代码。</p><pre><code class="language-Python">emp_df.loc[2056, 'job'] = '架构师'</code></pre><p>当然，我们也可以通过切片操作来获取多行多列，相信大家一定已经想到了这一点。</p><pre><code class="language-Python">emp_df.loc[2056:3344]</code></pre><p>输出：</p><pre><code>        ename    job        mgr      sal     comm    dnoeno2056乔峰    分析师    7800.0 5000 1500.0 203088李莫愁   设计师   2056.03500800.0203211张无忌   程序员   2056.03200NaN     203233丘处机   程序员   2056.03400NaN    203244欧阳锋   程序员   3088.03200NaN     203251张翠山   程序员   2056.04000NaN    203344黄蓉    销售主管   7800.03000800.030</code></pre><h5 id="数据筛选"><a class="anchor" href="#数据筛选">#</a> 数据筛选</h5><p>上面我们提到了花式索引，相信大家已经联想到了布尔索引。跟 <code>ndarray</code>  和 <code>Series</code>  一样，我们可以通过布尔索引对 <code>DataFrame</code>  对象进行数据筛选，例如我们要从 <code>emp_df</code>  中筛选出月薪超过 <code>3500</code>  的员工，代码如下所示。</p><pre><code class="language-Python">emp_df[emp_df.sal &gt; 3500]</code></pre><p>输出：</p><pre><code>        ename    job        mgr      sal     comm    dnoeno2056乔峰    分析师    7800.0 5000 1500.0 203251张翠山   程序员   2056.04000NaN    205566宋远桥   会计师   7800.040001000.0107800张三丰   总裁    NaN      9000 1200.0 20</code></pre><p>当然，我们也可以组合多个条件来进行数据筛选，例如从 <code>emp_df</code>  中筛选出月薪超过 <code>3500</code>  且部门编号为 <code>20</code>  的员工，代码如下所示。</p><pre><code class="language-Python">emp_df[(emp_df.sal &gt; 3500) &amp; (emp_df.dno == 20)]</code></pre><p>输出：</p><pre><code>        ename    job        mgr      sal     comm    dnoeno2056乔峰    分析师    7800.0 5000 1500.0 203251张翠山   程序员   2056.04000NaN    207800张三丰   总裁    NaN      9000 1200.0 20</code></pre><p>除了使用布尔索引， <code>DataFrame</code>  对象的 <code>query</code>  方法也可以实现数据筛选， <code>query</code>  方法的参数是一个字符串，它代表了筛选数据使用的表达式，而且更符合 Python 程序员的使用习惯。下面我们使用 <code>query</code>  方法将上面的效果重新实现一遍，代码如下所示。</p><pre><code class="language-Python">emp_df.query('sal &gt; 3500 and dno == 20')</code></pre><h4 id="重塑数据"><a class="anchor" href="#重塑数据">#</a> 重塑数据</h4><p>有的时候，我们做数据分析需要的原始数据可能并不是来自一个地方，就像上面的例子中，我们从关系型数据库中读取了三张表，得到了三个 <code>DataFrame</code>  对象，但实际工作可能需要我们把他们的数据整合到一起。例如： <code>emp_df</code>  和 <code>emp2_df</code>  其实都是员工的数据，而且数据结构完全一致，我们可以使用 <code>pandas</code>  提供的 <code>concat</code>  函数实现两个或多个 <code>DataFrame</code>  的数据拼接，代码如下所示。</p><pre><code class="language-Python">all_emp_df = pd.concat([emp_df, emp2_df])</code></pre><p>输出：</p><pre><code>        ename    job        mgr      sal     comm    dnoeno1359    胡一刀    销售员   3344.01800200.0302056    乔峰    分析师    7800.0 5000 1500.0 203088    李莫愁   设计师   2056.03500800.0203211    张无忌   程序员   2056.03200NaN     203233    丘处机   程序员   2056.03400NaN    203244    欧阳锋   程序员   3088.03200NaN     203251    张翠山   程序员   2056.04000NaN    203344    黄蓉    销售主管   7800.03000800.0303577    杨过    会计     5566.0  2200  NaN  103588    朱九真   会计    5566.0 2500 NaN 104466    苗人凤   销售员   3344.02500NaN    305234    郭靖    出纳     5566.0  2000  NaN  105566    宋远桥   会计师   7800.040001000.0107800    张三丰   总裁    NaN      9000 1200.0 209800    骆昊    架构师     7800.0 30000 5000.0 209900    王小刀   程序员     9800.0100001200.0209700    王大锤   程序员     9800.08000600.020</code></pre><p>上面的代码将两个代表员工数据的 <code>DataFrame</code>  拼接到了一起，接下来我们使用 <code>merge</code>  函数将员工表和部门表的数据合并到一张表中，代码如下所示。</p><p>先使用 <code>reset_index</code>  方法重新设置 <code>all_emp_df</code>  的索引，这样 <code>eno</code>  不再是索引而是一个普通列， <code>reset_index</code>  方法的 <code>inplace</code>  参数设置为 <code>True</code>  表示，重置索引的操作直接在 <code>all_emp_df</code>  上执行，而不是返回修改后的新对象。</p><pre><code class="language-Python">all_emp_df.reset_index(inplace=True)</code></pre><p>通过 <code>merge</code>  函数合并数据，当然，也可以调用 <code>DataFrame</code>  对象的 <code>merge</code>  方法来达到同样的效果。</p><pre><code class="language-Python">pd.merge(dept_df, all_emp_df, how='inner', on='dno')</code></pre><p>输出：</p><pre><code>    dno dname  dloc eno   ename  job      mgr     sal    comm0   10会计部北京3577  杨过会计   5566.0  2200   NaN1   10会计部北京3588  朱九真  会计     5566.0  2500   NaN2   10会计部北京5234  郭靖出纳   5566.0  2000   NaN3   10会计部北京5566  宋远桥  会计师   7800.0 4000   1000.04   20研发部成都2056  乔峰架构师   7800.0  5000 1500.05   20研发部成都3088  李莫愁  设计师   2056.0 3500   800.06   20研发部成都3211  张无忌  程序员   2056.0 3200   NaN7   20研发部成都3233  丘处机  程序员   2056.0 3400   NaN8   20研发部成都3244  欧阳锋  程序员   3088.0 3200   NaN9   20研发部成都3251  张翠山  程序员   2056.0 4000   NaN10  20研发部成都7800  张三丰  总裁     NaN     9000   1200.011  20研发部成都9800  骆昊    架构师   7800.0  30000 5000.012  20研发部成都9900  王小刀  程序员 9800.0 10000  1200.013  20研发部成都9700  王大锤  程序员 9800.0 8000   600.014  30销售部重庆1359  胡一刀  销售员 3344.0 1800   200.015  30销售部重庆3344  黄蓉    销售主管 7800.0 3000   800.016  30销售部重庆4466  苗人凤  销售员   3344.0 2500   NaN</code></pre><p><code>merge</code>  函数的一个参数代表合并的左表、第二个参数代表合并的右表，有 SQL 编程经验的同学对这两个词是不是感觉到非常亲切。正如大家猜想的那样， <code>DataFrame</code>  对象的合并跟数据库中的表连接非常类似，所以上面代码中的 <code>how</code>  代表了合并两张表的方式，有 <code>left</code> 、 <code>right</code> 、 <code>inner</code> 、 <code>outer</code>  四个选项；而 <code>on</code>  则代表了基于哪个列实现表的合并，相当于 SQL 表连接中的连表条件，如果左右两表对应的列列名不同，可以用 <code>left_on</code>  和 <code>right_on</code>  参数取代 <code>on</code>  参数分别进行指定。</p><p>如果对上面的代码稍作修改，将 <code>how</code>  参数修改为 <code>left</code> ，大家可以思考一下代码执行的结果。</p><pre><code class="language-Python">pd.merge(dept_df, all_emp_df, how='left', on='dno')</code></pre><p>运行结果比之前的输出多出了如下所示的一行，这是因为 <code>left</code>  代表左外连接，也就意味着左表 <code>dept_df</code>  中的数据会被完整的查出来，但是在 <code>all_emp_df</code>  中又没有编号为 <code>40</code>  部门的员工，所以对应的位置都被填入了空值。</p><pre><code>17  40  运维部  天津  NaN  NaN  NaN  NaN  NaN  NaN</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas的应用-1</title>
      <link href="/computer-science/python/basic/70.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-1/"/>
      <url>/computer-science/python/basic/70.Pandas%E7%9A%84%E5%BA%94%E7%94%A8-1/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas的应用-1"><a class="anchor" href="#pandas的应用-1">#</a> Pandas 的应用 - 1</h2><p>Pandas 是 Wes McKinney 在 2008 年开发的一个强大的<strong>分析结构化数据</strong>的工具集。Pandas 以 NumPy 为基础（数据表示和运算），提供了用于数据处理的函数和方法，对数据分析和数据挖掘提供了很好的支持；同时 Pandas 还可以跟数据可视化工具 Matplotlib 很好的整合在一起，非常轻松愉快的实现数据的可视化展示。</p><p>Pandas 核心的数据类型是 <code>Series</code> （数据系列）、 <code>DataFrame</code> （数据表 / 数据框），分别用于处理一维和二维的数据，除此之外还有一个名为 <code>Index</code>  的类型及其子类型，它为 <code>Series</code>  和 <code>DataFrame</code>  提供了索引功能。日常工作中以 <code>DataFrame</code>  使用最为广泛，因为二维的数据本质就是一个有行有列的表格（想一想 Excel 电子表格和关系型数据库中的二维表）。上述这些类型都提供了大量的处理数据的方法，数据分析师可以以此为基础实现对数据的各种常规处理。</p><h3 id="series的应用"><a class="anchor" href="#series的应用">#</a> Series 的应用</h3><p>Pandas 库中的 <code>Series</code>  对象可以用来表示一维数据结构，跟数组非常类似，但是多了一些额外的功能。 <code>Series</code>  的内部结构包含了两个数组，其中一个用来保存数据，另一个用来保存数据的索引。</p><h4 id="创建series对象"><a class="anchor" href="#创建series对象">#</a> 创建 Series 对象</h4><blockquote><p><strong>提示</strong>：在执行下面的代码之前，请先导入 <code>pandas</code>  以及相关的库文件，具体的做法可以参考上一章。</p></blockquote><h5 id="方法1通过列表或数组创建series对象"><a class="anchor" href="#方法1通过列表或数组创建series对象">#</a> 方法 1：通过列表或数组创建 Series 对象</h5><p>代码：</p><pre><code class="language-Python"># data参数表示数据，index参数表示数据的索引（标签）# 如果没有指定index属性，默认使用数字索引ser1 = pd.Series(data=[320, 180, 300, 405], index=['一季度', '二季度', '三季度', '四季度'])ser1</code></pre><p>输出：</p><pre><code>一季度    320二季度    180三季度    300四季度    405dtype: int64</code></pre><h5 id="方法2通过字典创建series对象"><a class="anchor" href="#方法2通过字典创建series对象">#</a> 方法 2：通过字典创建 Series 对象。</h5><p>代码：</p><pre><code class="language-Python"># 字典中的键就是数据的索引（标签），字典中的值就是数据ser2 = pd.Series(&#123;'一季度': 320, '二季度': 180, '三季度': 300, '四季度': 405&#125;)ser2</code></pre><p>输出：</p><pre><code>一季度    320二季度    180三季度    300四季度    405dtype: int64</code></pre><h4 id="索引和切片"><a class="anchor" href="#索引和切片">#</a> 索引和切片</h4><p>跟数组一样，Series 对象也可以进行索引和切片操作，不同的是 Series 对象因为内部维护了一个保存索引的数组，所以除了可以使用整数索引通过位置检索数据外，还可以通过自己设置的索引标签获取对应的数据。</p><h5 id="使用整数索引"><a class="anchor" href="#使用整数索引">#</a> 使用整数索引</h5><p>代码：</p><pre><code class="language-Python">print(ser2[0], ser[1], ser[2], ser[3])ser2[0], ser2[3] = 350, 360print(ser2)</code></pre><p>输出：</p><pre><code>320 180 300 405一季度    350二季度    180三季度    300四季度    360dtype: int64</code></pre><blockquote><p><strong>提示</strong>：如果要使用负向索引，必须在创建 <code>Series</code>  对象时通过 <code>index</code>  属性指定非数值类型的标签。</p></blockquote><h5 id="使用自定义的标签索引"><a class="anchor" href="#使用自定义的标签索引">#</a> 使用自定义的标签索引</h5><p>代码：</p><pre><code class="language-Python">print(ser2['一季度'], ser2['三季度'])ser2['一季度'] = 380print(ser2)</code></pre><p>输出：</p><pre><code>350 300一季度    380二季度    180三季度    300四季度    360dtype: int64</code></pre><h5 id="切片操作"><a class="anchor" href="#切片操作">#</a> 切片操作</h5><p>代码：</p><pre><code class="language-Python">print(ser2[1:3])print(ser2['二季度':'四季度'])</code></pre><p>输出：</p><pre><code>二季度    180三季度    300dtype: int64二季度    500三季度    500四季度    520dtype: int64</code></pre><p>代码：</p><pre><code class="language-Python">ser2[1:3] = 400, 500ser2</code></pre><p>输出：</p><pre><code>一季度    380二季度    400三季度    500四季度    360dtype: int64</code></pre><h5 id="花式索引"><a class="anchor" href="#花式索引">#</a> 花式索引</h5><p>代码：</p><pre><code class="language-Python">print(ser2[['二季度', '四季度']])ser2[['二季度', '四季度']] = 500, 520print(ser2)</code></pre><p>输出：</p><pre><code>二季度    400四季度    360dtype: int64一季度    380二季度    500三季度    500四季度    520dtype: int64</code></pre><h5 id="布尔索引"><a class="anchor" href="#布尔索引">#</a> 布尔索引</h5><p>代码：</p><pre><code class="language-Python">ser2[ser2 &gt;= 500]</code></pre><p>输出：</p><pre><code>二季度    500三季度    500四季度    520dtype: int64</code></pre><p>#### 属性和方法</p><p>Series 对象的常用属性如下表所示。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>dtype</code>  /  <code>dtypes</code></td><td>返回 <code>Series</code>  对象的数据类型</td></tr><tr><td><code>hasnans</code></td><td>判断 <code>Series</code>  对象中有没有空值</td></tr><tr><td><code>at</code>  /  <code>iat</code></td><td>通过索引访问 <code>Series</code>  对象中的单个值</td></tr><tr><td><code>loc</code>  /  <code>iloc</code></td><td>通过一组索引访问 <code>Series</code>  对象中的一组值</td></tr><tr><td><code>index</code></td><td>返回 <code>Series</code>  对象的索引</td></tr><tr><td><code>is_monotonic</code></td><td>判断 <code>Series</code>  对象中的数据是否单调</td></tr><tr><td><code>is_monotonic_increasing</code></td><td>判断 <code>Series</code>  对象中的数据是否单调递增</td></tr><tr><td><code>is_monotonic_decreasing</code></td><td>判断 <code>Series</code>  对象中的数据是否单调递减</td></tr><tr><td><code>is_unique</code></td><td>判断 <code>Series</code>  对象中的数据是否独一无二</td></tr><tr><td><code>size</code></td><td>返回 <code>Series</code>  对象中元素的个数</td></tr><tr><td><code>values</code></td><td>以 <code>ndarray</code>  的方式返回 <code>Series</code>  对象中的值</td></tr></tbody></table><p><code>Series</code>  对象的方法很多，我们通过下面的代码为大家介绍一些常用的方法。</p><h5 id="统计相关的方法"><a class="anchor" href="#统计相关的方法">#</a> 统计相关的方法</h5><p><code>Series</code>  对象支持各种获取描述性统计信息的方法。</p><p>代码：</p><pre><code class="language-Python"># 求和print(ser2.sum())# 求均值print(ser2.mean())# 求最大print(ser2.max())# 求最小print(ser2.min())# 计数print(ser2.count())# 求标准差print(ser2.std())# 求方差print(ser2.var())# 求中位数print(ser2.median())</code></pre><p><code>Series</code>  对象还有一个名为 <code>describe()</code>  的方法，可以获得上述所有的描述性统计信息，如下所示。</p><p>代码：</p><pre><code class="language-Python">ser2.describe()</code></pre><p>输出：</p><pre><code>count      4.000000mean     475.000000std       64.031242min      380.00000025%      470.00000050%      500.00000075%      505.000000max      520.000000dtype: float64</code></pre><blockquote><p><strong>提示</strong>：因为 <code>describe()</code>  返回的也是一个 <code>Series</code>  对象，所以也可以用 <code>ser2.describe()['mean']</code>  来获取平均值。</p></blockquote><p>如果 <code>Series</code>  对象有重复的值，我们可以使用 <code>unique()</code>  方法获得去重之后的 <code>Series</code>  对象；可以使用 <code>nunique()</code>  方法统计不重复值的数量；如果想要统计每个值重复的次数，可以使用 <code>value_counts()</code>  方法，这个方法会返回一个 <code>Series</code>  对象，它的索引就是原来的 <code>Series</code>  对象中的值，而每个值出现的次数就是返回的 <code>Series</code>  对象中的数据，在默认情况下会按照出现次数做降序排列。</p><p>代码：</p><pre><code class="language-Python">ser3 = pd.Series(data=['apple', 'banana', 'apple', 'pitaya', 'apple', 'pitaya', 'durian'])ser3.value_counts()</code></pre><p>输出：</p><pre><code>apple     3pitaya    2durian    1banana    1dtype: int64</code></pre><p>代码：</p><pre><code class="language-Python">ser3.nunique()</code></pre><p>输出：</p><pre><code>4</code></pre><h5 id="数据处理的方法"><a class="anchor" href="#数据处理的方法">#</a> 数据处理的方法</h5><p><code>Series</code>  对象的 <code>isnull()</code>  和 <code>notnull()</code>  方法可以用于空值的判断，代码如下所示。</p><p>代码：</p><pre><code class="language-Python">ser4 = pd.Series(data=[10, 20, np.NaN, 30, np.NaN])ser4.isnull()</code></pre><p>输出：</p><pre><code>0    False1    False2     True3    False4     Truedtype: bool</code></pre><p>代码：</p><pre><code class="language-Python">ser4.notnull()</code></pre><p>输出：</p><pre><code>0     True1     True2    False3     True4    Falsedtype: bool</code></pre><p><code>Series</code>  对象的 <code>dropna()</code>  和 <code>fillna()</code>  方法分别用来删除空值和填充空值，具体的用法如下所示。</p><p>代码：</p><pre><code class="language-Python">ser4.dropna()</code></pre><p>输出：</p><pre><code>0    10.01    20.03    30.0dtype: float64</code></pre><p>代码：</p><pre><code class="language-Python"># 将空值填充为40ser4.fillna(value=40)</code></pre><p>输出：</p><pre><code>0    10.01    20.02    40.03    30.04    40.0dtype: float64</code></pre><p>代码：</p><pre><code class="language-Python"># backfill或bfill表示用后一个元素的值填充空值# ffill或pad表示用前一个元素的值填充空值ser4.fillna(method='ffill')</code></pre><p>输出：</p><pre><code>0    10.01    20.02    20.03    30.04    30.0dtype: float64</code></pre><p>需要提醒大家注意的是， <code>dropna()</code>  和 <code>fillna()</code>  方法都有一个名为 <code>inplace</code>  的参数，它的默认值是 <code>False</code> ，表示删除空值或填充空值不会修改原来的 <code>Series</code>  对象，而是返回一个新的 <code>Series</code>  对象来表示删除或填充空值后的数据系列，如果将 <code>inplace</code>  参数的值修改为 <code>True</code> ，那么删除或填充空值会就地操作，直接修改原来的 <code>Series</code>  对象，那么方法的返回值是 <code>None</code> 。后面我们会接触到的很多方法，包括 <code>DataFrame</code>  对象的很多方法都会有这个参数，它们的意义跟这里是一样的。</p><p><code>Series</code>  对象的 <code>mask()</code>  和 <code>where()</code>  方法可以将满足或不满足条件的值进行替换，如下所示。</p><p>代码：</p><pre><code class="language-Python">ser5 = pd.Series(range(5))ser5.where(ser5 &gt; 0)</code></pre><p>输出：</p><pre><code>0    NaN1    1.02    2.03    3.04    4.0dtype: float64</code></pre><p>代码：</p><pre><code class="language-Python">ser5.where(ser5 &gt; 1, 10)</code></pre><p>输出：</p><pre><code>0    101    102     23     34     4dtype: int64</code></pre><p>代码：</p><pre><code class="language-Python">ser5.mask(ser5 &gt; 1, 10)</code></pre><p>输出：</p><pre><code>0     01     12    103    104    10dtype: int64</code></pre><p><code>Series</code>  对象的 <code>duplicated()</code>  方法可以帮助我们找出重复的数据，而 <code>drop_duplicates()</code>  方法可以帮我们删除重复数据。</p><p>代码：</p><pre><code class="language-Python">ser3.duplicated()</code></pre><p>输出：</p><pre><code>0    False1    False2     True3    False4     True5     True6    Falsedtype: bool</code></pre><p>代码：</p><pre><code class="language-Python">ser3.drop_duplicates()</code></pre><p>输出：</p><pre><code>0     apple1    banana3    pitaya6    duriandtype: object</code></pre><p><code>Series</code>  对象的 <code>apply()</code>  和 <code>map()</code>  方法非常重要，它们可以用于数据处理，把数据映射或转换成我们期望的样子，这个操作在数据分析的数据准备阶段非常重要。</p><p>代码：</p><pre><code class="language-Python">ser6 = pd.Series(['cat', 'dog', np.nan, 'rabbit'])ser6</code></pre><p>输出：</p><pre><code>0       cat1       dog2       NaN3    rabbitdtype: object</code></pre><p>代码：</p><pre><code class="language-Python">ser6.map(&#123;'cat': 'kitten', 'dog': 'puppy'&#125;)</code></pre><p>输出：</p><pre><code>0    kitten1     puppy2       NaN3       NaNdtype: object</code></pre><p>代码：</p><pre><code class="language-Python">ser6.map('I am a &#123;&#125;'.format, na_action='ignore')</code></pre><p>输出：</p><pre><code>0       I am a cat1       I am a dog2              NaN3    I am a rabbitdtype: object</code></pre><p>代码：</p><pre><code class="language-Python">ser7 = pd.Series([20, 21, 12],  index=['London', 'New York', 'Helsinki'])ser7</code></pre><p>输出：</p><pre><code>London      20New York    21Helsinki    12dtype: int64</code></pre><p>代码：</p><pre><code class="language-Python">ser7.apply(np.square)</code></pre><p>输出：</p><pre><code>London      400New York    441Helsinki    144dtype: int64</code></pre><p>代码：</p><pre><code class="language-Python">ser7.apply(lambda x, value: x - value, args=(5, ))</code></pre><p>输出：</p><pre><code>London      15New York    16Helsinki     7dtype: int64</code></pre><h5 id="排序和取头部值的方法"><a class="anchor" href="#排序和取头部值的方法">#</a> 排序和取头部值的方法</h5><p><code>Series</code>  对象的 <code>sort_index()</code>  和 <code>sort_values()</code>  方法可以用于对索引和数据的排序，排序方法有一个名为 <code>ascending</code>  的布尔类型参数，该参数用于控制排序的结果是升序还是降序；而名为 <code>kind</code>  的参数则用来控制排序使用的算法，默认使用了 <code>quicksort</code> ，也可以选择 <code>mergesort</code>  或 <code>heapsort</code> ；如果存在空值，那么可以用 <code>na_position</code>  参数空值放在最前还是最后，默认是 <code>last</code> ，代码如下所示。</p><p>代码：</p><pre><code class="language-Python">ser8 = pd.Series(    data=[35, 96, 12, 57, 25, 89], index=['grape', 'banana', 'pitaya', 'apple', 'peach', 'orange'])# 按值从小到大排序ser8.sort_values()</code></pre><p>输出：</p><pre><code>pitaya    12peach     25grape     35apple     57orange    89banana    96dtype: int64</code></pre><p>代码：</p><pre><code class="language-Python"># 按索引从大到小排序ser8.sort_index(ascending=False)</code></pre><p>输出：</p><pre><code>pitaya    12peach     25orange    89grape     35banana    96apple     57dtype: int64</code></pre><p>如果要从 <code>Series</code>  对象中找出元素中最大或最小的 “Top-N”，实际上是不需要对所有的值进行排序的，可以使用 <code>nlargest()</code>  和 <code>nsmallest()</code>  方法来完成，如下所示。</p><p>代码：</p><pre><code class="language-Python"># 值最大的3个ser8.nlargest(3)</code></pre><p>输出：</p><pre><code>banana    96orange    89apple     57dtype: int64</code></pre><p>代码：</p><pre><code class="language-Python"># 值最小的2个ser8.nsmallest(2)</code></pre><p>输出：</p><pre><code>pitaya    12peach     25dtype: int64</code></pre><h4 id="绘制图表"><a class="anchor" href="#绘制图表">#</a> 绘制图表</h4><p>Series 对象有一个名为 <code>plot</code>  的方法可以用来生成图表，如果选择生成折线图、饼图、柱状图等，默认会使用 Series 对象的索引作为横坐标，使用 Series 对象的数据作为纵坐标。</p><p>首先导入 <code>matplotlib</code>  中 <code>pyplot</code>  模块并进行必要的配置。</p><pre><code class="language-Python">import matplotlib.pyplot as plt# 配置支持中文的非衬线字体（默认的字体无法显示中文）plt.rcParams['font.sans-serif'] = ['SimHei', ]# 使用指定的中文字体时需要下面的配置来避免负号无法显示plt.rcParams['axes.unicode_minus'] = False</code></pre><p>创建 <code>Series</code>  对象并绘制对应的柱状图。</p><pre><code class="language-Python">ser9 = pd.Series(&#123;'一季度': 400, '二季度': 520, '三季度': 180, '四季度': 380&#125;)# 通过Series对象的plot方法绘图（kind='bar'表示绘制柱状图）ser9.plot(kind='bar', color=['r', 'g', 'b', 'y'])# x轴的坐标旋转到0度（中文水平显示）plt.xticks(rotation=0)# 在柱状图的柱子上绘制数字for i in range(4):    plt.text(i, ser9[i] + 5, ser9[i], ha='center')# 显示图像plt.show()</code></pre><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20220619171513.png" alt="" /></p><p>绘制反映每个季度占比的饼图。</p><pre><code class="language-Python"># autopct参数可以配置在饼图上显示每块饼的占比ser9.plot(kind='pie', autopct='%.1f%%')# 设置y轴的标签（显示在饼图左侧的文字）plt.ylabel('各季度占比')plt.show()</code></pre><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20220619171503.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy的应用-2</title>
      <link href="/computer-science/python/basic/69.NumPy%E7%9A%84%E5%BA%94%E7%94%A8-2/"/>
      <url>/computer-science/python/basic/69.NumPy%E7%9A%84%E5%BA%94%E7%94%A8-2/</url>
      
        <content type="html"><![CDATA[<h2 id="numpy的应用-2"><a class="anchor" href="#numpy的应用-2">#</a> NumPy 的应用 - 2</h2><h3 id="数组的运算"><a class="anchor" href="#数组的运算">#</a> 数组的运算</h3><p>使用 NumPy 最为方便的是当需要对数组元素进行运算时，不用编写循环代码遍历每个元素，所有的运算都会自动的<strong>矢量化</strong>（使用高效的、提前编译的底层代码来对数据序列进行数学操作）。简单的说就是，NumPy 中的数学运算和数学函数会自动作用于数组中的每个成员。</p><h4 id="数组跟标量的运算"><a class="anchor" href="#数组跟标量的运算">#</a> 数组跟标量的运算</h4><p>代码：</p><pre><code class="language-Python">array35 = np.arange(1, 10)print(array35 + 10)print(array35 * 10)</code></pre><p>输出：</p><pre><code>[11 12 13 14 15 16 17 18 19][10 20 30 40 50 60 70 80 90]</code></pre><h4 id="数组跟数组的运算"><a class="anchor" href="#数组跟数组的运算">#</a> 数组跟数组的运算</h4><p>代码：</p><pre><code class="language-Python">array36 = np.array([1, 1, 1, 2, 2, 2, 3, 3, 3])print(array35 + array36)print(array35 * array36)print(array35 ** array36)</code></pre><p>输出：</p><pre><code>[ 2  3  4  6  7  8 10 11 12][ 1  2  3  8 10 12 21 24 27][  1   2   3  16  25  36 343 512 729]</code></pre><h4 id="通用一元函数"><a class="anchor" href="#通用一元函数">#</a> 通用一元函数</h4><p>通用函数是对 <code>ndarray</code>  中的数据执行元素级运算的函数。你可以将其看做普通函数（接收一个标量值作为参数，返回一个标量值）的矢量化包装器，如下所示。</p><p>代码：</p><pre><code class="language-Python">print(np.sqrt(array35))print(np.log2(array35))</code></pre><p>输出：</p><pre><code>[1.         1.41421356 1.73205081 2.         2.23606798 2.44948974 2.64575131 2.82842712 3.        ][0.         1.         1.5849625  2.         2.32192809 2.5849625 2.80735492 3.         3.169925  ]</code></pre><p><strong>表 1：通用一元函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>abs</code>  /  <code>fabs</code></td><td>求绝对值的函数</td></tr><tr><td><code>sqrt</code></td><td>求平方根的函数，相当于 <code>array ** 0.5 </code></td></tr><tr><td><code>square</code></td><td>求平方的函数，相当于 <code>array ** 2</code></td></tr><tr><td><code>exp</code></td><td>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">e^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span> 的函数</td></tr><tr><td><code>log</code>  /  <code>log10</code>  /  <code>log2</code></td><td>对数函数（ <code>e</code>  为底 /  <code>10</code>  为底 /  <code>2</code>  为底）</td></tr><tr><td><code>sign</code></td><td>符号函数（ <code>1</code>  - 正数； <code>0</code>  - 零； <code>-1</code>  - 负数）</td></tr><tr><td><code>ceil</code>  /  <code>floor</code></td><td>上取整 /  下取整</td></tr><tr><td><code>isnan</code></td><td>返回布尔数组，NaN 对应 <code>True</code> ，非 NaN 对应 <code>False</code></td></tr><tr><td><code>isfinite</code>  /  <code>isinf</code></td><td>判断数值是否为无穷大的函数</td></tr><tr><td><code>cos</code>  /  <code>cosh</code>  /  <code>sin</code></td><td>三角函数</td></tr><tr><td><code>sinh</code>  /  <code>tan</code>  /  <code>tanh</code></td><td>三角函数</td></tr><tr><td><code>arccos</code>  /  <code>arccosh</code>  /  <code>arcsin</code></td><td>反三角函数</td></tr><tr><td><code>arcsinh</code>  /  <code>arctan</code>  /  <code>arctanh</code></td><td>反三角函数</td></tr><tr><td><code>rint</code>  /  <code>round</code></td><td>四舍五入函数</td></tr></tbody></table><h4 id="通用二元函数"><a class="anchor" href="#通用二元函数">#</a> 通用二元函数</h4><p>代码：</p><pre><code class="language-Python">array37 = np.array([[4, 5, 6], [7, 8, 9]])array38 = np.array([[1, 2, 3], [3, 2, 1]])print(array37 ** array38)print(np.power(array37, array38))</code></pre><p>输出：</p><pre><code>[[  4  25 216] [343  64   9]][[  4  25 216] [343  64   9]]</code></pre><p><strong>表 2：通用二元函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>add(x, y)</code>  /  <code>substract(x, y)</code></td><td>加法函数 / 减法函数</td></tr><tr><td><code>multiply(x, y)</code>  /  <code>divide(x, y)</code></td><td>乘法函数 / 除法函数</td></tr><tr><td><code>floor_divide(x, y)</code>  /  <code>mod(x, y)</code></td><td>整除函数 / 求模函数</td></tr><tr><td><code>allclose(x, y)</code></td><td>检查数组 <code>x</code>  和 <code>y</code>  元素是否几乎相等</td></tr><tr y_i=""><td><code>power(x, y)</code></td><td>数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，计算x_i^</td></tr><tr><td><code>maximum(x, y)</code>  /  <code>fmax(x, y)</code></td><td>两两比较元素获取最大值 / 获取最大值（忽略 NaN）</td></tr><tr><td><code>minimum(x, y)</code>  /  <code>fmin(x, y)</code></td><td>两两比较元素获取最小值 / 获取最小值（忽略 NaN）</td></tr><tr><td><code>dot(x, y)</code></td><td>点积运算（数量积，通常记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>，用于欧几里得空间（Euclidean space））</td></tr><tr><td><code>inner(x, y)</code></td><td>内积运算（内积的含义要高于点积，点积相当于是内积在欧几里得空间 $$ 的特例，而内积可以推广到<strong>赋范向量空间</strong>，只要它满足平行四边形法则即可）</td></tr><tr><td><code>cross(x, y) </code></td><td>叉积运算（向量积，通常记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span>，运算结果是一个向量）</td></tr><tr><td><code>outer(x, y)</code></td><td>外积运算（张量积，通常记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⨂</mo></mrow><annotation encoding="application/x-tex">\bigotimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨂</span></span></span></span>，运算结果通常是一个矩阵）</td></tr><tr><td><code>intersect1d(x, y)</code></td><td>计算 <code>x</code>  和 <code>y</code>  的交集，返回这些元素构成的有序数组</td></tr><tr><td><code>union1d(x, y)</code></td><td>计算 <code>x</code>  和 <code>y</code>  的并集，返回这些元素构成的有序数组</td></tr><tr><td><code>in1d(x, y)</code></td><td>返回由判断 <code>x</code>  的元素是否在 <code>y</code>  中得到的布尔值构成的数组</td></tr><tr><td><code>setdiff1d(x, y)</code></td><td>计算 <code>x</code>  和 <code>y</code>  的差集，返回这些元素构成的数组</td></tr><tr><td><code>setxor1d(x, y)</code></td><td>计算 <code>x</code>  和 <code>y</code>  的对称差，返回这些元素构成的数组</td></tr></tbody></table><blockquote><p><strong>补充说明</strong>：在二维空间内，两个向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">A</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>2</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{A}=\begin{bmatrix} a_1 \\ a_2 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">B</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>2</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{B}=\begin{bmatrix} b_1 \\ b_2 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.04835em;">B</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 的叉积是这样定义的：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">A</mi><mo>×</mo><mi mathvariant="bold-italic">B</mi><mo>=</mo><mrow><mo fence="true">∣</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>a</mi><mn>1</mn></msub><mspace width="1em"/><msub><mi>a</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mn>1</mn></msub><mspace width="1em"/><msub><mi>b</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>−</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\boldsymbol{A}\times \boldsymbol{B}=\begin{vmatrix} a_1 \quad a_2 \\ b_1 \quad b_2 \end{vmatrix}=a_1b_2 - a_2b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76944em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.04835em;">B</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.42999em;vertical-align:-0.9500199999999999em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">∣</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>a</mi><mn>1</mn></msub><mspace width="1em"/><msub><mi>a</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mn>1</mn></msub><mspace width="1em"/><msub><mi>b</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\begin{vmatrix} a_1 \quad a_2 \\ b_1 \quad b_2 \end{vmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.42999em;vertical-align:-0.9500199999999999em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span></span></span></span> 称为行列式。但是一定要注意，叉积并不等同于行列式，行列式的运算结果是一个标量，而叉积运算的结果是一个向量。如果不明白，我们可以看看三维空间两个向量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">A</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>2</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>3</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{A}=\begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">B</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>2</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>3</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{B}=\begin{bmatrix} b_1 \\ b_2 \\ b_3 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.04835em;">B</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span> 的叉积是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">&lt;</mo><mover accent="true"><mi>i</mi><mo>^</mo></mover><mrow><mo fence="true">∣</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>a</mi><mn>2</mn></msub><mspace width="1em"/><msub><mi>a</mi><mn>3</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mn>2</mn></msub><mspace width="1em"/><msub><mi>b</mi><mn>3</mn></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><mo separator="true">,</mo><mo>−</mo><mover accent="true"><mi>j</mi><mo>^</mo></mover><mrow><mo fence="true">∣</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>a</mi><mn>1</mn></msub><mspace width="1em"/><msub><mi>a</mi><mn>3</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mn>1</mn></msub><mspace width="1em"/><msub><mi>b</mi><mn>3</mn></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><mo separator="true">,</mo><mover accent="true"><mi>k</mi><mo>^</mo></mover><mrow><mo fence="true">∣</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>a</mi><mn>1</mn></msub><mspace width="1em"/><msub><mi>a</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mn>1</mn></msub><mspace width="1em"/><msub><mi>b</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><mo fence="true">&gt;</mo></mrow><annotation encoding="application/x-tex">\left&lt; \hat{i} \begin{vmatrix} a_2 \quad a_3 \\ b_2 \quad b_3 \end{vmatrix}, -\hat{j} \begin{vmatrix} a_1 \quad a_3 \\ b_1 \quad b_3 \end{vmatrix}, \hat{k} \begin{vmatrix} a_1 \quad a_2 \\ b_1 \quad b_2 \end{vmatrix} \right&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.43em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">⟨</span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92296em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span></span></span><span style="top:-3.22852em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.92296em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.22852em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4799700000000002em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.25698em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87897em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">⟩</span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>i</mi><mo>^</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>j</mi><mo>^</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>k</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{i}, \hat{j}, \hat{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1523199999999998em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92296em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span></span></span><span style="top:-3.22852em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.92296em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.22852em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> 代表每个维度的单位向量。</p></blockquote><h4 id="广播机制"><a class="anchor" href="#广播机制">#</a> 广播机制</h4><p>上面的例子中，两个二元运算的数组形状是完全相同的，我们再来研究一下，两个形状不同的数组是否可以直接做二元运算或使用二元函数进行运算，请看下面的例子。</p><p>代码：</p><pre><code class="language-Python">array39 = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]])array40 = np.array([1, 2, 3])array39 + array40</code></pre><p>输出：</p><pre><code>array([[1, 2, 3],       [2, 3, 4],       [3, 4, 5],       [4, 5, 6]])</code></pre><p>代码：</p><pre><code class="language-Python">array41 = np.array([[1], [2], [3], [4]])array39 + array41</code></pre><p>输出：</p><pre><code>array([[1, 1, 1],       [3, 3, 3],       [5, 5, 5],       [7, 7, 7]])</code></pre><p>通过上面的例子，我们发现形状不同的数组仍然有机会进行二元运算，但也绝对不是任意的数组都可以进行二元运算。简单的说，只有两个数组后缘维度相同或者其中一个数组后缘维度为 1 时，广播机制会被触发，而通过广播机制如果能够使两个数组的形状一致，才能进行二元运算。所谓后缘维度，指的是数组 <code>shape</code>  属性对应的元组中最后一个元素的值（从后往前数最后一个维度的值），例如，我们之前打开的图像对应的数组后缘维度为 3，3 行 4 列的二维数组后缘维度为 4，而有 5 个元素的一维数组后缘维度为 5。简单的说就是，后缘维度相同或者其中一个数组的后缘维度为 1，就可以应用广播机制；而广播机制如果能够使得数组的形状一致，就满足了两个数组对应元素做运算的需求，如下图所示。</p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005115640.png" alt="" /></p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005115658.png" alt="" /></p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005115800.png" alt="" /></p><h3 id="其他常用函数"><a class="anchor" href="#其他常用函数">#</a> 其他常用函数</h3><p>除了上面讲到的函数外，NumPy 中还提供了很多用于处理数组的函数， <code>ndarray</code>  对象的很多方法也可以通过直接调用函数来实现，下表给出了一些常用的函数。</p><p><strong>表 3：NumPy 其他常用函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>unique</code></td><td>去除数组重复元素，返回唯一元素构成的有序数组</td></tr><tr><td><code>copy</code></td><td>返回拷贝数组得到的数组</td></tr><tr><td><code>sort</code></td><td>返回数组元素排序后的拷贝</td></tr><tr><td><code>split</code>  /  <code>hsplit</code>  /  <code>vsplit</code></td><td>将数组拆成若干个子数组</td></tr><tr><td><code>stack</code>  /  <code>hstack</code>  /  <code>vstack</code></td><td>将多个数组堆叠成新数组</td></tr><tr><td><code>concatenate</code></td><td>沿着指定的轴连接多个数组构成新数组</td></tr><tr><td><code>append</code>  /  <code>insert</code></td><td>向数组末尾追加元素 / 在数组指定位置插入元素</td></tr><tr><td><code>argwhere</code></td><td>找出数组中非 0 元素的位置</td></tr><tr><td><code>extract</code>  /  <code>select</code>  /  <code>where</code></td><td>按照指定的条件从数组中抽取或处理数组元素</td></tr><tr><td><code>flip</code></td><td>沿指定的轴翻转数组中的元素</td></tr><tr><td><code>fromiter</code></td><td>通过迭代器创建数组对象</td></tr><tr><td><code>fromregex</code></td><td>通过读取文件和正则表达式解析获取数据创建数组对象</td></tr><tr><td><code>repeat</code>  /  <code>tile</code></td><td>通过对元素的重复来创建新数组</td></tr><tr><td><code>roll</code></td><td>沿指定轴对数组元素进行移位</td></tr><tr><td><code>resize</code></td><td>重新调整数组的大小</td></tr><tr><td><code>place</code>  /  <code>put</code></td><td>将数组中满足条件的元素 / 指定的元素替换为指定的值</td></tr><tr><td><code>partition</code></td><td>用选定的元素对数组进行一次划分并返回划分后的数组</td></tr></tbody></table><blockquote><p><strong>提示</strong>：上面的 <code>resize</code>  函数和 <code>ndarray</code>  对象的 <code>resize</code>  方法是有区别的， <code>resize</code>  函数在调整数组大小时会重复数组中的元素作为填补多出来的元素的值，而 <code>ndarry</code>  对象的 <code>resize</code>  方法是用 0 来填补多出来的元素。这些小细节不清楚暂时也不要紧，但是如果用到对应的功能了就要引起注意。</p></blockquote><p>代码：</p><pre><code class="language-Python">array42 = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])array43 = np.array([[4, 4, 4], [5, 5, 5], [6, 6, 6]])np.hstack((array42, array43))</code></pre><p>输出：</p><pre><code>array([[1, 1, 1, 4, 4, 4],       [2, 2, 2, 5, 5, 5],       [3, 3, 3, 6, 6, 6]])</code></pre><p>代码：</p><pre><code class="language-Python">np.vstack((array42, array43))</code></pre><p>输出：</p><pre><code>array([[1, 1, 1],       [2, 2, 2],       [3, 3, 3],       [4, 4, 4],       [5, 5, 5],       [6, 6, 6]])</code></pre><p>代码：</p><pre><code class="language-Python">np.concatenate((array42, array43))</code></pre><p>输出：</p><pre><code>array([[1, 1, 1],       [2, 2, 2],       [3, 3, 3],       [4, 4, 4],       [5, 5, 5],       [6, 6, 6]])</code></pre><p>代码：</p><pre><code class="language-Python">np.concatenate((array42, array43), axis=1)</code></pre><p>输出：</p><pre><code>array([[1, 1, 1, 4, 4, 4],       [2, 2, 2, 5, 5, 5],       [3, 3, 3, 6, 6, 6]])</code></pre><h3 id="矩阵运算"><a class="anchor" href="#矩阵运算">#</a> 矩阵运算</h3><p>NumPy 中提供了专门用于线性代数（linear algebra）的模块和表示矩阵的类型 <code>matrix</code> ，当然我们通过二维数组也可以表示一个矩阵，官方并不推荐使用 <code>matrix</code>  类而是建议使用二维数组，而且有可能在将来的版本中会移除 <code>matrix</code>  类。无论如何，利用这些已经封装好的类和函数，我们可以轻松愉快的实现线性代数中很多的操作。</p><h4 id="线性代数快速回顾"><a class="anchor" href="#线性代数快速回顾">#</a> 线性代数快速回顾</h4><ol><li><strong>向量</strong>也叫<strong>矢量</strong>，是一个同时具有大小和方向，且满足平行四边形法则的几何对象。与向量相对的概念叫<strong>标量</strong>或<strong>数量</strong>，标量只有大小、绝大多数情况下没有方向。</li><li>向量可以进行<strong>加</strong>、<strong>减</strong>、<strong>数乘</strong>、<strong>点积</strong>、<strong>叉积</strong>等运算。</li><li><strong>行列式</strong>由向量组成，它的性质可以由向量解释。</li><li>行列式可以使用<strong>行列式公式</strong>计算：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow></msub><mo>±</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mi>α</mi></mrow></msub><msub><mi>a</mi><mrow><mn>2</mn><mi>β</mi></mrow></msub><mo>⋯</mo><msub><mi>a</mi><mrow><mi>n</mi><mi>ω</mi></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">det(\boldsymbol{A})=\sum_{n!} \pm {a_{1\alpha}a_{2\beta} \cdots a_{n\omega}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1863979999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">±</span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>。</li><li>高阶行列式可以用<strong>代数余子式</strong>展开成多个低阶行列式，如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mn>11</mn></msub><msub><mi>C</mi><mn>11</mn></msub><mo>+</mo><msub><mi>a</mi><mn>12</mn></msub><msub><mi>C</mi><mn>12</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub><msub><mi>C</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">det(\boldsymbol{A})=a_{11}C_{11}+a_{12}C_{12}+ \cdots +a_{1n}C_{1n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li><strong>矩阵</strong>是由一系列元素排成的矩形阵列，矩阵里的元素可以是数字、符号或数学公式。</li><li>矩阵可以进行<strong>加法</strong>、<strong>减法</strong>、<strong>数乘</strong>、<strong>乘法</strong>、<strong>转置</strong>等运算。</li><li><strong>逆矩阵</strong>用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><msup><mi mathvariant="bold-italic">A</mi><mrow><mo mathvariant="bold-italic">−</mo><mn mathvariant="bold">1</mn></mrow></msup></mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A^{-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">−</span><span class="mord mathbf mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span> 表示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">A</mi><mi><msup><mi mathvariant="bold-italic">A</mi><mrow><mo mathvariant="bold-italic">−</mo><mn mathvariant="bold">1</mn></mrow></msup></mi><mo>=</mo><mi><msup><mi mathvariant="bold-italic">A</mi><mrow><mo mathvariant="bold-italic">−</mo><mn mathvariant="bold">1</mn></mrow></msup></mi><mi mathvariant="bold-italic">A</mi><mo>=</mo><mi mathvariant="bold-italic">I</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}\boldsymbol{A^{-1}}=\boldsymbol{A^{-1}}\boldsymbol{A}=\boldsymbol{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">−</span><span class="mord mathbf mtight">1</span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">−</span><span class="mord mathbf mtight">1</span></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span></span></span></span>；没有逆矩阵的方阵是<strong>奇异矩阵</strong>。</li><li>如果一个方阵是<strong>满秩矩阵</strong> (矩阵的秩等于矩阵的阶数)，该方阵对应的线性方程有唯一解。</li></ol><blockquote><p><strong>说明</strong>：<strong>矩阵的秩</strong>是指矩阵中线性无关的行 / 列向量的最大个数，同时也是矩阵对应的线性变换的像空间的维度。</p></blockquote><h4 id="numpy中矩阵相关函数"><a class="anchor" href="#numpy中矩阵相关函数">#</a> NumPy 中矩阵相关函数</h4><ol><li><p>创建矩阵对象。</p><p>代码：</p><pre><code class="language-Python"># matrix构造函数可以传入类数组对象也可以传入字符串m1 = np.matrix('1 2 3; 4 5 6')m1</code></pre><p>输出：</p><pre><code>matrix([[1, 2, 3],        [4, 5, 6]])</code></pre><p>代码：</p><pre><code class="language-Python"># asmatrix函数也可以写成mat函数，它们其实是同一个函数m2 = np.asmatrix(np.array([[1, 1], [2, 2], [3, 3]]))m2</code></pre><p>输出：</p><pre><code>matrix([[1, 1],        [2, 2],        [3, 3]])</code></pre><p>代码：</p><pre><code class="language-Python">m1 * m2</code></pre><p>输出：</p><pre><code>matrix([[14, 14],        [32, 32]])</code></pre><blockquote><p><strong>说明</strong>：注意 <code>matrix</code>  对象和 <code>ndarray</code>  对象乘法运算的差别，如果两个二维数组要做矩阵乘法运算，应该使用 <code>@</code> 运算符或 <code>matmul</code>  函数，而不是 <code>*</code>  运算符。</p></blockquote></li><li><p>矩阵对象的属性。</p><p>| 属性    | 说明                                      |<br />| ------- | ----------------------------------------- |<br />|  <code>A</code>      | 获取矩阵对象对应的 <code>ndarray</code>  对象           |<br />|  <code>A1</code>     | 获取矩阵对象对应的扁平化后的 <code>ndarray</code>  对象 |<br />|  <code>I</code>      | 可逆矩阵的逆矩阵                          |<br />|  <code>T</code>      | 矩阵的转置                                |<br />|  <code>H</code>      | 矩阵的共轭转置                            |<br />|  <code>shape</code>  | 矩阵的形状                                |<br />|  <code>size</code>   | 矩阵元素的个数                            |</p></li><li><p>矩阵对象的方法。</p></li></ol><p>矩阵对象的方法跟之前讲过的 <code>ndarray</code>  数组对象的方法基本差不多，此处不再进行赘述。</p><h4 id="numpy的线性代数模块"><a class="anchor" href="#numpy的线性代数模块">#</a> NumPy 的线性代数模块</h4><p>NumPy 的 <code>linalg</code>  模块中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的函数，它们跟 MATLAB 和 R 等语言所使用的是相同的行业标准线性代数库，下面的表格列出了 <code>numpy</code>  以及 <code>linalg</code>  模块中常用的跟线性代数相关的函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>diag</code></td><td>以一维数组的形式返回方阵的对角线元素或将一维数组转换为方阵（非对角元素元素为 0）</td></tr><tr><td><code>vdot</code></td><td>向量的点积</td></tr><tr><td><code>dot</code></td><td>数组的点积</td></tr><tr><td><code>inner</code></td><td>数组的内积</td></tr><tr><td><code>outer</code></td><td>数组的叉积</td></tr><tr><td><code>trace</code></td><td>计算对角线元素的和</td></tr><tr><td><code>norm</code></td><td>求模（范数）运算</td></tr><tr><td><code>det</code></td><td>计算行列式的值（在方阵上计算会得到一个标量）</td></tr><tr><td><code>matrix_rank</code></td><td>计算矩阵的秩</td></tr><tr><td><code>eig</code></td><td>计算矩阵的特征值（eigenvalue）和特征向量（eigenvector）</td></tr><tr><td><code>inv</code></td><td>计算非奇异矩阵（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 阶方阵）的逆矩阵</td></tr><tr><td><code>pinv</code></td><td>计算矩阵的摩尔 - 彭若斯（Moore-Penrose）广义逆</td></tr><tr><td><code>qr</code></td><td>QR 分解（把矩阵分解成一个正交矩阵与一个上三角矩阵的积）</td></tr><tr><td><code>svd</code></td><td>计算奇异值分解（singular value decomposition）</td></tr><tr><td><code>solve</code></td><td>解线性方程组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">x</mi><mo>=</mo><mi mathvariant="bold-italic">b</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}\boldsymbol{x}=\boldsymbol{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">b</span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span> 是一个方阵</td></tr><tr><td><code>lstsq</code></td><td>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">x</mi><mo>=</mo><mi mathvariant="bold-italic">b</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}\boldsymbol{x}=\boldsymbol{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">b</span></span></span></span></span></span> 的最小二乘解</td></tr></tbody></table><p>大家如果有兴趣可以用下面的代码验证上面的函数。</p><p>代码：</p><pre><code class="language-Python">m3 = np.array([[1., 2.], [3., 4.]])np.linalg.inv(m3)</code></pre><p>输出：</p><pre><code>array([[-2. ,  1. ],       [ 1.5, -0.5]])</code></pre><p>代码：</p><pre><code class="language-Python">m4 = np.array([[1, 3, 5], [2, 4, 6], [4, 7, 9]])np.linalg.det(m4)</code></pre><p>输出：</p><pre><code>2</code></pre><p>代码：</p><pre><code class="language-Python"># 解线性方程组ax=b# 3*x1 + x2= 9，x1 + 2*x2 = 8a = np.array([[3,1], [1,2]])b = np.array([9, 8])np.linalg.solve(a, b)</code></pre><p>输出：</p><pre><code>array([2., 3.])</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy的应用-1</title>
      <link href="/computer-science/python/basic/68.NumPy%E7%9A%84%E5%BA%94%E7%94%A8-1/"/>
      <url>/computer-science/python/basic/68.NumPy%E7%9A%84%E5%BA%94%E7%94%A8-1/</url>
      
        <content type="html"><![CDATA[<h2 id="numpy的应用-1"><a class="anchor" href="#numpy的应用-1">#</a> NumPy 的应用 - 1</h2><p>Numpy 是一个开源的 Python 科学计算库，<strong>用于快速处理任意维度的数组</strong>。Numpy <strong>支持常见的数组和矩阵操作</strong>，对于同样的数值计算任务，使用 NumPy 不仅代码要简洁的多，而且 NumPy 的性能远远优于原生 Python，基本是一个到两个数量级的差距，而且数据量越大，NumPy 的优势就越明显。</p><p>Numpy 最为核心的数据类型是 <code>ndarray</code> ，使用 <code>ndarray</code>  可以处理一维、二维和多维数组，该对象相当于是一个快速而灵活的大数据容器。NumPy 底层代码使用 C 语言编写，解决了 GIL 的限制， <code>ndarray</code>  在存取数据的时候，数据与数据的地址都是连续的，这确保了可以进行高效率的批量操作，远远优于 Python 中的 <code>list</code> ；另一方面 <code>ndarray</code>  对象提供了更多的方法来处理数据，尤其是和统计相关的方法，这些方法也是 Python 原生的 <code>list</code>  没有的。</p><h3 id="准备工作"><a class="anchor" href="#准备工作">#</a> 准备工作</h3><ol><li><p>启动 Notebook</p><pre><code class="language-Bash">jupyter notebook</code></pre><blockquote><p><strong>提示</strong>：在启动 Notebook 之前，建议先安装好数据分析相关依赖项，包括之前提到的三大神器以及相关依赖项，包括： <code>numpy</code> 、 <code>pandas</code> 、 <code>matplotlib</code> 、 <code>openpyxl</code>  等。如果使用 Anaconda，则无需单独安装。</p></blockquote></li><li><p>导入</p><pre><code class="language-Python">import numpy as npimport pandas as pdimport matplotlib.pyplot as plt</code></pre><blockquote><p><strong>说明</strong>：如果已经启动了 Notebook 但尚未安装相关依赖库，例如尚未安装 <code>numpy</code> ，可以在 Notebook 的单元格中输入 <code>!pip install numpy</code>  并运行该单元格来安装 NumPy，也可以一次性安装多个三方库，需要在单元格中输入 <code>%pip install numpy pandas matplotlib</code> 。注意上面的代码，我们不仅导入了 NumPy，还将 pandas 和 matplotlib 库一并导入了。</p></blockquote></li></ol><h3 id="创建数组对象"><a class="anchor" href="#创建数组对象">#</a> 创建数组对象</h3><p>创建 <code>ndarray</code>  对象有很多种方法，下面就如何创建一维数组、二维数组和多维数组进行说明。</p><h4 id="一维数组"><a class="anchor" href="#一维数组">#</a> 一维数组</h4><ul><li><p>方法一：使用 <code>array</code>  函数，通过 <code>list</code>  创建数组对象</p><p>代码：</p><pre><code class="language-Python">array1 = np.array([1, 2, 3, 4, 5])array1</code></pre><p>输出：</p><pre><code>array([1, 2, 3, 4, 5])</code></pre></li><li><p>方法二：使用 <code>arange</code>  函数，指定取值范围创建数组对象</p><p>代码：</p><pre><code class="language-Python">array2 = np.arange(0, 20, 2)array2</code></pre><p>输出：</p><pre><code>array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])</code></pre></li><li><p>方法三：使用 <code>linspace</code>  函数，用指定范围均匀间隔的数字创建数组对象</p><p>代码：</p><pre><code class="language-Python">array3 = np.linspace(-5, 5, 101)array3</code></pre><p>输出：</p><pre><code>array([-5. , -4.9, -4.8, -4.7, -4.6, -4.5, -4.4, -4.3, -4.2, -4.1, -4. ,       -3.9, -3.8, -3.7, -3.6, -3.5, -3.4, -3.3, -3.2, -3.1, -3. , -2.9,       -2.8, -2.7, -2.6, -2.5, -2.4, -2.3, -2.2, -2.1, -2. , -1.9, -1.8,       -1.7, -1.6, -1.5, -1.4, -1.3, -1.2, -1.1, -1. , -0.9, -0.8, -0.7,       -0.6, -0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,        0.5,  0.6,  0.7,  0.8,  0.9,  1. ,  1.1,  1.2,  1.3,  1.4,  1.5,        1.6,  1.7,  1.8,  1.9,  2. ,  2.1,  2.2,  2.3,  2.4,  2.5,  2.6,        2.7,  2.8,  2.9,  3. ,  3.1,  3.2,  3.3,  3.4,  3.5,  3.6,  3.7,        3.8,  3.9,  4. ,  4.1,  4.2,  4.3,  4.4,  4.5,  4.6,  4.7,  4.8,        4.9,  5. ])</code></pre></li><li><p>方法四：使用 <code>numpy.random</code>  模块的函数生成随机数创建数组对象</p><p>产生 10 个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 范围的随机小数，代码：</p><pre><code class="language-Python">array4 = np.random.rand(10)array4</code></pre><p>输出：</p><pre><code>array([0.45556132, 0.67871326, 0.4552213 , 0.96671509, 0.44086463,       0.72650875, 0.79877188, 0.12153022, 0.24762739, 0.6669852 ])</code></pre><p>产生 10 个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[1, 100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 范围的随机整数，代码：</p><pre><code class="language-Python">array5 = np.random.randint(1, 100, 10)array5</code></pre><p>输出：</p><pre><code>array([29, 97, 87, 47, 39, 19, 71, 32, 79, 34])</code></pre><p>产生 20 个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">\mu=50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\sigma=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的正态分布随机数，代码：</p><pre><code class="language-Python">array6 = np.random.normal(50, 10, 20)array6</code></pre><p>输出：</p><pre><code>array([55.04155586, 46.43510797, 20.28371158, 62.67884053, 61.23185964,       38.22682148, 53.17126151, 43.54741592, 36.11268017, 40.94086676,       63.27911699, 46.92688903, 37.1593374 , 67.06525656, 67.47269463,       23.37925889, 31.45312239, 48.34532466, 55.09180924, 47.95702787])</code></pre></li></ul><blockquote><p><strong>说明</strong>：创建一维数组还有很多其他的方式，比如通过读取字符串、读取文件、解析正则表达式等方式，这里我们暂不讨论这些方式，有兴趣的读者可以自行研究。</p></blockquote><h4 id="二维数组"><a class="anchor" href="#二维数组">#</a> 二维数组</h4><ul><li><p>方法一：使用 <code>array</code>  函数，通过嵌套的 <code>list</code>  创建数组对象</p><p>代码：</p><pre><code class="language-Python">array7 = np.array([[1, 2, 3], [4, 5, 6]])array7</code></pre><p>输出：</p><pre><code>array([[1, 2, 3],       [4, 5, 6]])</code></pre></li><li><p>方法二：使用 <code>zeros</code> 、 <code>ones</code> 、 <code>full</code>  函数指定数组的形状创建数组对象</p><p>使用 <code>zeros</code>  函数，代码：</p><pre><code class="language-Python">array8 = np.zeros((3, 4))array8</code></pre><p>输出：</p><pre><code>array([[0., 0., 0., 0.],       [0., 0., 0., 0.],       [0., 0., 0., 0.]])</code></pre><p>使用 <code>ones</code>  函数，代码：</p><pre><code class="language-Python">array9 = np.ones((3, 4))array9</code></pre><p>输出：</p><pre><code>array([[1., 1., 1., 1.],       [1., 1., 1., 1.],       [1., 1., 1., 1.]])</code></pre><p>使用 <code>full</code>  函数，代码：</p><pre><code class="language-Python">array10 = np.full((3, 4), 10)array10</code></pre><p>输出：</p><pre><code>array([[10, 10, 10, 10],       [10, 10, 10, 10],       [10, 10, 10, 10]])</code></pre></li><li><p>方法三：使用 eye 函数创建单位矩阵</p><p>代码：</p><pre><code class="language-Python">array11 = np.eye(4)array11</code></pre><p>输出：</p><pre><code>array([[1., 0., 0., 0.],       [0., 1., 0., 0.],       [0., 0., 1., 0.],       [0., 0., 0., 1.]])</code></pre></li><li><p>方法四：通过 <code>reshape</code>  将一维数组变成二维数组</p><p>代码：</p><pre><code class="language-Python">array12 = np.array([1, 2, 3, 4, 5, 6]).reshape(2, 3)array12</code></pre><p>输出：</p><pre><code>array([[1, 2, 3],       [4, 5, 6]])</code></pre><blockquote><p><strong>提示</strong>： <code>reshape</code>  是 <code>ndarray</code>  对象的一个方法，使用 <code>reshape</code>  方法时需要确保调形后的数组元素个数与调形前数组元素个数保持一致，否则将会产生异常。</p></blockquote></li><li><p>方法五：通过 <code>numpy.random</code>  模块的函数生成随机数创建数组对象</p><p>产生<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 范围的随机小数构成的 3 行 4 列的二维数组，代码：</p><pre><code class="language-Python">array13 = np.random.rand(3, 4)array13</code></pre><p>输出：</p><pre><code>array([[0.54017809, 0.46797771, 0.78291445, 0.79501326],       [0.93973783, 0.21434806, 0.03592874, 0.88838892],       [0.84130479, 0.3566601 , 0.99935473, 0.26353598]])</code></pre><p>产生<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[1, 100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 范围的随机整数构成的 3 行 4 列的二维数组，代码：</p><pre><code class="language-Python">array14 = np.random.randint(1, 100, (3, 4))array14</code></pre><p>输出：</p><pre><code>array([[83, 30, 64, 53],       [39, 92, 53, 43],       [43, 48, 91, 72]])</code></pre></li></ul><h4 id="多维数组"><a class="anchor" href="#多维数组">#</a> 多维数组</h4><ul><li><p>使用随机的方式创建多维数组</p><p>代码：</p><pre><code class="language-Python">array15 = np.random.randint(1, 100, (3, 4, 5))array15</code></pre><p>输出：</p><pre><code>array([[[94, 26, 49, 24, 43],        [27, 27, 33, 98, 33],        [13, 73,  6,  1, 77],        [54, 32, 51, 86, 59]],       [[62, 75, 62, 29, 87],        [90, 26,  6, 79, 41],        [31, 15, 32, 56, 64],        [37, 84, 61, 71, 71]],       [[45, 24, 78, 77, 41],        [75, 37,  4, 74, 93],        [ 1, 36, 36, 60, 43],        [23, 84, 44, 89, 79]]])</code></pre></li><li><p>将一维二维的数组调形为多维数组</p><p>一维数组调形为多维数组，代码：</p><pre><code class="language-Python">array16 = np.arange(1, 25).reshape((2, 3, 4))array16</code></pre><p>输出：</p><pre><code class="language-Python">array([[[ 1,  2,  3,  4],        [ 5,  6,  7,  8],        [ 9, 10, 11, 12]],       [[13, 14, 15, 16],        [17, 18, 19, 20],        [21, 22, 23, 24]]])</code></pre><p>二维数组调形为多维数组，代码：</p><pre><code class="language-Python">array17 = np.random.randint(1, 100, (4, 6)).reshape((4, 3, 2))array17</code></pre><p>输出：</p><pre><code>array([[[60, 59],        [31, 80],        [54, 91]],       [[67,  4],        [ 4, 59],        [47, 49]],       [[16,  4],        [ 5, 71],        [80, 53]],       [[38, 49],        [70,  5],        [76, 80]]])</code></pre></li><li><p>读取图片获得对应的三维数组</p><p>代码：</p><pre><code class="language-Python">array18 = plt.imread('guido.jpg')array18</code></pre><p>输出：</p><pre><code>array([[[ 36,  33,  28],        [ 36,  33,  28],        [ 36,  33,  28],        ...,        [ 32,  31,  29],        [ 32,  31,  27],        [ 31,  32,  26]],       [[ 37,  34,  29],        [ 38,  35,  30],        [ 38,  35,  30],        ...,        [ 31,  30,  28],        [ 31,  30,  26],        [ 30,  31,  25]],       [[ 38,  35,  30],        [ 38,  35,  30],        [ 38,  35,  30],        ...,        [ 30,  29,  27],        [ 30,  29,  25],        [ 29,  30,  25]],       ...,       [[239, 178, 123],        [237, 176, 121],        [235, 174, 119],        ...,        [ 78,  68,  56],        [ 75,  67,  54],        [ 73,  65,  52]],       [[238, 177, 120],        [236, 175, 118],        [234, 173, 116],        ...,        [ 82,  70,  58],        [ 78,  68,  56],        [ 75,  66,  51]],       [[238, 176, 119],        [236, 175, 118],        [234, 173, 116],        ...,        [ 84,  70,  61],        [ 81,  69,  57],        [ 79,  67,  53]]], dtype=uint8)</code></pre><blockquote><p><strong>说明</strong>：上面的代码读取了当前路径下名为 <code>guido.jpg</code>  的图片文件，计算机系统中的图片通常由若干行若干列的像素点构成，而每个像素点又是由红绿蓝三原色构成的，所以能够用三维数组来表示。读取图片用到了 <code>matplotlib</code>  库的 <code>imread</code>  函数。</p></blockquote></li></ul><h3 id="数组对象的属性"><a class="anchor" href="#数组对象的属性">#</a> 数组对象的属性</h3><ol><li><p><code>size</code>  属性：数组元素个数</p><p>代码：</p><pre><code class="language-Python">array19 = np.arange(1, 100, 2)array20 = np.random.rand(3, 4)print(array19.size, array20.size)</code></pre><p>输出：</p><pre><code>50 12</code></pre></li><li><p><code>shape</code>  属性：数组的形状</p><p>代码：</p><pre><code class="language-Python">print(array19.shape, array20.shape)</code></pre><p>输出：</p><pre><code>(50,) (3, 4)</code></pre></li><li><p><code>dtype</code>  属性：数组元素的数据类型</p><p>代码：</p><pre><code class="language-Python">print(array19.dtype, array20.dtype)</code></pre><p>输出：</p><pre><code>int64 float64</code></pre><p><code>ndarray</code>  对象元素的数据类型可以参考如下所示的表格。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL215cGljLzIwMjExMDA1MTE0ODEzLnBuZw==">https://github.com/mypic/20211005114813.png</span>&quot; width=&quot;85%&quot;&gt;</p></li><li><p><code>ndim</code>  属性：数组的维度</p><p>代码：</p><pre><code class="language-Python">print(array19.ndim, array20.ndim)</code></pre><p>输出：</p><pre><code>1 2</code></pre></li><li><p><code>itemsize</code>  属性：数组单个元素占用内存空间的字节数</p><p>代码：</p><pre><code class="language-Python">array21 = np.arange(1, 100, 2, dtype=np.int8)print(array19.itemsize, array20.itemsize, array21.itemsize)</code></pre><p>输出：</p><pre><code>8 8 1</code></pre><blockquote><p><strong>说明</strong>：在使用 <code>arange</code>  创建数组对象时，通过 <code>dtype</code>  参数指定元素的数据类型。可以看出， <code>np.int8</code>  代表的是 8 位有符号整数，只占用 1 个字节的内存空间，取值范围是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>128</mn><mo separator="true">,</mo><mn>127</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-128,127]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mclose">]</span></span></span></span>。</p></blockquote></li><li><p><code>nbytes</code>  属性：数组所有元素占用内存空间的字节数</p><p>代码：</p><pre><code class="language-Python">print(array19.nbytes, array20.nbytes, array21.nbytes)</code></pre><p>输出：</p><pre><code>400 96 50</code></pre></li><li><p><code>flat</code>  属性：数组（一维化之后）元素的迭代器</p><p>代码：</p><pre><code class="language-Python">from typing import Iterableprint(isinstance(array20.flat, np.ndarray), isinstance(array20.flat, Iterable))</code></pre><p>输出：</p><pre><code>False True</code></pre></li><li><p><code>base</code>  属性：数组的基对象（如果数组共享了其他数组的内存空间）</p><p>代码：</p><pre><code class="language-Python">array22 = array19[:]print(array22.base is array19, array22.base is array21)</code></pre><p>输出：</p><pre><code>True False</code></pre><blockquote><p><strong>说明</strong>：上面的代码用到了数组的切片操作，它类似于 Python 中 <code>list</code>  类型的切片，但在细节上又不完全相同，下面会专门讲解这个知识点。通过上面的代码可以发现， <code>ndarray</code>  切片后得到的新的数组对象跟原来的数组对象共享了内存中的数据，因此 <code>array22</code>  的 <code>base</code>  属性就是 <code>array19</code>  对应的数组对象。</p></blockquote></li></ol><h3 id="数组的索引和切片"><a class="anchor" href="#数组的索引和切片">#</a> 数组的索引和切片</h3><p>和 Python 中的列表类似，NumPy 的 <code>ndarray</code>  对象可以进行索引和切片操作，通过索引可以获取或修改数组中的元素，通过切片可以取出数组的一部分。</p><ol><li><p>索引运算（普通索引）</p><p>一维数组，代码：</p><pre><code class="language-Python">array23 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])print(array23[0], array23[array23.size - 1])print(array23[-array23.size], array23[-1])</code></pre><p>输出：</p><pre><code>1 91 9</code></pre><p>二维数组，代码：</p><pre><code class="language-Python">array24 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print(array24[2])print(array24[0][0], array24[-1][-1])print(array24[1][1], array24[1, 1])</code></pre><p>输出：</p><pre><code>[7 8 9]1 95 5[[ 1  2  3] [ 4 10  6] [ 7  8  9]]</code></pre><p>代码：</p><pre><code class="language-Python">array24[1][1] = 10print(array24)array24[1] = [10, 11, 12]print(array24)</code></pre><p>输出：</p><pre><code>[[ 1  2  3] [ 4 10  6] [ 7  8  9]][[ 1  2  3] [10 11 12] [ 7  8  9]]</code></pre></li><li><p>切片运算（切片索引）</p><p>切片是形如 <code>[开始索引:结束索引:步长]</code>  的语法，通过指定<strong>开始索引</strong>（默认值无穷小）、<strong>结束索引</strong>（默认值无穷大）和<strong>步长</strong>（默认值 1），从数组中取出指定部分的元素并构成新的数组。因为开始索引、结束索引和步长都有默认值，所以它们都可以省略，如果不指定步长，第二个冒号也可以省略。一维数组的切片运算跟 Python 中的 <code>list</code>  类型的切片非常类似，此处不再赘述，二维数组的切片可以参考下面的代码，相信非常容易理解。</p><p>代码：</p><pre><code class="language-Python">print(array24[:2, 1:])</code></pre><p>输出：</p><pre><code>[[2 3] [5 6]]</code></pre><p>代码：</p><pre><code class="language-Python">print(array24[2])print(array24[2, :])</code></pre><p>输出：</p><pre><code>[7 8 9][7 8 9]</code></pre><p>代码：</p><pre><code class="language-Python">print(array24[2:, :])</code></pre><p>输出：</p><pre><code>[[7 8 9]]</code></pre><p>代码：</p><pre><code class="language-Python">print(array24[:, :2])</code></pre><p>输出：</p><pre><code>[[1 2] [4 5] [7 8]]</code></pre><p>代码：</p><pre><code class="language-Python">print(array24[1, :2])print(array24[1:2, :2])</code></pre><p>输出：</p><pre><code>[4 5][[4 5]]</code></pre><p>代码：</p><pre><code class="language-Python">print(array24[::2, ::2])</code></pre><p>输出：</p><pre><code>[[1 3] [7 9]]</code></pre><p>代码：</p><pre><code class="language-Python">print(array24[::-2, ::-2])</code></pre><p>输出：</p><pre><code>[[9 7] [3 1]]</code></pre><p>关于数组的索引和切片运算，大家可以通过下面的两张图来增强印象，这两张图来自<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMjM5ODcyNS5odG1s">《利用 Python 进行数据分析》</span>一书，它是 <code>pandas</code>  库的作者 Wes McKinney 撰写的 Python 数据分析领域的经典教科书，有兴趣的读者可以购买和阅读原书。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMDA1MTE1MDA1LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211005115005.png</span>&quot; style=&quot;zoom: 65%&quot;&gt;</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMDA1MTE1MDQxLnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211005115041.png</span>&quot; style=&quot;zoom:65%&quot;&gt;</p></li><li><p>花式索引（fancy index）</p><p>花式索引（Fancy indexing）是指利用整数数组进行索引，这里所说的整数数组可以是 NumPy 的 <code>ndarray</code> ，也可以是 Python 中 <code>list</code> 、 <code>tuple</code>  等可迭代类型，可以使用正向或负向索引。</p><p>一维数组的花式索引，代码：</p><pre><code class="language-Python">array25 = np.array([50, 30, 15, 20, 40])array25[[0, 1, -1]]</code></pre><p>输出：</p><pre><code>array([50, 30, 40])</code></pre><p>二维数组的花式索引，代码：</p><pre><code class="language-Python">array26 = np.array([[30, 20, 10], [40, 60, 50], [10, 90, 80]])# 取二维数组的第1行和第3行array26[[0, 2]]</code></pre><p>输出：</p><pre><code>array([[30, 20, 10],       [10, 90, 80]])</code></pre><p>代码：</p><pre><code class="language-Python"># 取二维数组第1行第2列，第3行第3列的两个元素array26[[0, 2], [1, 2]]</code></pre><p>输出：</p><pre><code>array([20, 80])</code></pre><p>代码：</p><pre><code class="language-Python"># 取二维数组第1行第2列，第3行第2列的两个元素array26[[0, 2], 1]</code></pre><p>输出：</p><pre><code>array([20, 90])</code></pre></li><li><p>布尔索引</p><p>布尔索引就是通过布尔类型的数组对数组元素进行索引，布尔类型的数组可以手动构造，也可以通过关系运算来产生布尔类型的数组。</p><p>代码：</p><pre><code class="language-Python">array27 = np.arange(1, 10)array27[[True, False, True, True, False, False, False, False, True]]</code></pre><p>输出：</p><pre><code>array([1, 3, 4, 9])</code></pre><p>代码：</p><pre><code class="language-Python">array27 &gt;= 5</code></pre><p>输出：</p><pre><code>array([False, False, False, False,  True,  True,  True,  True,  True])</code></pre><p>代码：</p><pre><code class="language-Python"># ~运算符可以实现逻辑变反，看看运行结果跟上面有什么不同~(array27 &gt;= 5)</code></pre><p>输出：</p><pre><code>array([ True,  True,  True,  True, False, False, False, False, False])</code></pre><p>代码：</p><pre><code class="language-Python">array27[array27 &gt;= 5]</code></pre><p>输出：</p><pre><code>array([5, 6, 7, 8, 9])</code></pre></li></ol><blockquote><p><strong>提示</strong>：切片操作虽然创建了新的数组对象，但是新数组和原数组共享了数组中的数据，简单的说，如果通过新数组对象或原数组对象修改数组中的数据，其实修改的是同一块数据。花式索引和布尔索引也会创建新的数组对象，而且新数组复制了原数组的元素，新数组和原数组并不是共享数据的关系，这一点通过前面讲的数组的 <code>base</code>  属性也可以了解到，在使用的时候要引起注意。</p></blockquote><h4 id="案例通过数组切片处理图像"><a class="anchor" href="#案例通过数组切片处理图像">#</a> 案例：通过数组切片处理图像</h4><p>学习基础知识总是比较枯燥且没有成就感的，所以我们还是来个案例为大家演示下上面学习的数组索引和切片操作到底有什么用。前面我们说到过，可以用三维数组来表示图像，那么通过图像对应的三维数组进行操作，就可以实现对图像的处理，如下所示。</p><p>读入图片创建三维数组对象。</p><pre><code class="language-Python">guido_image = plt.imread('guido.jpg')plt.imshow(guido_image)</code></pre><p>对数组的 0 轴进行反向切片，实现图像的垂直翻转。</p><pre><code class="language-Python">plt.imshow(guido_image[::-1])</code></pre><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005115228.png" alt="" /></p><p>对数组的 1 轴进行反向切片，实现图像的水平翻转。</p><pre><code class="language-Python">plt.imshow(guido_image[:,::-1])</code></pre><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005115242.png" alt="" /></p><p>将 Guido 的头切出来。</p><pre><code class="language-Python">plt.imshow(guido_image[30:350, 90:300])</code></pre><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005115305.png" alt="" /></p><h3 id="数组对象的方法"><a class="anchor" href="#数组对象的方法">#</a> 数组对象的方法</h3><h4 id="统计方法"><a class="anchor" href="#统计方法">#</a> 统计方法</h4><p>统计方法主要包括： <code>sum()</code> 、 <code>mean()</code> 、 <code>std()</code> 、 <code>var()</code> 、 <code>min()</code> 、 <code>max()</code> 、 <code>argmin()</code> 、 <code>argmax()</code> 、 <code>cumsum()</code>  等，分别用于对数组中的元素求和、求平均、求标准差、求方差、找最大、找最小、求累积和等，请参考下面的代码。</p><pre><code class="language-Python">array28 = np.array([1, 2, 3, 4, 5, 5, 4, 3, 2, 1])print(array28.sum())print(array28.mean())print(array28.max())print(array28.min())print(array28.std())print(array28.var())print(array28.cumsum())</code></pre><p>输出：</p><pre><code>303.0511.41421356237309512.0[ 1  3  6 10 15 20 24 27 29 30]</code></pre><h4 id="其他方法"><a class="anchor" href="#其他方法">#</a> 其他方法</h4><ol><li><p><code>all()</code>  /  <code>any()</code>  方法：判断数组是否所有元素都是 <code>True</code>  / 判断数组是否有为 <code>True</code>  的元素。</p></li><li><p><code>astype()</code>  方法：拷贝数组，并将数组中的元素转换为指定的类型。</p></li><li><p><code>dump()</code>  方法：保存数组到文件中，可以通过 NumPy 中的 <code>load()</code>  函数从保存的文件中加载数据创建数组。</p><p>代码：</p><pre><code class="language-Python">array31.dump('array31-data')array32 = np.load('array31-data', allow_pickle=True)array32</code></pre><p>输出：</p><pre><code>array([[1, 2],       [3, 4],       [5, 6]])</code></pre></li><li><p><code>fill()</code>  方法：向数组中填充指定的元素。</p></li><li><p><code>flatten()</code>  方法：将多维数组扁平化为一维数组。</p><p>代码：</p><pre><code class="language-Python">array32.flatten()</code></pre><p>输出：</p><pre><code>array([1, 2, 3, 4, 5, 6])</code></pre></li><li><p><code>nonzero()</code>  方法：返回非 0 元素的索引。</p></li><li><p><code>round()</code>  方法：对数组中的元素做四舍五入操作。</p></li><li><p><code>sort()</code>  方法：对数组进行就地排序。</p><p>代码：</p><pre><code class="language-Python">array33 = np.array([35, 96, 12, 78, 66, 54, 40, 82])array33.sort()array33</code></pre><p>输出：</p><pre><code>array([12, 35, 40, 54, 66, 78, 82, 96])</code></pre></li><li><p><code>swapaxes()</code>  和 <code>transpose()</code>  方法：交换数组指定的轴。</p><p>代码：</p><pre><code class="language-Python"># 指定需要交换的两个轴，顺序无所谓array32.swapaxes(0, 1)</code></pre><p>输出：</p><pre><code>array([[1, 3, 5],      [2, 4, 6]])</code></pre><p>代码：</p><pre><code class="language-Python"># 对于二维数组，transpose相当于实现了矩阵的转置array32.transpose()</code></pre><p>输出：</p><pre><code>array([[1, 3, 5],      [2, 4, 6]])</code></pre></li><li><p><code>tolist()</code>  方法：将数组转成 Python 中的 <code>list</code> 。</p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境准备</title>
      <link href="/computer-science/python/basic/67.%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
      <url>/computer-science/python/basic/67.%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a class="anchor" href="#环境准备">#</a> 环境准备</h2><p>如果希望快速开始使用 Python 处理数据科学相关的工作，建议大家直接安装 Anaconda，然后使用 Anaconda 中集成的 Notebook 或 JupyterLab 工具来编写代码。因为对于新手来说，先安装官方的 Python 解释器，再逐个安装工作中会使用到的三方库文件会比较麻烦，尤其是在 Windows 环境下，经常会因为构建工具或 DLL 文件的缺失导致安装失败，而一般新手也很难根据错误提示信息采取正确的解决措施，容易产生严重的挫败感。如果计算机上已经有 Python 解释器环境了，也可以直接使用 Python 的包管理工具 pip 安装 Jupyter，再根据实际工作的需要安装三方库，这种方式适合有一定经验的用户。</p><h3 id="安装和使用-anaconda"><a class="anchor" href="#安装和使用-anaconda">#</a> 安装和使用 Anaconda</h3><p>对于个人用户来说，可以从 Anaconda 的<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5hY29uZGEuY29tLw==">官方网站</span>下载它的 “个人版（Individual Edition）” 安装程序，安装完成后，你的计算机上不仅拥有了 Python 环境和 Spyder（类似于 PyCharm 的集成开发工具），还拥有了与数据科学工作相关的近 200 个工具包，包括我们上面提到 Python 数据分析三大神器。除此之外，Anaconda 还提供了一个名为 conda 的包管理工具，通过这个工具不仅可以管理 Python 的工具包，还可以用于创建运行 Python 程序的虚拟环境。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMDA1MTExNDE3LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211005111417.png</span>&quot;&gt;</p><p>如上图所示，可以通过 Anaconda 官网提供的下载链接选择适合自己操作系统的安装程序，建议大家选择图形化的安装程序，下载完成后双击安装程序开始安装。安装过程基本使用默认设置即可，完成安装后，macOS 用户可以在 “应用程序” 或 “Launchpad” 中找到名为 “Anaconda-Navigator” 的应用程序，运行该程序可以看到如下所示的界面，我们可以在这里选择需要执行的操作。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9teXBpYy9yYXcvbWFzdGVyLzIwMjExMDA1MTExNzI5LnBuZw==">https://github.com/jackfrued/mypic/raw/master/20211005111729.png</span>&quot;&gt;</p><p>对于 Windows 用户，建议按照安装向导的提示和推荐的选项来安装 Anaconda（除了安装路径，基本也没有什么需要选择的），安装完成后可以在 “开始菜单” 中找到 “Anaconda3”。</p><blockquote><p><strong>温馨提示</strong>：可以选择 Miniconda 作为 Anaconda 的替代品，Miniconda 只会安装 Python 解释器环境和一些必要的工具，其他的三方库由用户自行选择安装。其实我个人并不喜欢 Anaconda，因为它是给小白用户使用的，我们有了 Python 以后完全可以按照自己的意愿来安装需要的三方库。</p></blockquote><h4 id="conda命令"><a class="anchor" href="#conda命令">#</a> conda 命令</h4><p>如果希望使用 conda 工具来管理依赖项或者创建项目的虚拟环境，可以在终端或命令行提示符中使用 conda 命令。Windows 用户可以在 “开始菜单” 中找到 “Anaconda3”，然后点击 “Anaconda Prompt” 来启动支持 conda 的命令行提示符。macOS 用户建议直接使用 “Anaconda-Navigator” 中的 “Environments”，通过可视化的方式对虚拟环境和依赖项进行管理。</p><ol><li><p>版本和帮助信息。</p><ul><li>查看版本： <code>conda -V</code>  或 <code>conda --version</code></li><li>获取帮助： <code>conda -h</code>  或 <code>conda --help</code></li><li>相关信息： <code>conda list</code></li></ul></li><li><p>虚拟环境相关。</p><ul><li>显示所有虚拟环境： <code>conda env list</code></li><li>创建虚拟环境： <code>conda create --name venv</code></li><li>指定 Python 版本创建虚拟环境： <code>conda create --name venv python=3.7</code></li><li>指定 Python 版本创建虚拟环境并安装指定依赖项： <code>conda create --name venv python=3.7 numpy pandas</code></li><li>通过克隆现有虚拟环境的方式创建虚拟环境： <code>conda create --name venv2 --clone venv</code></li><li>分享虚拟环境并重定向到指定的文件中： <code>conda env export &gt; environment.yml</code></li><li>通过分享的虚拟环境文件创建虚拟环境： <code>conda env create -f environment.yml</code></li><li>激活虚拟环境： <code>conda activate venv</code></li><li>退出虚拟环境： <code>conda deactivate</code></li><li>删除虚拟环境： <code>conda remove --name venv --all</code></li></ul><blockquote><p><strong>说明</strong>：上面的命令中， <code>venv</code>  和 <code>venv2</code>  是虚拟环境文件夹的名字，可以将其替换为自己喜欢的名字，但是<strong>强烈建议</strong>使用英文且不要出现空格或其他特殊字符。</p></blockquote></li><li><p>包（三方库或工具）管理。</p><ul><li>查看已经安装的包： <code>conda list</code></li><li>搜索指定的包： <code>conda search matplotlib</code></li><li>安装指定的包： <code>conda install matplotlib</code></li><li>更新指定的包： <code>conda update matplotlib</code></li><li>移除指定的包： <code>conda remove matplotlib</code></li></ul><blockquote><p><strong>说明</strong>：在搜索、安装和更新软件包时，默认会连接到官方网站进行操作，如果觉得速度不给力，可以将默认的官方网站替换为国内的镜像网站，推荐使用清华大学的开源镜像网站。将默认源更换为国内镜像的命令是： <code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</code>  和 <code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</code> 。如果需要换回默认源，可以使用命令 <code>conda config --remove-key channels</code> 。</p></blockquote></li></ol><h3 id="使用notebook"><a class="anchor" href="#使用notebook">#</a> 使用 Notebook</h3><h4 id="安装和启动notebook"><a class="anchor" href="#安装和启动notebook">#</a> 安装和启动 Notebook</h4><p>如果已经安装了 Anaconda，macOS 用户可以按照上面所说的方式在 “Anaconda-Navigator” 中直接启动 “Jupyter Notebook”（以下统一简称为 Notebook）。Windows 用户可以在 “开始菜单” 中找到 Anaconda 文件夹，接下来选择运行文件夹中的 “Jupyter Notebook” 就可以开始数据科学的探索之旅。</p><p>对于安装了 Python 环境但是没有安装 Anaconda 的用户，可以用 Python 的包管理工具 <code>pip</code>  来安装 <code>jupyter</code> ，然后在终端（Windows 系统为命令行提示符）中运行 <code>jupyter notebook</code>  命令来启动 Notebook，如下所示。</p><p>安装 Notebook：</p><pre><code class="language-Bash">pip install jupyter</code></pre><p>安装三大神器：</p><pre><code class="language-Bash">pip install numpy pandas matplotlib</code></pre><p>运行 Notebook：</p><pre><code class="language-Bash">jupyter notebook</code></pre><p>Notebook 是基于网页的用于交互计算的应用程序，可以用于代码开发、文档撰写、代码运行和结果展示。简单的说，你可以在网页中直接<strong>编写代码</strong>和<strong>运行代码</strong>，代码的运行结果也会直接在代码块下方进行展示。如在编写代码的过程中需要编写说明文档，可在同一个页面中使用 Markdown 格式进行编写，而且可以直接看到渲染后的效果。此外，Notebook 的设计初衷是提供一个能够支持多种编程语言的工作环境，目前它能够支持超过 40 种编程语言，包括 Python、R、Julia、Scala 等。</p><p>首先，我们可以创建一个用于书写 Python 代码的 Notebook，如下图所示。</p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211129131353.png" alt="" /></p><p>接下来，我们就可以编写代码、撰写文档和运行程序啦，如下图所示。</p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005113900.png" alt="" /></p><h4 id="notebook使用技巧"><a class="anchor" href="#notebook使用技巧">#</a> Notebook 使用技巧</h4><p>如果使用 Python 做工程化的项目开发，PyCharm 肯定是最好的选择，它提供了一个集成开发环境应该具有的所有功能，尤其是智能提示、代码补全、自动纠错这类功能会让开发人员感到非常舒服。如果使用 Python 做数据科学相关的工作，Notebook 并不比 PyCharm 逊色，在数据和图表展示方面 Notebook 更加优秀。这个工具的使用非常简单，大家可以看看 Notebook 菜单栏，相信理解起来不会有太多困难，在知乎上有一篇名为<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjMyMDIxNA==">《最详尽使用指南：超快上手 Jupyter Notebook》</span>的文章，也可以帮助大家快速认识 Notebook。</p><blockquote><p><strong>说明</strong>：<span class="exturl" data-url="aHR0cHM6Ly9qdXB5dGVyLm9yZy8=">Jupyter 官网</span>上还有一个名为 JupyterLab 的工具，被称之为 “Next-Generation Notebook”，用户界面较之 Notebook 更加友好，有兴趣的读者可以使用 <code>pip install jupyterlab</code>  命令来安装这个工具，然后通过 <code>jupyter lab</code>  来启动它。</p></blockquote><p>下面我为大家介绍一些 Notebook 的使用技巧，希望能够帮助大家提升工作效率。</p><ol><li><p>自动补全。在使用 Notebook 编写代码时，按 <code>Tab</code>  键会获得代码提示。</p></li><li><p>获得帮助。在使用 Notebook 时，如果希望了解一个对象（如变量、类、函数等）的相关信息或使用方式，可以在对象后面使用 <code>?</code>  并运行代码， 窗口下方会显示出对应的信息，帮助我们了解该对象，如下所示。</p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005113848.png" alt="" /></p></li><li><p>搜索命名。如果只记得一个类或一个函数名字的一部分，可以使用通配符 <code>*</code>  并配合 <code>?</code>  进行搜索，如下所示。</p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005113836.png" alt="" /></p></li><li><p>调用命令。可以在 Notebook 中使用 <code>!</code>  后面跟系统命令的方式来执行系统命令。</p></li><li><p>魔法指令。Notebook 中有很多非常有趣且有用的魔法指令，例如可以使用 <code>%timeit</code>  测试语句的执行时间，可以使用 <code>%pwd</code>  查看当前工作目录等。如果想查看所有的魔法指令，可以使用 <code>%lsmagic</code> ，如果了解魔法指令的用法，可以使用 <code>%magic</code>  来查看，如下图所示。</p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005113825.png" alt="" /></p><p>常用的魔法指令有：</p><p>| 魔法指令                                    | 功能说明                                   |<br />| ------------------------------------------- | ------------------------------------------ |<br />|  <code>%pwd</code>                                       | 查看当前工作目录                           |<br />|  <code>%ls</code>                                        | 列出当前或指定文件夹下的内容               |<br />|  <code>%cat</code>                                       | 查看指定文件的内容                         |<br />|  <code>%hist</code>                                      | 查看输入历史                               |<br />|  <code>%matplotlib inline</code>                         | 设置在页面中嵌入 matplotlib 输出的统计图表   |<br />|  <code>%config Inlinebackend.figure_format='svg'</code>  | 设置统计图表使用 SVG 格式（矢量图）          |<br />|  <code>%run</code>                                       | 运行指定的程序                             |<br />|  <code>%load</code>                                      | 加载指定的文件到单元格中                   |<br />|  <code>%quickref</code>                                  | 显示 IPython 的快速参考                      |<br />|  <code>%timeit</code>                                    | 多次运行代码并统计代码执行时间             |<br />|  <code>%prun</code>                                      | 用 <code>cProfile.run</code>  运行代码并显示分析器的输出 |<br />|  <code>%who</code>  /  <code>%whos</code>                             | 显示命名空间中的变量                       |<br />|  <code>%xdel</code>                                      | 删除一个对象并清理所有对它的引用           |</p></li><li><p>快捷键。Notebook 中的很多操作可以通过快捷键来实现，使用快捷键可以提升工作效率。Notebook 的快捷键又可以分为命令模式下的快捷键和编辑模式下的快捷键，所谓编辑模式就是处于输入代码或撰写文档状态的模式，在编辑模式下按 <code>Esc</code>  可以回到命令模式，在命令模式下按 <code>Enter</code>  可以进入编辑模式。</p><p>命令模式下的快捷键：</p><p>| 快捷键                                   | 功能说明                                     |<br />| ---------------------------------------- | -------------------------------------------- |<br />|  <code>Alt</code>  +  <code>Enter</code> （ <code>Option</code>  +  <code>Enter</code> ）    | 运行当前单元格并在下面插入新的单元格         |<br />|  <code>Shift</code>  +  <code>Enter</code>                         | 运行当前单元格并选中下方的单元格             |<br />|  <code>Ctrl</code>  +  <code>Enter</code> （ <code>Command</code>  +  <code>Enter</code> ）  | 运行当前单元格                               |<br />|  <code>j</code>  /  <code>k</code> 、 <code>Shift</code>  +  <code>j</code>  /  <code>Shift</code>  +  <code>k</code>  | 选中下方 / 上方单元格、连续选中下方 / 上方单元格 |<br />|  <code>a</code>  /  <code>b</code>                                 | 在下方 / 上方插入新的单元格                    |<br />|  <code>c</code>  /  <code>x</code>                                 | 复制单元格 / 剪切单元格                      |<br />|  <code>v</code>  /  <code>Shift</code>  +  <code>v</code>                       | 在下方 / 上方粘贴单元格                        |<br />|  <code>dd</code>  /  <code>z</code>                                | 删除单元格 / 恢复删除的单元格                |<br />|  <code>l</code>  /  <code>Shift</code>  +  <code>l</code>                       | 显示或隐藏当前 / 所有单元格行号                |<br />|  <code>ii</code>  /  <code>00</code>                               | 中断 / 重启 Notebook 内核                        |<br />|  <code>Space</code>  /  <code>Shift</code>  +  <code>Space</code>               | 向下 / 向上滚动页面                            |</p><p>编辑模式下的快捷键：</p><p>| 快捷键                                                       | 功能说明                               |<br />| ------------------------------------------------------------ | -------------------------------------- |<br />|  <code>Shift</code>  +  <code>Tab</code>                                               | 获得提示信息                           |<br />|  <code>Ctrl</code>  +  <code>]</code> （ <code>Command</code>  +  <code>]</code> ）/  <code>Ctrl</code>  +  <code>[</code> （ <code>Command</code>  +  <code>[</code> ） | 增加 / 减少缩进                          |<br />|  <code>Alt</code>  +  <code>Enter</code> （ <code>Option</code>  +  <code>Enter</code> ）                        | 运行当前单元格并在下面插入新的单元格   |<br />|  <code>Shift</code>  +  <code>Enter</code>                                             | 运行当前单元格并选中下方的单元格       |<br />|  <code>Ctrl</code>  +  <code>Enter</code> （ <code>Command</code>  +  <code>Enter</code> ）                      | 运行当前单元格                         |<br />|  <code>Ctrl</code>  +  <code>Left</code>  /  <code>Right</code> （ <code>Command</code>  +  <code>Left</code>  /  <code>Right</code> ）    | 光标移到行首 / 行尾                      |<br />|  <code>Ctrl</code>  +  <code>Up</code>  /  <code>Down</code> （ <code>Command</code>  +  <code>Up</code>  /  <code>Down</code> ）          | 光标移动代码开头 / 结尾处                |<br />|  <code>Up</code>  /  <code>Down</code>                                                 | 光标上移 / 下移一行或移到上 / 下一个单元格 |</p><blockquote><p><strong>温馨提示</strong>：如果记不住这些快捷键也没有关系，在命令模式下按 <code>h</code>  键可以打开 Notebook 的帮助系统，马上就可以看到快捷键的设置，而且可以根据实际的需要重新编辑快捷键，如下图所示。</p><p><img data-src="https://github.com/jackfrued/mypic/raw/master/20211005113812.png" alt="" /></p></blockquote></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析概述</title>
      <link href="/computer-science/python/basic/66.%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/"/>
      <url>/computer-science/python/basic/66.%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据分析概述"><a class="anchor" href="#数据分析概述">#</a> 数据分析概述</h2><p>当今世界对信息技术的依赖程度在不断加深，每天都会有大量的数据产生，我们经常会感到数据越来越多，但是要从中发现有价值的信息却越来越难。这里所说的信息，可以理解为对数据集处理之后的结果，是从数据集中提炼出的可用于其他场合的结论性的东西，而<strong>从原始数据中抽取出有价值的信息</strong>的这个过程我们就称之为<strong>数据分析</strong>，它是数据科学工作的一部分。</p><blockquote><p>定义：<strong>数据分析是有针对性的收集、加工、整理数据并采用统计、挖掘等技术对数据进行分析和解释的科学和艺术</strong>。</p></blockquote><h3 id="数据分析师的职责和技能栈"><a class="anchor" href="#数据分析师的职责和技能栈">#</a> 数据分析师的职责和技能栈</h3><p>HR 在发布招聘需求时，通常将数据工程、数据分析、数据挖掘等岗位都统称为数据分析岗位，但是根据工作性质的不同，又可以分为偏工程的<strong>数据治理方向</strong>、偏业务的<strong>数据分析方向</strong>、偏算法的<strong>数据挖掘方向</strong>、偏开发的<strong>数据开发方向</strong>、偏产品的<strong>数据产品经理</strong>。我们通常所说的数据分析师主要是指<strong>业务数据分析师</strong>，很多数据分析师的职业生涯都是从这个岗位开始的，而且这个岗位也是招聘数量最多的岗位。业务数据分析师在公司通常不属于研发部门而属于运营部门，所以这个岗位也称为<strong>数据运营</strong>或<strong>商业分析</strong>，这类人员通常也被称为 “BI 工程师”。通常招聘信息对这个岗位的描述（JD）是：</p><ol><li>负责相关报表的输出。</li><li>建立和优化指标体系。</li><li>监控数据波动和异常，找出问题。</li><li>优化和驱动业务，推动数字化运营。</li><li>找出潜在的市场和产品的上升空间。</li></ol><p>根据上面的描述，作为业务数据分析师，我们的工作不是给领导一个简单浅显的结论，而是结合公司的业务，完成<strong>监控数据</strong>、<strong>揪出异常</strong>、<strong>找到原因</strong>、<strong>探索趋势</strong>等工作。作为数据分析师，不管是用 Python 语言、Excel、SPSS 或其他的商业智能工具，工具只是达成目标的手段，<strong>数据思维是核心技能</strong>，从实际业务问题出发到最终<strong>发现数据中的商业价值</strong>是终极目标。数据分析师在很多公司只是一个基础岗位，精于业务的数据分析师可以向<strong>数据分析经理</strong>或<strong>数据运营总监</strong>等管理岗位发展；对于熟悉机器学习算法的数据分析师来说，可以向<strong>数据挖掘工程师</strong>或<strong>算法专家</strong>方向发展，而这些岗位除了需要相应的数学和统计学知识，在编程能力方面也比数据分析师有更高的要求，可能还需要有大数据存储和处理的相关经验。数据治理岗位主要是帮助公司建设数据仓库或数据湖，实现数据从业务系统、埋点系统、日志系统到分析库的转移，为后续的数据分析和挖掘提供基础设施。数据治理岗位对 SQL 和 HiveSQL 有着较高的要求，要求能够熟练的使用 ETL 工具，此外可能还需要对 Hadoop 生态圈有一个很好的认知。作为数据产品经理，除了传统产品经理的技能栈之外，也需要较强的技术能力，例如要了解常用的推荐算法、机器学习模型，能够为算法的改进提供依据，能够制定相关埋点的规范和口径，虽然不需要精通各种算法，但是要站在产品的角度去考虑数据模型、指标、算法等的落地</p><p>以下是我总结的数据分析师的技能栈，仅供参考。</p><ol><li>计算机科学（数据分析工具、编程语言、数据库）</li><li>数学和统计学（数据思维、统计思维）</li><li>人工智能（机器学习中的数据挖掘算法）</li><li>业务理解能力（沟通、表达、经验）</li><li>总结和表述能力（商业 PPT、文字总结）</li></ol><h3 id="数据分析的流程"><a class="anchor" href="#数据分析的流程">#</a> 数据分析的流程</h3><p>我们提到数分析这个词很多时候可能指的都是<strong>狭义的数据分析</strong>，这类数据分析主要目标就是生成可视化报表并通过这些报表来洞察业务中的问题。<strong>广义的数据分析</strong>还包含了数据挖掘的部分，不仅要通过数据实现对业务的监控和分析，还要利用机器学习算法，找出隐藏在数据背后的知识，并利用这些知识为将来的决策提供支撑。简单的说，<strong>一个完整的数据分析应该包括基本的数据分析和深入的数据挖掘两个部分</strong>。</p><p>基本的数据分析工作一般包含以下几个方面的内容，当然因为行业和工作内容的不同会略有差异。</p><ol><li>确定目标（输入）：理解业务，确定指标口径</li><li>获取数据：数据仓库、电子表格、三方接口、网络爬虫、开放数据集等</li><li>清洗数据：缺失值 / 重复值 / 异常值处理、数据变换（格式化、规范化）、离散化等</li><li>数据透视：运算、统计、分组、聚合、可视化</li><li>数据报告（输出）：数据发布，工作成果总结汇报</li><li>分析洞察（后续）：解释数据的变化，提出对应的方案</li></ol><p>深入的数据挖掘工作通常包含以下几个方面的内容，当然因为行业和工作内容的不同会略有差异。</p><ol><li>确定目标（输入）：理解业务，明确挖掘目标</li><li>数据准备：数据采集、数据描述、数据探索、质量判定等</li><li>数据加工：提取数据、清洗数据、数据变换、特殊编码、降维、特征选择等</li><li>数据建模：模型比较、模型选择、算法应用</li><li>模型评估：交叉检验、参数调优、结果评价</li><li>模型部署（输出）：模型落地、业务改进、运营监控、报告撰写</li></ol><h3 id="数据分析相关库"><a class="anchor" href="#数据分析相关库">#</a> 数据分析相关库</h3><p>使用 Python 从事数据科学相关的工作是一个非常棒的选择，因为 Python 整个生态圈中，有大量的成熟的用于数据科学的软件包（工具库）。而且不同于其他的用于数据科学的编程语言（如：Julia、R），Python 除了可以用于数据科学，能做的事情还很多，可以说 Python 语言几乎是无所不能的。</p><h4 id="三大神器"><a class="anchor" href="#三大神器">#</a> 三大神器</h4><ol><li><span class="exturl" data-url="aHR0cHM6Ly9udW1weS5vcmcv">NumPy</span>：支持常见的数组和矩阵操作，通过 <code>ndarray</code>  类实现了对多维数组的封装，提供了操作这些数组的方法和函数集。由于 NumPy 内置了并行运算功能，当使用多核 CPU 时，Numpy 会自动做并行计算。</li><li><span class="exturl" data-url="aHR0cHM6Ly9wYW5kYXMucHlkYXRhLm9yZy8=">Pandas</span>：pandas 的核心是其特有的数据结构 <code>DataFrame</code>  和 <code>Series</code> ，这使得 pandas 可以处理包含不同类型的数据的负责表格和时间序列，这一点是 NumPy 的 <code>ndarray</code>  做不到的。使用 pandas，可以轻松顺利的加载各种形式的数据，然后对数据进行切片、切块、处理缺失值、聚合、重塑和可视化等操作。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tYXRwbG90bGliLm9yZy8=">Matplotlib</span>：matplotlib 是一个包含各种绘图模块的库，能够根据我们提供的数据创建高质量的图形。此外，matplotlib 还提供了 pylab 模块，这个模块包含了很多像 <span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0aHdvcmtzLmNvbS9wcm9kdWN0cy9tYXRsYWIuaHRtbA==">MATLAB</span> 一样的绘图组件。</li></ol><h4 id="其他相关库"><a class="anchor" href="#其他相关库">#</a> 其他相关库</h4><ol><li><span class="exturl" data-url="aHR0cHM6Ly9zY2lweS5vcmcv">SciPy</span>：完善了 NumPy 的功能，封装了大量科学计算的算法，包括线性代数、稀疏矩阵、信号和图像处理、最优化问题、快速傅里叶变换等。</li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWFib3JuLnB5ZGF0YS5vcmcv">Seaborn</span>：seaborn 是基于 matplotlib 的图形可视化工具，直接使用 matplotlib 虽然可以定制出漂亮的统计图表，但是总体来说还不够简单方便，seaborn 相当于是对 matplotlib 做了封装，让用户能够以更简洁有效的方式做出各种有吸引力的统计图表。</li><li><span class="exturl" data-url="aHR0cHM6Ly9zY2lraXQtbGVhcm4ub3JnLw==">Scikit-learn</span>：scikit-learn 最初是 SciPy 的一部分，它是 Python 数据科学运算的核心，提供了大量机器学习可能用到的工具，包括：数据预处理、监督学习（分类、回归）、无监督学习（聚类）、模式选择、交叉检验等。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc3RhdHNtb2RlbHMub3JnL3N0YWJsZS9pbmRleC5odG1s">Statsmodels</span>：包含了经典统计学和经济计量学算法的库。</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫框架Scrapy简介</title>
      <link href="/computer-science/python/basic/65.%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy%E7%AE%80%E4%BB%8B/"/>
      <url>/computer-science/python/basic/65.%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="爬虫框架scrapy简介"><a class="anchor" href="#爬虫框架scrapy简介">#</a> 爬虫框架 Scrapy 简介</h2><p>当你写了很多个爬虫程序之后，你会发现每次写爬虫程序时，都需要将页面获取、页面解析、爬虫调度、异常处理、反爬应对这些代码从头至尾实现一遍，这里面有很多工作其实都是简单乏味的重复劳动。那么，有没有什么办法可以提升我们编写爬虫代码的效率呢？答案是肯定的，那就是利用爬虫框架，而在所有的爬虫框架中，Scrapy 应该是最流行、最强大的框架。</p><h3 id="scrapy-概述"><a class="anchor" href="#scrapy-概述">#</a> Scrapy 概述</h3><p>Scrapy 是基于 Python 的一个非常流行的网络爬虫框架，可以用来抓取 Web 站点并从页面中提取结构化的数据。下图展示了 Scrapy 的基本架构，其中包含了主要组件和系统的数据处理流程（图中带数字的红色箭头）。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210824003638.png" alt="" /></p><h4 id="scrapy的组件"><a class="anchor" href="#scrapy的组件">#</a> Scrapy 的组件</h4><p>我们先来说说 Scrapy 中的组件。</p><ol><li>Scrapy 引擎（Engine）：用来控制整个系统的数据处理流程。</li><li>调度器（Scheduler）：调度器从引擎接受请求并排序列入队列，并在引擎发出请求后返还给它们。</li><li>下载器（Downloader）：下载器的主要职责是抓取网页并将网页内容返还给蜘蛛（Spiders）。</li><li>蜘蛛程序（Spiders）：蜘蛛是用户自定义的用来解析网页并抓取特定 URL 的类，每个蜘蛛都能处理一个域名或一组域名，简单的说就是用来定义特定网站的抓取和解析规则的模块。</li><li>数据管道（Item Pipeline）：管道的主要责任是负责处理有蜘蛛从网页中抽取的数据条目，它的主要任务是清理、验证和存储数据。当页面被蜘蛛解析后，将被发送到数据管道，并经过几个特定的次序处理数据。每个数据管道组件都是一个 Python 类，它们获取了数据条目并执行对数据条目进行处理的方法，同时还需要确定是否需要在数据管道中继续执行下一步或是直接丢弃掉不处理。数据管道通常执行的任务有：清理 HTML 数据、验证解析到的数据（检查条目是否包含必要的字段）、检查是不是重复数据（如果重复就丢弃）、将解析到的数据存储到数据库（关系型数据库或 NoSQL 数据库）中。</li><li>中间件（Middlewares）：中间件是介于引擎和其他组件之间的一个钩子框架，主要是为了提供自定义的代码来拓展 Scrapy 的功能，包括下载器中间件和蜘蛛中间件。</li></ol><h4 id="数据处理流程"><a class="anchor" href="#数据处理流程">#</a> 数据处理流程</h4><p>Scrapy 的整个数据处理流程由引擎进行控制，通常的运转流程包括以下的步骤：</p><ol><li><p>引擎询问蜘蛛需要处理哪个网站，并让蜘蛛将第一个需要处理的 URL 交给它。</p></li><li><p>引擎让调度器将需要处理的 URL 放在队列中。</p></li><li><p>引擎从调度那获取接下来进行爬取的页面。</p></li><li><p>调度将下一个爬取的 URL 返回给引擎，引擎将它通过下载中间件发送到下载器。</p></li><li><p>当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎；如果下载失败了，引擎会通知调度器记录这个 URL，待会再重新下载。</p></li><li><p>引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。</p></li><li><p>蜘蛛处理响应并返回爬取到的数据条目，此外还要将需要跟进的新的 URL 发送给引擎。</p></li><li><p>引擎将抓取到的数据条目送入数据管道，把新的 URL 发送给调度器放入队列中。</p></li></ol><p>上述操作中的第 2 步到第 8 步会一直重复直到调度器中没有需要请求的 URL，爬虫就停止工作。</p><h3 id="安装和使用scrapy"><a class="anchor" href="#安装和使用scrapy">#</a> 安装和使用 Scrapy</h3><p>可以使用 Python 的包管理工具 <code>pip</code>  来安装 Scrapy。</p><pre><code class="language-Shell">pip install scrapy</code></pre><p>在命令行中使用 <code>scrapy</code>  命令创建名为 <code>demo</code>  的项目。</p><pre><code class="language-Bash">scrapy startproject demo</code></pre><p>项目的目录结构如下图所示。</p><pre><code class="language-Shell">demo|____ demo|________ spiders|____________ __init__.py|________ __init__.py|________ items.py|________ middlewares.py|________ pipelines.py|________ settings.py|____ scrapy.cfg</code></pre><p>切换到 <code>demo</code>  目录，用下面的命令创建名为 <code>douban</code>  的蜘蛛程序。</p><pre><code class="language-Bash">scrapy genspider douban movie.douban.com</code></pre><h4 id="一个简单的例子"><a class="anchor" href="#一个简单的例子">#</a> 一个简单的例子</h4><p>接下来，我们实现一个爬取豆瓣电影 Top250 电影标题、评分和金句的爬虫。</p><ol><li><p>在 <code>items.py</code>  的 <code>Item</code>  类中定义字段，这些字段用来保存数据，方便后续的操作。</p><pre><code class="language-Python">import scrapyclass DoubanItem(scrapy.Item):    title = scrapy.Field()    score = scrapy.Field()    motto = scrapy.Field()</code></pre></li><li><p>修改 <code>spiders</code>  文件夹中名为 <code>douban.py</code>  的文件，它是蜘蛛程序的核心，需要我们添加解析页面的代码。在这里，我们可以通过对 <code>Response</code>  对象的解析，获取电影的信息，代码如下所示。</p><pre><code class="language-Python">import scrapyfrom scrapy import Selector, Requestfrom scrapy.http import HtmlResponsefrom demo.items import MovieItemclass DoubanSpider(scrapy.Spider):    name = 'douban'    allowed_domains = ['movie.douban.com']    start_urls = ['https://movie.douban.com/top250?start=0&amp;filter=']    def parse(self, response: HtmlResponse):        sel = Selector(response)        movie_items = sel.css('#content &gt; div &gt; div.article &gt; ol &gt; li')        for movie_sel in movie_items:            item = MovieItem()            item['title'] = movie_sel.css('.title::text').extract_first()            item['score'] = movie_sel.css('.rating_num::text').extract_first()            item['motto'] = movie_sel.css('.inq::text').extract_first()            yield item</code></pre><p>通过上面的代码不难看出，我们可以使用 CSS 选择器进行页面解析。当然，如果你愿意也可以使用 XPath 或正则表达式进行页面解析，对应的方法分别是 <code>xpath</code>  和 <code>re</code> 。</p><p>如果还要生成后续爬取的请求，我们可以用 <code>yield</code>  产出 <code>Request</code>  对象。 <code>Request</code>  对象有两个非常重要的属性，一个是 <code>url</code> ，它代表了要请求的地址；一个是 <code>callback</code> ，它代表了获得响应之后要执行的回调函数。我们可以将上面的代码稍作修改。</p><pre><code class="language-Python">import scrapyfrom scrapy import Selector, Requestfrom scrapy.http import HtmlResponsefrom demo.items import MovieItemclass DoubanSpider(scrapy.Spider):    name = 'douban'    allowed_domains = ['movie.douban.com']    start_urls = ['https://movie.douban.com/top250?start=0&amp;filter=']    def parse(self, response: HtmlResponse):        sel = Selector(response)        movie_items = sel.css('#content &gt; div &gt; div.article &gt; ol &gt; li')        for movie_sel in movie_items:            item = MovieItem()            item['title'] = movie_sel.css('.title::text').extract_first()            item['score'] = movie_sel.css('.rating_num::text').extract_first()            item['motto'] = movie_sel.css('.inq::text').extract_first()            yield item        hrefs = sel.css('#content &gt; div &gt; div.article &gt; div.paginator &gt; a::attr(&quot;href&quot;)')        for href in hrefs:            full_url = response.urljoin(href.extract())            yield Request(url=full_url)</code></pre><p>到这里，我们已经可以通过下面的命令让爬虫运转起来。</p><pre><code class="language-Shell">scrapy crawl movie</code></pre><p>可以在控制台看到爬取到的数据，如果想将这些数据保存到文件中，可以通过 <code>-o</code>  参数来指定文件名，Scrapy 支持我们将爬取到的数据导出成 JSON、CSV、XML 等格式。</p><pre><code class="language-Shell">scrapy crawl moive -o result.json</code></pre><p>不知大家是否注意到，通过运行爬虫获得的 JSON 文件中有 <code>275</code>  条数据，那是因为首页被重复爬取了。要解决这个问题，可以对上面的代码稍作调整，不在 <code>parse</code>  方法中解析获取新页面的 URL，而是通过 <code>start_requests</code>  方法提前准备好待爬取页面的 URL，调整后的代码如下所示。</p><pre><code class="language-Python">import scrapyfrom scrapy import Selector, Requestfrom scrapy.http import HtmlResponsefrom demo.items import MovieItemclass DoubanSpider(scrapy.Spider):    name = 'douban'    allowed_domains = ['movie.douban.com']    def start_requests(self):        for page in range(10):            yield Request(url=f'https://movie.douban.com/top250?start=&#123;page * 25&#125;')    def parse(self, response: HtmlResponse):        sel = Selector(response)        movie_items = sel.css('#content &gt; div &gt; div.article &gt; ol &gt; li')        for movie_sel in movie_items:            item = MovieItem()            item['title'] = movie_sel.css('.title::text').extract_first()            item['score'] = movie_sel.css('.rating_num::text').extract_first()            item['motto'] = movie_sel.css('.inq::text').extract_first()            yield item</code></pre></li><li><p>如果希望完成爬虫数据的持久化，可以在数据管道中处理蜘蛛程序产生的 <code>Item</code>  对象。例如，我们可以通过前面讲到的 <code>openpyxl</code>  操作 Excel 文件，将数据写入 Excel 文件中，代码如下所示。</p><pre><code class="language-Python">import openpyxlfrom demo.items import MovieItemclass MovieItemPipeline:    def __init__(self):        self.wb = openpyxl.Workbook()        self.sheet = self.wb.active        self.sheet.title = 'Top250'        self.sheet.append(('名称', '评分', '名言'))    def process_item(self, item: MovieItem, spider):        self.sheet.append((item['title'], item['score'], item['motto']))        return item    def close_spider(self, spider):        self.wb.save('豆瓣电影数据.xlsx')</code></pre><p>上面的 <code>process_item</code>  和 <code>close_spider</code>  都是回调方法（钩子函数）， 简单的说就是 Scrapy 框架会自动去调用的方法。当蜘蛛程序产生一个 <code>Item</code>  对象交给引擎时，引擎会将该 <code>Item</code>  对象交给数据管道，这时我们配置好的数据管道的 <code>parse_item</code>  方法就会被执行，所以我们可以在该方法中获取数据并完成数据的持久化操作。另一个方法 <code>close_spider</code>  是在爬虫结束运行前会自动执行的方法，在上面的代码中，我们在这个地方进行了保存 Excel 文件的操作，相信这段代码大家是很容易读懂的。</p><p>总而言之，数据管道可以帮助我们完成以下操作：</p><ul><li>清理 HTML 数据，验证爬取的数据。</li><li>丢弃重复的不必要的内容。</li><li>将爬取的结果进行持久化操作。</li></ul></li><li><p>修改 <code>settings.py</code>  文件对项目进行配置，主要需要修改以下几个配置。</p><pre><code class="language-Python"># 用户浏览器USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'# 并发请求数量 CONCURRENT_REQUESTS = 4# 下载延迟DOWNLOAD_DELAY = 3# 随机化下载延迟RANDOMIZE_DOWNLOAD_DELAY = True# 是否遵守爬虫协议ROBOTSTXT_OBEY = True# 配置数据管道ITEM_PIPELINES = &#123;   'demo.pipelines.MovieItemPipeline': 300,&#125;</code></pre><blockquote><p><strong>说明</strong>：上面配置文件中的 <code>ITEM_PIPELINES</code>  选项是一个字典，可以配置多个处理数据的管道，后面的数字代表了执行的优先级，数字小的先执行。</p></blockquote></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Selenium抓取网页动态内容</title>
      <link href="/computer-science/python/basic/64.%E4%BD%BF%E7%94%A8Selenium%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9/"/>
      <url>/computer-science/python/basic/64.%E4%BD%BF%E7%94%A8Selenium%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="使用selenium抓取网页动态内容"><a class="anchor" href="#使用selenium抓取网页动态内容">#</a> 使用 Selenium 抓取网页动态内容</h2><p>根据权威机构发布的全球互联网可访问性审计报告，全球约有四分之三的网站其内容或部分内容是通过 JavaScript 动态生成的，这就意味着在浏览器窗口中 “查看网页源代码” 时无法在 HTML 代码中找到这些内容，也就是说我们之前用的抓取数据的方式无法正常运转了。解决这样的问题基本上有两种方案，一是获取提供动态内容的数据接口，这种方式也适用于抓取手机 App 的数据；另一种是通过自动化测试工具 Selenium 运行浏览器获取渲染后的动态内容。对于第一种方案，我们可以使用浏览器的 “开发者工具” 或者更为专业的抓包工具（如：Charles、Fiddler、Wireshark 等）来获取到数据接口，后续的操作跟上一个章节中讲解的获取 “360 图片” 网站的数据是一样的，这里我们不再进行赘述。这一章我们重点讲解如何使用自动化测试工具 Selenium 来获取网站的动态内容。</p><h3 id="selenium-介绍"><a class="anchor" href="#selenium-介绍">#</a> Selenium 介绍</h3><p>Selenium 是一个自动化测试工具，利用它可以驱动浏览器执行特定的行为，最终帮助爬虫开发者获取到网页的动态内容。简单的说，只要我们在浏览器窗口中能够看到的内容，都可以使用 Selenium 获取到，对于那些使用了 JavaScript 动态渲染技术的网站，Selenium 会是一个重要的选择。下面，我们还是以 Chrome 浏览器为例，来讲解 Selenium 的用法，大家需要先安装 Chrome 浏览器并下载它的驱动。Chrome 浏览器的驱动程序可以在<span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWVkcml2ZXIuY2hyb21pdW0ub3JnL2Rvd25sb2Fkcw=="> ChromeDriver 官网</span>进行下载，驱动的版本要跟浏览器的版本对应，如果没有完全对应的版本，就选择版本代号最为接近的版本。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMjAzMTAxMzQ1NTgucG5n">https://gitee.com/jackfrued/mypic/raw/master/20220310134558.png</span>&quot; style=&quot;zoom: 35%&quot;&gt;</p><h3 id="使用selenium"><a class="anchor" href="#使用selenium">#</a> 使用 Selenium</h3><p>我们可以先通过 <code>pip</code>  来安装 Selenium，命令如下所示。</p><pre><code class="language-Shell">pip install selenium</code></pre><h4 id="加载页面"><a class="anchor" href="#加载页面">#</a> 加载页面</h4><p>接下来，我们通过下面的代码驱动 Chrome 浏览器打开百度。</p><pre><code class="language-Python">from selenium import webdriver# 创建Chrome浏览器对象browser = webdriver.Chrome()# 加载指定的页面browser.get('https://www.baidu.com/')</code></pre><p>如果不愿意使用 Chrome 浏览器，也可以修改上面的代码操控其他浏览器，只需创建对应的浏览器对象（如 Firefox、Safari 等）即可。运行上面的程序，如果看到如下所示的错误提示，那是说明我们还没有将 Chrome 浏览器的驱动添加到 PATH 环境变量中，也没有在程序中指定 Chrome 浏览器驱动所在的位置。</p><pre><code class="language-Shell">selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home</code></pre><p>解决这个问题的办法有三种：</p><ol><li><p>将下载的 ChromeDriver 放到已有的 PATH 环境变量下，建议直接跟 Python 解释器放在同一个目录，因为之前安装 Python 的时候我们已经将 Python 解释器的路径放到 PATH 环境变量中了。</p></li><li><p>将 ChromeDriver 放到项目虚拟环境下的  <code>bin</code>  文件夹中（Windows 系统对应的目录是  <code>Scripts</code> ），这样 ChromeDriver 就跟虚拟环境下的 Python 解释器在同一个位置，肯定是能够找到的。</p></li><li><p>修改上面的代码，在创建 Chrome 对象时，通过 <code>service</code>  参数配置 <code>Service</code>  对象，并通过创建 <code>Service</code>  对象的 <code>executable_path</code>  参数指定 ChromeDriver 所在的位置，如下所示：</p><pre><code class="language-Python">from selenium import webdriverfrom selenium.webdriver.chrome.service import Servicebrowser = webdriver.Chrome(service=Service(executable_path='venv/bin/chromedriver'))browser.get('https://www.baidu.com/')</code></pre></li></ol><h4 id="查找元素和模拟用户行为"><a class="anchor" href="#查找元素和模拟用户行为">#</a> 查找元素和模拟用户行为</h4><p>接下来，我们可以尝试模拟用户在百度首页的文本框输入搜索关键字并点击 “百度一下” 按钮。在完成页面加载后，可以通过 <code>Chrome</code>  对象的 <code>find_element</code>  和 <code>find_elements</code>  方法来获取页面元素，Selenium 支持多种获取元素的方式，包括：CSS 选择器、XPath、元素名字（标签名）、元素 ID、类名等，前者可以获取单个页面元素（ <code>WebElement</code>  对象），后者可以获取多个页面元素构成的列表。获取到 <code>WebElement</code>  对象以后，可以通过 <code>send_keys</code>  来模拟用户输入行为，可以通过 <code>click</code>  来模拟用户点击操作，代码如下所示。</p><pre><code class="language-Python">from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')# 通过元素ID获取元素kw_input = browser.find_element(By.ID, 'kw')# 模拟用户输入行为kw_input.send_keys('Python')# 通过CSS选择器获取元素su_button = browser.find_element(By.CSS_SELECTOR, '#su')# 模拟用户点击行为su_button.click()</code></pre><p>如果要执行一个系列动作，例如模拟拖拽操作，可以创建 <code>ActionChains</code>  对象，有兴趣的读者可以自行研究。</p><h4 id="隐式等待和显式等待"><a class="anchor" href="#隐式等待和显式等待">#</a> 隐式等待和显式等待</h4><p>这里还有一个细节需要大家知道，网页上的元素可能是动态生成的，在我们使用 <code>find_element</code>  或 <code>find_elements</code>  方法获取的时候，可能还没有完成渲染，这时会引发 <code>NoSuchElementException</code>  错误。为了解决这个问题，我们可以使用隐式等待的方式，通过设置等待时间让浏览器完成对页面元素的渲染。除此之外，我们还可以使用显示等待，通过创建 <code>WebDriverWait</code>  对象，并设置等待时间和条件，当条件没有满足时，我们可以先等待再尝试进行后续的操作，具体的代码如下所示。</p><pre><code class="language-Python">from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.support.wait import WebDriverWaitbrowser = webdriver.Chrome()# 设置浏览器窗口大小browser.set_window_size(1200, 800)browser.get('https://www.baidu.com/')# 设置隐式等待时间为10秒browser.implicitly_wait(10)kw_input = browser.find_element(By.ID, 'kw')kw_input.send_keys('Python')su_button = browser.find_element(By.CSS_SELECTOR, '#su')su_button.click()# 创建显示等待对象wait_obj = WebDriverWait(browser, 10)# 设置等待条件（等搜索结果的div出现）wait_obj.until(    expected_conditions.presence_of_element_located(        (By.CSS_SELECTOR, '#content_left')    ))# 截屏browser.get_screenshot_as_file('python_result.png')</code></pre><p>上面设置的等待条件 <code>presence_of_element_located</code>  表示等待指定元素出现，下面的表格列出了常用的等待条件及其含义。</p><table><thead><tr><th>等待条件</th><th>具体含义</th></tr></thead><tbody><tr><td><code>title_is / title_contains</code></td><td>标题是指定的内容 / 标题包含指定的内容</td></tr><tr><td><code>visibility_of</code></td><td>元素可见</td></tr><tr><td><code>presence_of_element_located</code></td><td>定位的元素加载完成</td></tr><tr><td><code>visibility_of_element_located</code></td><td>定位的元素变得可见</td></tr><tr><td><code>invisibility_of_element_located</code></td><td>定位的元素变得不可见</td></tr><tr><td><code>presence_of_all_elements_located</code></td><td>定位的所有元素加载完成</td></tr><tr><td><code>text_to_be_present_in_element</code></td><td>元素包含指定的内容</td></tr><tr><td><code>text_to_be_present_in_element_value</code></td><td>元素的 <code>value</code>  属性包含指定的内容</td></tr><tr><td><code>frame_to_be_available_and_switch_to_it</code></td><td>载入并切换到指定的内部窗口</td></tr><tr><td><code>element_to_be_clickable</code></td><td>元素可点击</td></tr><tr><td><code>element_to_be_selected</code></td><td>元素被选中</td></tr><tr><td><code>element_located_to_be_selected</code></td><td>定位的元素被选中</td></tr><tr><td><code>alert_is_present</code></td><td>出现 Alert 弹窗</td></tr></tbody></table><h4 id="执行javascript代码"><a class="anchor" href="#执行javascript代码">#</a> 执行 JavaScript 代码</h4><p>对于使用瀑布式加载的页面，如果希望在浏览器窗口中加载更多的内容，可以通过浏览器对象的 <code>execute_scripts</code>  方法执行 JavaScript 代码来实现。对于一些高级的爬取操作，也很有可能会用到类似的操作，如果你的爬虫代码需要 JavaScript 的支持，建议先对 JavaScript 进行适当的了解，尤其是 JavaScript 中的 BOM 和 DOM 操作。我们在上面的代码中截屏之前加入下面的代码，这样就可以利用 JavaScript 将网页滚到最下方。</p><pre><code class="language-Python"># 执行JavaScript代码browser.execute_script('document.documentElement.scrollTop = document.documentElement.scrollHeight')</code></pre><h4 id="selenium反爬的破解"><a class="anchor" href="#selenium反爬的破解">#</a> Selenium 反爬的破解</h4><p>有一些网站专门针对 Selenium 设置了反爬措施，因为使用 Selenium 驱动的浏览器，在控制台中可以看到如下所示的 <code>webdriver</code>  属性值为 <code>true</code> ，如果要绕过这项检查，可以在加载页面之前，先通过执行 JavaScript 代码将其修改为 <code>undefined</code> 。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMjAzMTAxNTQyNDYucG5n">https://gitee.com/jackfrued/mypic/raw/master/20220310154246.png</span>&quot; style=&quot;zoom:50%&quot;&gt;</p><p>另一方面，我们还可以将浏览器窗口上的 “Chrome 正受到自动测试软件的控制” 隐藏掉，完整的代码如下所示。</p><pre><code class="language-Python"># 创建Chrome参数对象options = webdriver.ChromeOptions()# 添加试验性参数options.add_experimental_option('excludeSwitches', ['enable-automation'])options.add_experimental_option('useAutomationExtension', False)# 创建Chrome浏览器对象并传入参数browser = webdriver.Chrome(options=options)# 执行Chrome开发者协议命令（在加载页面时执行指定的JavaScript代码）browser.execute_cdp_cmd(    'Page.addScriptToEvaluateOnNewDocument',    &#123;'source': 'Object.defineProperty(navigator, &quot;webdriver&quot;, &#123;get: () =&gt; undefined&#125;)'&#125;)browser.set_window_size(1200, 800)browser.get('https://www.baidu.com/')</code></pre><h4 id="无头浏览器"><a class="anchor" href="#无头浏览器">#</a> 无头浏览器</h4><p>很多时候，我们在爬取数据时并不需要看到浏览器窗口，只要有 Chrome 浏览器以及对应的驱动程序，我们的爬虫就能够运转起来。如果不想看到浏览器窗口，我们可以通过下面的方式设置使用无头浏览器。</p><pre><code class="language-Python">options = webdriver.ChromeOptions()options.add_argument('--headless')browser = webdriver.Chrome(options=options)</code></pre><h3 id="api参考"><a class="anchor" href="#api参考">#</a> API 参考</h3><p>Selenium 相关的知识还有很多，我们在此就不一一赘述了，下面为大家罗列一些浏览器对象和 <code>WebElement</code>  对象常用的属性和方法。具体的内容大家还可以参考 Selenium <span class="exturl" data-url="aHR0cHM6Ly9zZWxlbml1bS1weXRob24temgucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L2luZGV4Lmh0bWw=">官方文档的中文翻译</span>。</p><h4 id="浏览器对象"><a class="anchor" href="#浏览器对象">#</a> 浏览器对象</h4><p>表 1. 常用属性</p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>current_url</code></td><td>当前页面的 URL</td></tr><tr><td><code>current_window_handle</code></td><td>当前窗口的句柄（引用）</td></tr><tr><td><code>name</code></td><td>浏览器的名称</td></tr><tr><td><code>orientation</code></td><td>当前设备的方向（横屏、竖屏）</td></tr><tr><td><code>page_source</code></td><td>当前页面的源代码（包括动态内容）</td></tr><tr><td><code>title</code></td><td>当前页面的标题</td></tr><tr><td><code>window_handles</code></td><td>浏览器打开的所有窗口的句柄</td></tr></tbody></table><p>表 2. 常用方法</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>back</code>  /  <code>forward</code></td><td>在浏览历史记录中后退 / 前进</td></tr><tr><td><code>close</code>  /  <code>quit</code></td><td>关闭当前浏览器窗口 / 退出浏览器实例</td></tr><tr><td><code>get</code></td><td>加载指定 URL 的页面到浏览器中</td></tr><tr><td><code>maximize_window</code></td><td>将浏览器窗口最大化</td></tr><tr><td><code>refresh</code></td><td>刷新当前页面</td></tr><tr><td><code>set_page_load_timeout</code></td><td>设置页面加载超时时间</td></tr><tr><td><code>set_script_timeout</code></td><td>设置 JavaScript 执行超时时间</td></tr><tr><td><code>implicit_wait</code></td><td>设置等待元素被找到或目标指令完成</td></tr><tr><td><code>get_cookie</code>  /  <code>get_cookies</code></td><td>获取指定的 Cookie / 获取所有 Cookie</td></tr><tr><td><code>add_cookie</code></td><td>添加 Cookie 信息</td></tr><tr><td><code>delete_cookie</code>  /  <code>delete_all_cookies</code></td><td>删除指定的 Cookie / 删除所有 Cookie</td></tr><tr><td><code>find_element</code>  /  <code>find_elements</code></td><td>查找单个元素 / 查找一系列元素</td></tr></tbody></table><h4 id="webelement对象"><a class="anchor" href="#webelement对象">#</a> WebElement 对象</h4><p>表 1. WebElement 常用属性</p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>location</code></td><td>元素的位置</td></tr><tr><td><code>size</code></td><td>元素的尺寸</td></tr><tr><td><code>text</code></td><td>元素的文本内容</td></tr><tr><td><code>id</code></td><td>元素的 ID</td></tr><tr><td><code>tag_name</code></td><td>元素的标签名</td></tr></tbody></table><p>表 2. 常用方法</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>clear</code></td><td>清空文本框或文本域中的内容</td></tr><tr><td><code>click</code></td><td>点击元素</td></tr><tr><td><code>get_attribute</code></td><td>获取元素的属性值</td></tr><tr><td><code>is_displayed</code></td><td>判断元素对于用户是否可见</td></tr><tr><td><code>is_enabled</code></td><td>判断元素是否处于可用状态</td></tr><tr><td><code>is_selected</code></td><td>判断元素（单选框和复选框）是否被选中</td></tr><tr><td><code>send_keys</code></td><td>模拟输入文本</td></tr><tr><td><code>submit</code></td><td>提交表单</td></tr><tr><td><code>value_of_css_property</code></td><td>获取指定的 CSS 属性值</td></tr><tr><td><code>find_element</code>  /  <code>find_elements</code></td><td>获取单个子元素 / 获取一系列子元素</td></tr><tr><td><code>screenshot</code></td><td>为元素生成快照</td></tr></tbody></table><h3 id="简单案例"><a class="anchor" href="#简单案例">#</a> 简单案例</h3><p>下面的例子演示了如何使用 Selenium 从 “360 图片” 网站搜索和下载图片。</p><pre><code class="language-Python">import osimport timefrom concurrent.futures import ThreadPoolExecutorimport requestsfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import KeysDOWNLOAD_PATH = 'images/'def download_picture(picture_url: str):    &quot;&quot;&quot;    下载保存图片    :param picture_url: 图片的URL    &quot;&quot;&quot;    filename = picture_url[picture_url.rfind('/') + 1:]    resp = requests.get(picture_url)    with open(os.path.join(DOWNLOAD_PATH, filename), 'wb') as file:        file.write(resp.content)if not os.path.exists(DOWNLOAD_PATH):    os.makedirs(DOWNLOAD_PATH)browser = webdriver.Chrome()browser.get('https://image.so.com/z?ch=beauty')browser.implicitly_wait(10)kw_input = browser.find_element(By.CSS_SELECTOR, 'input[name=q]')kw_input.send_keys('苍老师')kw_input.send_keys(Keys.ENTER)for _ in range(10):    browser.execute_script(        'document.documentElement.scrollTop = document.documentElement.scrollHeight'    )    time.sleep(1)imgs = browser.find_elements(By.CSS_SELECTOR, 'div.waterfall img')with ThreadPoolExecutor(max_workers=32) as pool:    for img in imgs:        pic_url = img.get_attribute('src')        pool.submit(download_picture, pic_url)</code></pre><p>运行上面的代码，检查指定的目录下是否下载了根据关键词搜索到的图片。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的并发编程-3</title>
      <link href="/computer-science/python/basic/63.Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-3/"/>
      <url>/computer-science/python/basic/63.Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-3/</url>
      
        <content type="html"><![CDATA[<h2 id="python中的并发编程-3"><a class="anchor" href="#python中的并发编程-3">#</a> Python 中的并发编程 - 3</h2><p>爬虫是典型的 I/O 密集型任务，I/O 密集型任务的特点就是程序会经常性的因为 I/O 操作而进入阻塞状态，比如我们之前使用 <code>requests</code>  获取页面代码或二进制内容，发出一个请求之后，程序必须要等待网站返回响应之后才能继续运行，如果目标网站不是很给力或者网络状况不是很理想，那么等待响应的时间可能会很久，而在这个过程中整个程序是一直阻塞在那里，没有做任何的事情。通过前面的课程，我们已经知道了可以通过多线程的方式为爬虫提速，使用多线程的本质就是，当一个线程阻塞的时候，程序还有其他的线程可以继续运转，因此整个程序就不会在阻塞和等待中浪费了大量的时间。</p><p>事实上，还有一种非常适合 I/O 密集型任务的并发编程方式，我们称之为异步编程，你也可以将它称为异步 I/O。这种方式并不需要启动多个线程或多个进程来实现并发，它是通过多个子程序相互协作的方式来提升 CPU 的利用率，解决了 I/O 密集型任务 CPU  利用率很低的问题，我一般将这种方式称为 “协作式并发”。这里，我不打算探讨操作系统的各种 I/O 模式，因为这对很多读者来说都太过抽象；但是我们得先抛出两组概念给大家，一组叫做 “阻塞” 和 “非阻塞”，一组叫做 “同步” 和 “异步”。</p><h3 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h3><h4 id="阻塞"><a class="anchor" href="#阻塞">#</a> 阻塞</h4><p>阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续处理其他的事情，则称该程序在该操作上是阻塞的。阻塞随时都可能发生，最典型的就是 I/O 中断（包括网络 I/O 、磁盘 I/O 、用户输入等）、休眠操作、等待某个线程执行结束，甚至包括在 CPU 切换上下文时，程序都无法真正的执行，这就是所谓的阻塞。</p><h4 id="非阻塞"><a class="anchor" href="#非阻塞">#</a> 非阻塞</h4><p>程序在等待某操作过程中，自身不被阻塞，可以继续处理其他的事情，则称该程序在该操作上是非阻塞的。非阻塞并不是在任何程序级别、任何情况下都可以存在的。仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。显然，某个操作的阻塞可能会导程序耗时以及效率低下，所以我们会希望把它变成非阻塞的。</p><h4 id="同步"><a class="anchor" href="#同步">#</a> 同步</h4><p>不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，我们称这些程序单元是同步执行的。例如前面讲过的给银行账户存钱的操作，我们在代码中使用了 “锁” 作为通信信号，让多个存钱操作强制排队顺序执行，这就是所谓的同步。</p><h4 id="异步"><a class="anchor" href="#异步">#</a> 异步</h4><p>不同程序单元在执行过程中无需通信协调，也能够完成一个任务，这种方式我们就称之为异步。例如，使用爬虫下载页面时，调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是不相关的，也无需相互通知协调。很显然，异步操作的完成时刻和先后顺序并不能确定。</p><p>很多人都不太能准确的把握这几个概念，这里我们简单的总结一下，同步与异步的关注点是<strong>消息通信机制</strong>，最终表现出来的是 “有序” 和 “无序” 的区别；阻塞和非阻塞的关注点是<strong>程序在等待消息时状态</strong>，最终表现出来的是程序在等待时能不能做点别的。如果想深入理解这些内容，推荐大家阅读经典著作<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMTg4MDA0Ny5odG1s">《UNIX 网络编程》</span>，这本书非常的赞。</p><h3 id="生成器和协程"><a class="anchor" href="#生成器和协程">#</a> 生成器和协程</h3><p>前面我们说过，异步编程是一种 “协作式并发”，即通过多个子程序相互协作的方式提升 CPU 的利用率，从而减少程序在阻塞和等待中浪费的时间，最终达到并发的效果。我们可以将多个相互协作的子程序称为 “协程”，它是实现异步编程的关键。在介绍协程之前，我们先通过下面的代码，看看什么是生成器。</p><pre><code class="language-Python">def fib(max_count):    a, b = 0, 1    for _ in range(max_count):        a, b = b, a + b        yield a</code></pre><p>上面我们编写了一个生成斐波那契数列的生成器，调用上面的 <code>fib</code>  函数并不是执行该函数获得返回值，因为 <code>fib</code>  函数中有一个特殊的关键字 <code>yield</code> 。这个关键字使得 <code>fib</code>  函数跟普通的函数有些区别，调用该函数会得到一个生成器对象，我们可以通过下面的代码来验证这一点。</p><pre><code class="language-Python">gen_obj = fib(20)print(gen_obj)</code></pre><p>输出：</p><pre><code>&lt;generator object fib at 0x106daee40&gt;</code></pre><p>我们可以使用内置函数 <code>next</code>  从生成器对象中获取斐波那契数列的值，也可以通过 <code>for-in</code>  循环对生成器能够提供的值进行遍历，代码如下所示。</p><pre><code class="language-Python">for value in gen_obj:    print(value)</code></pre><p>生成器经过预激活，就是一个协程，它可以跟其他子程序协作。</p><pre><code class="language-Python">def calc_average():    total, counter = 0, 0    avg_value = None    while True:        curr_value = yield avg_value        total += curr_value        counter += 1        avg_value = total / counterdef main():    obj = calc_average()    # 生成器预激活    obj.send(None)    for _ in range(5):        print(obj.send(float(input())))if __name__ == '__main__':    main()</code></pre><p>上面的 <code>main</code>  函数首先通过生成器对象的 <code>send</code>  方法发送一个 <code>None</code>  值来将其激活为协程，也可以通过 <code>next(obj)</code>  达到同样的效果。接下来，协程对象会接收 <code>main</code>  函数发送的数据并产出（ <code>yield</code> ）数据的平均值。通过上面的例子，不知道大家是否看出两段子程序是怎么 “协作” 的。</p><h3 id="异步函数"><a class="anchor" href="#异步函数">#</a> 异步函数</h3><p>Python 3.5 版本中，引入了两个非常有意思的元素，一个叫 <code>async</code> ，一个叫 <code>await</code> ，它们在 Python 3.7 版本中成为了正式的关键字。通过这两个关键字，可以简化协程代码的编写，可以用更为简单的方式让多个子程序很好的协作起来。我们通过一个例子来加以说明，请大家先看看下面的代码。</p><pre><code class="language-Python">import timedef display(num):    time.sleep(1)    print(num)def main():    start = time.time()    for i in range(1, 10):        display(i)    end = time.time()    print(f'&#123;end - start:.3f&#125;秒')if __name__ == '__main__':    main()</code></pre><p>上面的代码每次执行都会依次输出 <code>1</code>  到 <code>9</code>  的数字，每个间隔 <code>1</code>  秒钟，整个代码需要执行大概需要 <code>9</code>  秒多的时间，这一点我相信大家都能看懂。不知道大家是否意识到，这段代码就是以同步和阻塞的方式执行的，同步可以从代码的输出看出来，而阻塞是指在调用 <code>display</code>  函数发生休眠时，整个代码的其他部分都不能继续执行，必须等待休眠结束。</p><p>接下来，我们尝试用异步的方式改写上面的代码，让 <code>display</code>  函数以异步的方式运转。</p><pre><code class="language-Python">import asyncioimport timeasync def display(num):    await asyncio.sleep(1)    print(num)def main():    start = time.time()    objs = [display(i) for i in range(1, 10)]    loop = asyncio.get_event_loop()    loop.run_until_complete(asyncio.wait(objs))    loop.close()    end = time.time()    print(f'&#123;end - start:.3f&#125;秒')if __name__ == '__main__':    main()</code></pre><p>Python 中的 <code>asyncio</code>  模块提供了对异步 I/O 的支持。上面的代码中，我们首先在 <code>display</code>  函数前面加上了 <code>async</code>  关键字使其变成一个异步函数，调用异步函数不会执行函数体而是获得一个协程对象。我们将 <code>display</code>  函数中的 <code>time.sleep(1)</code>  修改为 <code>await asyncio.sleep(1)</code> ，二者的区别在于，后者不会让整个代码陷入阻塞，因为 <code>await</code>  操作会让其他协作的子程序有获得 CPU 资源而得以运转的机会。为了让这些子程序可以协作起来，我们需要将他们放到一个事件循环（实现消息分派传递的系统）上，因为<strong>当协程遭遇 I/O 操作阻塞时，就会到事件循环中监听 I/O 操作是否完成，并注册自身的上下文以及自身的唤醒函数（以便恢复执行），之后该协程就变为阻塞状态</strong>。上面的第 12 行代码创建了 <code>9</code>  个协程对象并放到一个列表中，第 13 行代码通过 <code>asyncio</code>  模块的 <code>get_event_loop</code>  函数获得了系统的事件循环，第 14 行通过 <code>asyncio</code>  模块的 <code>run_until_complete</code>  函数将协程对象挂载到事件循环上。执行上面的代码会发现， <code>9</code>  个分别会阻塞 <code>1</code>  秒钟的协程总共只阻塞了约 <code>1</code>  秒种的时间，因为<strong>阻塞的协程对象会放弃对 CPU 的占有而不是让 CPU 处于闲置状态，这种方式大大的提升了 CPU 的利用率</strong>。而且我们还会注意到，数字并不是按照从 <code>1</code>  到 <code>9</code>  的顺序打印输出的，这正是我们想要的结果，说明它们是<strong>异步执行</strong>的。对于爬虫这样的 I/O 密集型任务来说，这种协作式并发在很多场景下是比使用多线程更好的选择，因为这种做法减少了管理和维护多个线程以及多个线程切换所带来的开销。</p><h3 id="aiohttp库"><a class="anchor" href="#aiohttp库">#</a> aiohttp 库</h3><p>我们之前使用的 <code>requests</code>  三方库并不支持异步 I/O，如果希望使用异步 I/O 的方式来加速爬虫代码的执行，我们可以安装和使用名为 <code>aiohttp</code>  的三方库。</p><p>安装 <code>aiohttp</code> 。</p><pre><code class="language-Bash">pip install aiohttp</code></pre><p>下面的代码使用 <code>aiohttp</code>  抓取了 <code>10</code>  个网站的首页并解析出它们的标题。</p><pre><code class="language-Python">import asyncioimport reimport aiohttpfrom aiohttp import ClientSessionTITLE_PATTERN = re.compile(r'&lt;title.*?&gt;(.*?)&lt;/title&gt;', re.DOTALL)async def fetch_page_title(url):    async with aiohttp.ClientSession(headers=&#123;        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36',    &#125;) as session:  # type: ClientSession        async with session.get(url, ssl=False) as resp:            if resp.status == 200:                html_code = await resp.text()                matcher = TITLE_PATTERN.search(html_code)                title = matcher.group(1).strip()                print(title)def main():    urls = [        'https://www.python.org/',        'https://www.jd.com/',        'https://www.baidu.com/',        'https://www.taobao.com/',        'https://git-scm.com/',        'https://www.sohu.com/',        'https://gitee.com/',        'https://www.amazon.com/',        'https://www.usa.gov/',        'https://www.nasa.gov/'    ]    objs = [fetch_page_title(url) for url in urls]    loop = asyncio.get_event_loop()    loop.run_until_complete(asyncio.wait(objs))    loop.close()if __name__ == '__main__':    main()</code></pre><p>输出：</p><pre><code>京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！搜狐淘宝网 - 淘！我喜欢百度一下，你就知道Gitee - 基于 Git 的代码托管和研发协作平台GitNASAOfficial Guide to Government Information and Services   &amp;#124; USAGovAmazon.com. Spend less. Smile more.Welcome to Python.org</code></pre><p>从上面的输出可以看出，网站首页标题的输出顺序跟它们的 URL 在列表中的顺序没有关系。代码的第 11 行到第 13 行创建了 <code>ClientSession</code>  对象，通过它的 <code>get</code>  方法可以向指定的 URL 发起请求，如第 14 行所示，跟 <code>requests</code>  中的 <code>Session</code>  对象并没有本质区别，唯一的区别是这里使用了异步上下文。代码第 16 行的 <code>await</code>  会让因为 I/O 操作阻塞的子程序放弃对 CPU 的占用，这使得其他的子程序可以运转起来去抓取页面。代码的第 17 行和第 18 行使用了正则表达式捕获组操作解析网页标题。 <code>fetch_page_title</code>  是一个被 <code>async</code>  关键字修饰的异步函数，调用该函数会获得协程对象，如代码第 35 行所示。后面的代码跟之前的例子没有什么区别，相信大家能够理解。</p><p>大家可以尝试将 <code>aiohttp</code>  换回到 <code>requests</code> ，看看不使用异步 I/O 也不使用多线程，到底和上面的代码有什么区别，相信通过这样的对比，大家能够更深刻的理解我们之前强调的几个概念：同步和异步，阻塞和非阻塞。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的并发编程-2</title>
      <link href="/computer-science/python/basic/63.Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-2/"/>
      <url>/computer-science/python/basic/63.Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-2/</url>
      
        <content type="html"><![CDATA[<h2 id="python中的并发编程-2"><a class="anchor" href="#python中的并发编程-2">#</a> Python 中的并发编程 - 2</h2><p>在上一课中我们说过，由于 GIL 的存在，CPython 中的多线程并不能发挥 CPU 的多核优势，如果希望突破 GIL 的限制，可以考虑使用多进程。对于多进程的程序，每个进程都有一个属于自己的 GIL，所以多进程不会受到 GIL 的影响。那么，我们应该如何在 Python 程序中创建和使用多进程呢？</p><p>### 创建进程</p><p>在 Python 中可以基于 <code>Process</code>  类来创建进程，虽然进程和线程有着本质的差别，但是 <code>Process</code>  类和 <code>Thread</code>  类的用法却非常类似。在使用 <code>Process</code>  类的构造器创建对象时，也是通过 <code>target</code>  参数传入一个函数来指定进程要执行的代码，而 <code>args</code>  和 <code>kwargs</code>  参数可以指定该函数使用的参数值。</p><pre><code class="language-Python">from multiprocessing import Process, current_processfrom time import sleepdef sub_task(content, nums):    # 通过current_process函数获取当前进程对象    # 通过进程对象的pid和name属性获取进程的ID号和名字    print(f'PID: &#123;current_process().pid&#125;')    print(f'Name: &#123;current_process().name&#125;')    # 通过下面的输出不难发现，每个进程都有自己的nums列表，进程之间本就不共享内存    # 在创建子进程时复制了父进程的数据结构，三个进程从列表中pop(0)得到的值都是20    counter, total = 0, nums.pop(0)    print(f'Loop count: &#123;total&#125;')    sleep(0.5)    while counter &lt; total:        counter += 1        print(f'&#123;counter&#125;: &#123;content&#125;')        sleep(0.01)def main():    nums = [20, 30, 40]    # 创建并启动进程来执行指定的函数    Process(target=sub_task, args=('Ping', nums)).start()    Process(target=sub_task, args=('Pong', nums)).start()    # 在主进程中执行sub_task函数    sub_task('Good', nums)if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码通过 <code>current_process</code>  函数获取当前进程对象，再通过进程对象的 <code>pid</code>  属性获取进程 ID。在 Python 中，使用 <code>os</code>  模块的 <code>getpid</code>  函数也可以达到同样的效果。</p></blockquote><p>如果愿意，也可以使用 <code>os</code>  模块的 <code>fork</code>  函数来创建进程，调用该函数时，操作系统自动把当前进程（父进程）复制一份（子进程），父进程的 <code>fork</code>  函数会返回子进程的 ID，而子进程中的 <code>fork</code>  函数会返回 <code>0</code> ，也就是说这个函数调用一次会在父进程和子进程中得到两个不同的返回值。需要注意的是，Windows 系统并不支持 <code>fork</code>  函数，如果你使用的是 Linux 或 macOS 系统，可以试试下面的代码。</p><pre><code class="language-Python">import osprint(f'PID: &#123;os.getpid()&#125;')pid = os.fork()if pid == 0:    print(f'子进程 - PID: &#123;os.getpid()&#125;')    print('Todo: 在子进程中执行的代码')else:    print(f'父进程 - PID: &#123;os.getpid()&#125;')    print('Todo: 在父进程中执行的代码')</code></pre><p>简而言之，我们还是推荐大家通过直接使用 <code>Process</code>  类、继承 <code>Process</code>  类和使用进程池（ <code>ProcessPoolExecutor</code> ）这三种方式来创建和使用多进程，这三种方式不同于上面的 <code>fork</code>  函数，能够保证代码的兼容性和可移植性。具体的做法跟之前讲过的创建和使用多线程的方式比较接近，此处不再进行赘述。</p><h3 id="多进程和多线程的比较"><a class="anchor" href="#多进程和多线程的比较">#</a> 多进程和多线程的比较</h3><p>对于爬虫这类 I/O 密集型任务来说，使用多进程并没有什么优势；但是对于计算密集型任务来说，多进程相比多线程，在效率上会有显著的提升，我们可以通过下面的代码来加以证明。下面的代码会通过多线程和多进程两种方式来判断一组大整数是不是质数，很显然这是一个计算密集型任务，我们将任务分别放到多个线程和多个进程中来加速代码的执行，让我们看看多线程和多进程的代码具体表现有何不同。</p><p>我们先实现一个多线程的版本，代码如下所示。</p><pre><code class="language-Python">import concurrent.futuresPRIMES = [    1116281,    1297337,    104395303,    472882027,    533000389,    817504243,    982451653,    112272535095293,    112582705942171,    112272535095293,    115280095190773,    115797848077099,    1099726899285419] * 5def is_prime(n):    &quot;&quot;&quot;判断素数&quot;&quot;&quot;    for i in range(2, int(n ** 0.5) + 1):        if n % i == 0:            return False    return n != 1def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    with concurrent.futures.ThreadPoolExecutor(max_workers=16) as executor:        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):            print('%d is prime: %s' % (number, prime))if __name__ == '__main__':    main()</code></pre><p>假设上面的代码保存在名为 <code>example.py</code>  的文件中，在 Linux 或 macOS 系统上，可以使用 <code>time python example.py</code>  命令执行程序并获得操作系统关于执行时间的统计，在我的 macOS 上，某次的运行结果的最后一行输出如下所示。</p><pre><code>python example09.py  38.69s user 1.01s system 101% cpu 39.213 total</code></pre><p>从运行结果可以看出，多线程的代码只能让 CPU 利用率达到 100%，这其实已经证明了多线程的代码无法利用 CPU 多核特性来加速代码的执行，我们再看看多进程的版本，我们将上面代码中的线程池（ <code>ThreadPoolExecutor</code> ）更换为进程池（ <code>ProcessPoolExecutor</code> ）。</p><p>多进程的版本。</p><pre><code class="language-Python">import concurrent.futuresPRIMES = [    1116281,    1297337,    104395303,    472882027,    533000389,    817504243,    982451653,    112272535095293,    112582705942171,    112272535095293,    115280095190773,    115797848077099,    1099726899285419] * 5def is_prime(n):    &quot;&quot;&quot;判断素数&quot;&quot;&quot;    for i in range(2, int(n ** 0.5) + 1):        if n % i == 0:            return False    return n != 1def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    with concurrent.futures.ProcessPoolExecutor(max_workers=16) as executor:        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):            print('%d is prime: %s' % (number, prime))if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>提示</strong>：运行上面的代码时，可以通过操作系统的任务管理器（资源监视器）来查看是否启动了多个 Python  解释器进程。</p></blockquote><p>我们仍然通过 <code>time python example.py</code>  的方式来执行上述代码，运行结果的最后一行如下所示。</p><pre><code>python example09.py 106.63s user 0.57s system 389% cpu 27.497 total</code></pre><p>可以看出，多进程的版本在我使用的这台电脑上，让 CPU 的利用率达到了将近 400%，而运行代码时用户态耗费的 CPU 的时间（106.63 秒）几乎是代码运行总时间（27.497 秒）的 4 倍，从这两点都可以看出，我的电脑使用了一款 4 核的 CPU。当然，要知道自己的电脑有几个 CPU 或几个核，可以直接使用下面的代码。</p><pre><code class="language-Python">import osprint(os.cpu_count())</code></pre><p>综上所述，多进程可以突破 GIL 的限制，充分利用 CPU 多核特性，对于计算密集型任务，这一点是相当重要的。常见的计算密集型任务包括科学计算、图像处理、音视频编解码等，如果这些计算密集型任务本身是可以并行的，那么使用多进程应该是更好的选择。</p><h3 id="进程间通信"><a class="anchor" href="#进程间通信">#</a> 进程间通信</h3><p>在讲解进程间通信之前，先给大家一个任务：启动两个进程，一个输出 “Ping”，一个输出 “Pong”，两个进程输出的 “Ping” 和 “Pong” 加起来一共有 50 个时，就结束程序。听起来是不是非常简单，但是实际编写代码时，由于多个进程之间不能够像多个线程之间直接通过共享内存的方式交换数据，所以下面的代码是达不到我们想要的结果的。</p><pre><code class="language-Python">from multiprocessing import Processfrom time import sleepcounter = 0def sub_task(string):    global counter    while counter &lt; 50:        print(string, end='', flush=True)        counter += 1        sleep(0.01)        def main():    Process(target=sub_task, args=('Ping', )).start()    Process(target=sub_task, args=('Pong', )).start()if __name__ == '__main__':    main()</code></pre><p>上面的代码看起来没毛病，但是最后的结果是 “Ping” 和 “Pong” 各输出了 50 个。再次提醒大家，当我们在程序中创建进程的时候，子进程会复制父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个 <code>counter</code>  变量，它们都会从 <code>0</code>  加到 <code>50</code> ，所以结果就可想而知了。要解决这个问题比较简单的办法是使用 <code>multiprocessing</code>  模块中的 <code>Queue</code>  类，它是可以被多个进程共享的队列，底层是通过操作系统底层的管道和信号量（semaphore）机制来实现的，代码如下所示。</p><pre><code class="language-Python">import timefrom multiprocessing import Process, Queuedef sub_task(content, queue):    counter = queue.get()    while counter &lt; 50:        print(content, end='', flush=True)        counter += 1        queue.put(counter)        time.sleep(0.01)        counter = queue.get()def main():    queue = Queue()    queue.put(0)    p1 = Process(target=sub_task, args=('Ping', queue))    p1.start()    p2 = Process(target=sub_task, args=('Pong', queue))    p2.start()    while p1.is_alive() and p2.is_alive():        pass    queue.put(50)if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>提示</strong>： <code>multiprocessing.Queue</code>  对象的 <code>get</code>  方法默认在队列为空时是会阻塞的，直到获取到数据才会返回。如果不希望该方法阻塞以及需要指定阻塞的超时时间，可以通过指定 <code>block</code>  和 <code>timeout</code>  参数进行设定。</p></blockquote><p>上面的代码通过 <code>Queue</code>  类的 <code>get</code>  和 <code>put</code>  方法让三个进程（ <code>p1</code> 、 <code>p2</code>  和主进程）实现了数据的共享，这就是所谓的进程间的通信，通过这种方式，当 <code>Queue</code>  中取出的值已经大于等于 <code>50</code>  时， <code>p1</code>  和 <code>p2</code>  就会跳出 <code>while</code>  循环，从而终止进程的执行。代码第 22 行的循环是为了等待 <code>p1</code>  和 <code>p2</code>  两个进程中的一个结束，这时候主进程还需要向 <code>Queue</code>  中放置一个大于等于 <code>50</code>  的值，这样另一个尚未结束的进程也会因为读到这个大于等于 <code>50</code>  的值而终止。</p><p>进程间通信的方式还有很多，比如使用套接字也可以实现两个进程的通信，甚至于这两个进程并不在同一台主机上，有兴趣的读者可以自行了解。</p><h3 id="简单的总结"><a class="anchor" href="#简单的总结">#</a> 简单的总结</h3><p>在 Python 中，我们还可以通过 <code>subprocess</code>  模块的 <code>call</code>  函数执行其他的命令来创建子进程，相当于就是在我们的程序中调用其他程序，这里我们暂不探讨这些知识，有兴趣的读者可以自行研究。</p><p>对于 Python 开发者来说，以下情况需要考虑使用多线程：</p><ol><li>程序需要维护许多共享的状态（尤其是可变状态），Python 中的列表、字典、集合都是线程安全的（多个线程同时操作同一个列表、字典或集合，不会引发错误和数据问题），所以使用线程而不是进程维护共享状态的代价相对较小。</li><li>程序会花费大量时间在 I/O 操作上，没有太多并行计算的需求且不需占用太多的内存。</li></ol><p>那么在遇到下列情况时，应该考虑使用多进程：</p><ol><li>程序执行计算密集型任务（如：音视频编解码、数据压缩、科学计算等）。</li><li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li><li>程序在内存使用方面没有任何限制且不强依赖于 I/O 操作（如读写文件、套接字等）。</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的并发编程-1</title>
      <link href="/computer-science/python/basic/63.Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-1/"/>
      <url>/computer-science/python/basic/63.Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-1/</url>
      
        <content type="html"><![CDATA[<h2 id="python中的并发编程-1"><a class="anchor" href="#python中的并发编程-1">#</a> Python 中的并发编程 - 1</h2><p>现如今，我们使用的计算机早已是多 CPU 或多核的计算机，而我们使用的操作系统基本都支持 “多任务”，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务 “并行” 或 “并发” 的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此当下，不管用什么编程语言进行开发，实现 “并行” 或 “并发” 编程已经成为了程序员的标配技能。为了讲述如何在 Python 程序中实现 “并行” 或 “并发”，我们需要先了解两个重要的概念：进程和线程。</p><h3 id="线程和进程"><a class="anchor" href="#线程和进程">#</a> 线程和进程</h3><p>我们通过操作系统运行一个程序会创建出一个或多个进程，进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。简单的说，进程是操作系统分配存储空间的基本单位，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据；操作系统管理所有进程的执行，为它们合理的分配资源。一个进程可以通过 fork 或 spawn 的方式创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此两个进程如果要共享数据，必须通过进程间通信机制来实现，具体的方式包括管道、信号、套接字等。</p><p>一个进程还可以拥有多个执行线索，简单的说就是拥有多个可以获得 CPU 调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核 CPU 系统中，多个线程不可能同时执行，因为在某个时刻只有一个线程能够获得 CPU，多个线程通过共享 CPU 执行时间的方式来达到并发的效果。</p><p>在程序中使用多线程技术通常都会带来不言而喻的好处，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如 macOS 中的 “活动监视器”、Windows 中的 “任务管理器”）来证实，如下图所示。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTA4MjIwOTQyNDMucG5n">https://gitee.com/jackfrued/mypic/raw/master/20210822094243.png</span>&quot; width=&quot;80%&quot;&gt;</p><p>这里，我们还需要跟大家再次强调两个概念：<strong>并发</strong>（concurrency）和<strong>并行</strong>（parallel）。<strong>并发</strong>通常是指同一时刻只能有一条指令执行，但是多个线程对应的指令被快速轮换地执行。比如一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。由于处理器执行指令的速度和切换的速度极快，人们完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行，但微观上其实只有一个线程在执行。<strong>并行</strong>是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器，不论是从宏观上还是微观上，多个线程可以在同一时刻一起执行的。很多时候，我们并不用严格区分并发和并行两个词，所以我们有时候也把 Python 中的多线程、多进程以及异步 I/O 都视为实现并发编程的手段，但实际上前面两者也可以实现并行编程，当然这里还有一个全局解释器锁（GIL）的问题，我们稍后讨论。</p><h3 id="多线程编程"><a class="anchor" href="#多线程编程">#</a> 多线程编程</h3><p>Python 标准库中 <code>threading</code>  模块的 <code>Thread</code>  类可以帮助我们非常轻松的实现多线程编程。我们用一个联网下载文件的例子来对比使用多线程和不使用多线程到底有什么区别，代码如下所示。</p><p>不使用多线程的下载。</p><pre><code class="language-Python">import randomimport timedef download(*, filename):    start = time.time()    print(f'开始下载 &#123;filename&#125;.')    time.sleep(random.randint(3, 6))    print(f'&#123;filename&#125; 下载完成.')    end = time.time()    print(f'下载耗时: &#123;end - start:.3f&#125;秒.')def main():    start = time.time()    download(filename='Python从入门到住院.pdf')    download(filename='MySQL从删库到跑路.avi')    download(filename='Linux从精通到放弃.mp4')    end = time.time()    print(f'总耗时: &#123;end - start:.3f&#125;秒.')if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码并没有真正实现联网下载的功能，而是通过 <code>time.sleep()</code>  休眠一段时间来模拟下载文件需要一些时间上的开销，跟实际下载的状况比较类似。</p></blockquote><p>运行上面的代码，可以得到如下所示的运行结果。可以看出，当我们的程序只有一个工作线程时，每个下载任务都需要等待上一个下载任务执行结束才能开始，所以程序执行的总耗时是三个下载任务各自执行时间的总和。</p><pre><code>开始下载Python从入门到住院.pdf.Python从入门到住院.pdf下载完成.下载耗时: 3.005秒.开始下载MySQL从删库到跑路.avi.MySQL从删库到跑路.avi下载完成.下载耗时: 5.006秒.开始下载Linux从精通到放弃.mp4.Linux从精通到放弃.mp3下载完成.下载耗时: 6.007秒.总耗时: 14.018秒.</code></pre><p>事实上，上面的三个下载任务之间并没有逻辑上的因果关系，三者是可以 “并发” 的，下一个下载任务没有必要等待上一个下载任务结束，为此，我们可以使用多线程编程来改写上面的代码。</p><pre><code class="language-Python">import randomimport timefrom threading import Threaddef download(*, filename):    start = time.time()    print(f'开始下载 &#123;filename&#125;.')    time.sleep(random.randint(3, 6))    print(f'&#123;filename&#125; 下载完成.')    end = time.time()    print(f'下载耗时: &#123;end - start:.3f&#125;秒.')def main():    threads = [        Thread(target=download, kwargs=&#123;'filename': 'Python从入门到住院.pdf'&#125;),        Thread(target=download, kwargs=&#123;'filename': 'MySQL从删库到跑路.avi'&#125;),        Thread(target=download, kwargs=&#123;'filename': 'Linux从精通到放弃.mp4'&#125;)    ]    start = time.time()    # 启动三个线程    for thread in threads:        thread.start()    # 等待线程结束    for thread in threads:        thread.join()    end = time.time()    print(f'总耗时: &#123;end - start:.3f&#125;秒.')if __name__ == '__main__':    main()</code></pre><p>某次的运行结果如下所示。</p><pre><code>开始下载 Python从入门到住院.pdf.开始下载 MySQL从删库到跑路.avi.开始下载 Linux从精通到放弃.mp4.MySQL从删库到跑路.avi 下载完成.下载耗时: 3.005秒.Python从入门到住院.pdf 下载完成.下载耗时: 5.006秒.Linux从精通到放弃.mp4 下载完成.下载耗时: 6.003秒.总耗时: 6.004秒.</code></pre><p>通过上面的运行结果可以发现，整个程序的执行时间几乎等于耗时最长的一个下载任务的执行时间，这也就意味着，三个下载任务是并发执行的，不存在一个等待另一个的情况，这样做很显然提高了程序的执行效率。简单的说，如果程序中有非常耗时的执行单元，而这些耗时的执行单元之间又没有逻辑上的因果关系，即 B 单元的执行不依赖于 A 单元的执行结果，那么 A 和 B 两个单元就可以放到两个不同的线程中，让他们并发的执行。这样做的好处除了减少程序执行的等待时间，还可以带来更好的用户体验，因为一个单元的阻塞不会造成程序的 “假死”，因为程序中还有其他的单元是可以运转的。</p><h4 id="使用-thread-类创建线程对象"><a class="anchor" href="#使用-thread-类创建线程对象">#</a> 使用 Thread 类创建线程对象</h4><p>通过上面的代码可以看出，直接使用 <code>Thread</code>  类的构造器就可以创建线程对象，而线程对象的 <code>start()</code>  方法可以启动一个线程。线程启动后会执行 <code>target</code>  参数指定的函数，当然前提是获得 CPU 的调度；如果 <code>target</code>  指定的线程要执行的目标函数有参数，需要通过 <code>args</code>  参数为其进行指定，对于关键字参数，可以通过 <code>kwargs</code>  参数进行传入。 <code>Thread</code>  类的构造器还有很多其他的参数，我们遇到的时候再为大家进行讲解，目前需要大家掌握的，就是 <code>target</code> 、 <code>args</code>  和 <code>kwargs</code> 。</p><h4 id="继承-thread-类自定义线程"><a class="anchor" href="#继承-thread-类自定义线程">#</a> 继承 Thread 类自定义线程</h4><p>除了上面的代码展示的创建线程的方式外，还可以通过继承 <code>Thread</code>  类并重写 <code>run()</code>  方法的方式来自定义线程，具体的代码如下所示。</p><pre><code class="language-Python">import randomimport timefrom threading import Threadclass DownloadThread(Thread):    def __init__(self, filename):        self.filename = filename        super().__init__()    def run(self):        start = time.time()        print(f'开始下载 &#123;self.filename&#125;.')        time.sleep(random.randint(3, 6))        print(f'&#123;self.filename&#125; 下载完成.')        end = time.time()        print(f'下载耗时: &#123;end - start:.3f&#125;秒.')def main():    threads = [        DownloadThread('Python从入门到住院.pdf'),        DownloadThread('MySQL从删库到跑路.avi'),        DownloadThread('Linux从精通到放弃.mp4')    ]    start = time.time()    # 启动三个线程    for thread in threads:        thread.start()    # 等待线程结束    for thread in threads:        thread.join()    end = time.time()    print(f'总耗时: &#123;end - start:.3f&#125;秒.')if __name__ == '__main__':    main()</code></pre><h4 id="使用线程池"><a class="anchor" href="#使用线程池">#</a> 使用线程池</h4><p>我们还可以通过线程池的方式将任务放到多个线程中去执行，通过线程池来使用线程应该是多线程编程最理想的选择。事实上，线程的创建和释放都会带来较大的开销，频繁的创建和释放线程通常都不是很好的选择。利用线程池，可以提前准备好若干个线程，在使用的过程中不需要再通过自定义的代码创建和释放线程，而是直接复用线程池中的线程。Python 内置的 <code>concurrent.futures</code>  模块提供了对线程池的支持，代码如下所示。</p><pre><code class="language-Python">import randomimport timefrom concurrent.futures import ThreadPoolExecutorfrom threading import Threaddef download(*, filename):    start = time.time()    print(f'开始下载 &#123;filename&#125;.')    time.sleep(random.randint(3, 6))    print(f'&#123;filename&#125; 下载完成.')    end = time.time()    print(f'下载耗时: &#123;end - start:.3f&#125;秒.')def main():    with ThreadPoolExecutor(max_workers=4) as pool:        filenames = ['Python从入门到住院.pdf', 'MySQL从删库到跑路.avi', 'Linux从精通到放弃.mp4']        start = time.time()        for filename in filenames:            pool.submit(download, filename=filename)    end = time.time()    print(f'总耗时: &#123;end - start:.3f&#125;秒.')if __name__ == '__main__':    main()</code></pre><h3 id="守护线程"><a class="anchor" href="#守护线程">#</a> 守护线程</h3><p>所谓 “守护线程” 就是在主线程结束的时候，不值得再保留的执行线程。这里的不值得保留指的是守护线程会在其他非守护线程全部运行结束之后被销毁，它守护的是当前进程内所有的非守护线程。简单的说，守护线程会跟随主线程一起挂掉，而主线程的生命周期就是一个进程的生命周期。如果不理解，我们可以看一段简单的代码。</p><pre><code class="language-Python">import timefrom threading import Threaddef display(content):    while True:        print(content, end='', flush=True)        time.sleep(0.1)def main():    Thread(target=display, args=('Ping', )).start()    Thread(target=display, args=('Pong', )).start()if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码中，我们将 <code>print</code>  函数的参数 <code>flush</code>  设置为 <code>True</code> ，这是因为 <code>flush</code>  参数的值如果为 <code>False</code> ，而 <code>print</code>  又没有做换行处理，就会导致每次 <code>print</code>  输出的内容被放到操作系统的输出缓冲区，直到缓冲区被输出的内容塞满，才会清空缓冲区产生一次输出。上述现象是操作系统为了减少 I/O 中断，提升 CPU 利用率做出的设定，为了让代码产生直观交互，我们才将 <code>flush</code>  参数设置为 <code>True</code> ，强制每次输出都清空输出缓冲区。</p></blockquote><p>上面的代码运行起来之后是不会停止的，因为两个子线程中都有死循环，除非你手动中断代码的执行。但是，如果在创建线程对象时，将名为 <code>daemon</code>  的参数设置为 <code>True</code> ，这两个线程就会变成守护线程，那么在其他线程结束时，即便有死循环，两个守护线程也会挂掉，不会再继续执行下去，代码如下所示。</p><pre><code class="language-Python">import timefrom threading import Threaddef display(content):    while True:        print(content, end='', flush=True)        time.sleep(0.1)def main():    Thread(target=display, args=('Ping', ), daemon=True).start()    Thread(target=display, args=('Pong', ), daemon=True).start()    time.sleep(5)if __name__ == '__main__':    main()</code></pre><p>上面的代码，我们在主线程中添加了一行 <code>time.sleep(5)</code>  让主线程休眠 5 秒，在这个过程中，输出 <code>Ping</code>  和 <code>Pong</code>  的守护线程会持续运转，直到主线程在 5 秒后结束，这两个守护线程也被销毁，不再继续运行。</p><blockquote><p><strong>思考</strong>：如果将上面代码第 12 行的 <code>daemon=True</code>  去掉，代码会怎样执行？有兴趣的读者可以尝试一下，并看看实际执行的结果跟你想象的是否一致。</p></blockquote><h3 id="资源竞争"><a class="anchor" href="#资源竞争">#</a> 资源竞争</h3><p>在编写多线程代码时，不可避免的会遇到多个线程竞争同一个资源（对象）的情况。在这种情况下，如果没有合理的机制来保护被竞争的资源，那么就有可能出现非预期的状况。下面的代码创建了 <code>100</code>  个线程向同一个银行账户（初始余额为 <code>0</code>  元）转账，每个线程转账金额为 <code>1</code>  元。在正常的情况下，我们的银行账户最终的余额应该是 <code>100</code>  元，但是运行下面的代码我们并不能得到 <code>100</code>  元这个结果。</p><pre><code class="language-Python">import timefrom concurrent.futures import ThreadPoolExecutorclass Account(object):    &quot;&quot;&quot;银行账户&quot;&quot;&quot;    def __init__(self):        self.balance = 0.0    def deposit(self, money):        &quot;&quot;&quot;存钱&quot;&quot;&quot;        new_balance = self.balance + money        time.sleep(0.01)        self.balance = new_balancedef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    account = Account()    with ThreadPoolExecutor(max_workers=16) as pool:        for _ in range(100):            pool.submit(account.deposit, 1)    print(account.balance)if __name__ == '__main__':    main()</code></pre><p>上面代码中的 <code>Account</code>  类代表了银行账户，它的 <code>deposit</code>  方法代表存款行为，参数 <code>money</code>  代表存入的金额，该方法通过 <code>time.sleep</code>  函数模拟受理存款需要一段时间。我们通过线程池的方式启动了 <code>100</code>  个线程向一个账户转账，但是上面的代码并不能运行出 <code>100</code>  这个我们期望的结果，这就是在多个线程竞争一个资源的时候，可能会遇到的数据不一致的问题。注意上面代码的第 <code>14</code>  行，当多个线程都执行到这行代码时，它们会在相同的余额上执行加上存入金额的操作，这就会造成 “丢失更新” 现象，即之前修改数据的成果被后续的修改给覆盖掉了，所以才得不到正确的结果。</p><p>要解决上面的问题，可以使用锁机制，通过锁对操作数据的关键代码加以保护。Python 标准库的 <code>threading</code>  模块提供了 <code>Lock</code>  和 <code>RLock</code>  类来支持锁机制，这里我们不去深究二者的区别，建议大家直接使用 <code>RLock</code> 。接下来，我们给银行账户添加一个锁对象，通过锁对象来解决刚才存款时发生 “丢失更新” 的问题，代码如下所示。</p><pre><code class="language-Python">import timefrom concurrent.futures import ThreadPoolExecutorfrom threading import RLockclass Account(object):    &quot;&quot;&quot;银行账户&quot;&quot;&quot;    def __init__(self):        self.balance = 0.0        self.lock = RLock()    def deposit(self, money):        # 获得锁        self.lock.acquire()        try:            new_balance = self.balance + money            time.sleep(0.01)            self.balance = new_balance        finally:            # 释放锁            self.lock.release()def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    account = Account()    with ThreadPoolExecutor(max_workers=16) as pool:        for _ in range(100):            pool.submit(account.deposit, 1)    print(account.balance)if __name__ == '__main__':    main()</code></pre><p>上面代码中，获得锁和释放锁的操作也可以通过上下文语法来实现，使用上下文语法会让代码更加简单优雅，这也是我们推荐大家使用的方式。</p><pre><code class="language-Python">import timefrom concurrent.futures import ThreadPoolExecutorfrom threading import RLockclass Account(object):    &quot;&quot;&quot;银行账户&quot;&quot;&quot;    def __init__(self):        self.balance = 0.0        self.lock = RLock()    def deposit(self, money):        # 通过上下文语法获得锁和释放锁        with self.lock:            new_balance = self.balance + money            time.sleep(0.01)            self.balance = new_balancedef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    account = Account()    with ThreadPoolExecutor(max_workers=16) as pool:        for _ in range(100):            pool.submit(account.deposit, 1)    print(account.balance)if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>思考</strong>：将上面的代码修改为 5 个线程向银行账户存钱，5 个线程从银行账户取钱，取钱的线程在银行账户余额不足时，需要停下来等待存钱的线程将钱存入后再尝试取钱。这里需要用到线程调度的知识，大家可以自行研究下 <code>threading</code>  模块中的 <code>Condition</code>  类，看看是否能够完成这个任务。</p></blockquote><h3 id="gil问题"><a class="anchor" href="#gil问题">#</a> GIL 问题</h3><p>如果使用官方的 Python 解释器（通常称之为 CPython）运行 Python 程序，我们并不能通过使用多线程的方式将 CPU 的利用率提升到逼近 400%（对于 4 核 CPU）或逼近 800%（对于 8 核 CPU）这样的水平，因为 CPython 在执行代码时，会受到 GIL（全局解释器锁）的限制。具体的说，CPython 在执行任何代码时，都需要对应的线程先获得 GIL，然后每执行 100 条（字节码）指令，CPython 就会让获得 GIL 的线程主动释放 GIL，这样别的线程才有机会执行。因为 GIL 的存在，无论你的 CPU 有多少个核，我们编写的 Python 代码也没有机会真正并行的执行。</p><p>GIL 是官方 Python 解释器在设计上的历史遗留问题，要解决这个问题，让多线程能够发挥 CPU 的多核优势，需要重新实现一个不带 GIL 的 Python 解释器。这个问题按照官方的说法，在 Python 发布 4.0 版本时会得到解决，就让我们拭目以待吧。当下，对于 CPython 而言，如果希望充分发挥 CPU 的多核优势，可以考虑使用多进程，因为每个进程都对应一个 Python 解释器，因此每个进程都有自己独立的 GIL，这样就可以突破 GIL 的限制。在下一个章节中，我们会为大家介绍关于多进程的相关知识，并对多线程和多进程的代码及其执行效果进行比较。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程在爬虫中的应用</title>
      <link href="/computer-science/python/basic/63.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9C%A8%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/computer-science/python/basic/63.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9C%A8%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="并发编程在爬虫中的应用"><a class="anchor" href="#并发编程在爬虫中的应用">#</a> 并发编程在爬虫中的应用</h2><p>之前的课程，我们已经为大家介绍了 Python 中的多线程、多进程和异步编程，通过这三种手段，我们可以实现并发或并行编程，这一方面可以加速代码的执行，另一方面也可以带来更好的用户体验。爬虫程序是典型的 I/O 密集型任务，对于 I/O 密集型任务来说，多线程和异步 I/O 都是很好的选择，因为当程序的某个部分因 I/O 操作阻塞时，程序的其他部分仍然可以运转，这样我们不用在等待和阻塞中浪费大量的时间。下面我们以爬取 “<span class="exturl" data-url="aHR0cHM6Ly9pbWFnZS5zby5jb20v">360 图片</span>” 网站的图片并保存到本地为例，为大家分别展示使用单线程、多线程和异步 I/O 编程的爬虫程序有什么区别，同时也对它们的执行效率进行简单的对比。</p><p>“360 图片” 网站的页面使用了 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvR3VpZGUvQUpBWA==">Ajax</span> 技术，这是很多网站都会使用的一种异步加载数据和局部刷新页面的技术。简单的说，页面上的图片都是通过 JavaScript 代码异步获取 JSON 数据并动态渲染生成的，而且整个页面还使用了瀑布式加载（一边向下滚动，一边加载更多的图片）。我们在浏览器的 “开发者工具” 中可以找到提供动态内容的数据接口，如下图所示，我们需要的图片信息就在服务器返回的 JSON 数据中。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTEyMDUyMjEzNTIucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211205221352.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>例如，要获取 “美女” 频道的图片，我们可以请求如下所示的 URL，其中参数 <code>ch</code>  表示请求的频道， <code>=</code>  后面的参数值 <code>beauty</code>  就代表了 “美女” 频道，参数 <code>sn</code>  相当于是页码， <code>0</code>  表示第一页（共 <code>30</code>  张图片）， <code>30</code>  表示第二页， <code>60</code>  表示第三页，以此类推。</p><pre><code>https://image.so.com/zjl?ch=beauty&amp;sn=0</code></pre><h3 id="单线程版本"><a class="anchor" href="#单线程版本">#</a> 单线程版本</h3><p>通过上面的 URL 下载 “美女” 频道共 <code>90</code>  张图片。</p><pre><code class="language-Python">&quot;&quot;&quot;example04.py - 单线程版本爬虫&quot;&quot;&quot;import osimport requestsdef download_picture(url):    filename = url[url.rfind('/') + 1:]    resp = requests.get(url)    if resp.status_code == 200:        with open(f'images/beauty/&#123;filename&#125;', 'wb') as file:            file.write(resp.content)def main():    if not os.path.exists('images/beauty'):        os.makedirs('images/beauty')    for page in range(3):        resp = requests.get(f'https://image.so.com/zjl?ch=beauty&amp;sn=&#123;page * 30&#125;')        if resp.status_code == 200:            pic_dict_list = resp.json()['list']            for pic_dict in pic_dict_list:                download_picture(pic_dict['qhimg_url'])if __name__ == '__main__':    main()</code></pre><p>在 macOS 或 Linux 系统上，我们可以使用 <code>time</code>  命令来了解上面代码的执行时间以及 CPU 的利用率，如下所示。</p><pre><code class="language-Bash">time python3 example04.py </code></pre><p>下面是单线程爬虫代码在我的电脑上执行的结果。</p><pre><code>python3 example04.py  2.36s user 0.39s system 12% cpu 21.578 total</code></pre><p>这里我们只需要关注代码的总耗时为 <code>21.578</code>  秒，CPU 利用率为 <code>12%</code> 。</p><h3 id="多线程版本"><a class="anchor" href="#多线程版本">#</a> 多线程版本</h3><p>我们使用之前讲到过的线程池技术，将上面的代码修改为多线程版本。</p><pre><code class="language-Python">&quot;&quot;&quot;example05.py - 多线程版本爬虫&quot;&quot;&quot;import osfrom concurrent.futures import ThreadPoolExecutorimport requestsdef download_picture(url):    filename = url[url.rfind('/') + 1:]    resp = requests.get(url)    if resp.status_code == 200:        with open(f'images/beauty/&#123;filename&#125;', 'wb') as file:            file.write(resp.content)def main():    if not os.path.exists('images/beauty'):        os.makedirs('images/beauty')    with ThreadPoolExecutor(max_workers=16) as pool:        for page in range(3):            resp = requests.get(f'https://image.so.com/zjl?ch=beauty&amp;sn=&#123;page * 30&#125;')            if resp.status_code == 200:                pic_dict_list = resp.json()['list']                for pic_dict in pic_dict_list:                    pool.submit(download_picture, pic_dict['qhimg_url'])if __name__ == '__main__':    main()</code></pre><p>执行如下所示的命令。</p><pre><code class="language-Bash">time python3 example05.py</code></pre><p>代码的执行结果如下所示：</p><pre><code>python3 example05.py  2.65s user 0.40s system 95% cpu 3.193 total</code></pre><h3 id="异步io版本"><a class="anchor" href="#异步io版本">#</a> 异步 I/O 版本</h3><p>我们使用 <code>aiohttp</code>  将上面的代码修改为异步 I/O 的版本。为了以异步 I/O 的方式实现网络资源的获取和写文件操作，我们首先得安装三方库 <code>aiohttp</code>  和 <code>aiofile</code> ，命令如下所示。</p><pre><code class="language-Bash">pip install aiohttp aiofile</code></pre><p><code>aiohttp</code>  的用法在之前的课程中已经做过简要介绍， <code>aiofile</code>  模块中的 <code>async_open</code>  函数跟 Python 内置函数 <code>open</code>  的用法大致相同，只不过它支持异步操作。下面是异步 I/O 版本的爬虫代码。</p><pre><code class="language-Python">&quot;&quot;&quot;example06.py - 异步I/O版本爬虫&quot;&quot;&quot;import asyncioimport jsonimport osimport aiofileimport aiohttpasync def download_picture(session, url):    filename = url[url.rfind('/') + 1:]    async with session.get(url, ssl=False) as resp:        if resp.status == 200:            data = await resp.read()            async with aiofile.async_open(f'images/beauty/&#123;filename&#125;', 'wb') as file:                await file.write(data)async def fetch_json():    async with aiohttp.ClientSession() as session:        for page in range(3):            async with session.get(                url=f'https://image.so.com/zjl?ch=beauty&amp;sn=&#123;page * 30&#125;',                ssl=False            ) as resp:                if resp.status == 200:                    json_str = await resp.text()                    result = json.loads(json_str)                    for pic_dict in result['list']:                        await download_picture(session, pic_dict['qhimg_url'])def main():    if not os.path.exists('images/beauty'):        os.makedirs('images/beauty')    loop = asyncio.get_event_loop()    loop.run_until_complete(fetch_json())    loop.close()if __name__ == '__main__':    main()</code></pre><p>执行如下所示的命令。</p><pre><code class="language-Bash">time python3 example06.py</code></pre><p>代码的执行结果如下所示：</p><pre><code>python3 example06.py  0.82s user 0.21s system 27% cpu 3.782 total</code></pre><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>通过上面三段代码执行结果的比较，我们可以得出一个结论，使用多线程和异步 I/O 都可以改善爬虫程序的性能，因为我们不用将时间浪费在因 I/O 操作造成的等待和阻塞上，而 <code>time</code>  命令的执行结果也告诉我们，单线程的代码 CPU 利用率仅仅只有 <code>12%</code> ，而多线程版本的 CPU 利用率则高达 <code>95%</code> ；单线程版本的爬虫执行时间约 <code>21</code>  秒，而多线程和异步 I/O 的版本仅执行了 <code>3</code>  秒钟。另外，在运行时间差别不大的情况下，多线程的代码比异步 I/O 的代码耗费了更多的 CPU 资源，这是因为多线程的调度和切换也需要花费 CPU 时间。至此，三种方式在 I/O 密集型任务上的优劣已经一目了然，当然这只是在我的电脑上跑出来的结果。如果网络状况不是很理想或者目标网站响应很慢，那么使用多线程和异步 I/O 的优势将更为明显，有兴趣的读者可以自行试验。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python解析HTML页面</title>
      <link href="/computer-science/python/basic/62.%E7%94%A8Python%E8%A7%A3%E6%9E%90HTML%E9%A1%B5%E9%9D%A2-2/"/>
      <url>/computer-science/python/basic/62.%E7%94%A8Python%E8%A7%A3%E6%9E%90HTML%E9%A1%B5%E9%9D%A2-2/</url>
      
        <content type="html"><![CDATA[<h2 id="用python解析html页面"><a class="anchor" href="#用python解析html页面">#</a> 用 Python 解析 HTML 页面</h2><p>在前面的课程中，我们讲到了使用 <code>request</code>  三方库获取网络资源，还介绍了一些前端的基础知识。接下来，我们继续探索如何解析 HTML 代码，从页面中提取出有用的信息。之前，我们尝试过用正则表达式的捕获组操作提取页面内容，但是写出一个正确的正则表达式也是一件让人头疼的事情。为了解决这个问题，我们得先深入的了解一下 HTML 页面的结构，并在此基础上研究另外的解析页面的方法。</p><h3 id="html-页面的结构"><a class="anchor" href="#html-页面的结构">#</a> HTML 页面的结构</h3><p>我们在浏览器中打开任意一个网站，然后通过鼠标右键菜单，选择 “显示网页源代码” 菜单项，就可以看到网页对应的 HTML 代码。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210822094218.png" alt="image-20210822094218269" /></p><p>代码的第 <code>1</code>  行是文档类型声明，第 <code>2</code>  行的 <code>&lt;html&gt;</code>  标签是整个页面根标签的开始标签，最后一行是根标签的结束标签 <code>&lt;/html&gt;</code> 。 <code>&lt;html&gt;</code>  标签下面有两个子标签 <code>&lt;head&gt;</code>  和 <code>&lt;body&gt;</code> ，放在 <code>&lt;body&gt;</code>  标签下的内容会显示在浏览器窗口中，这部分内容是网页的主体；放在 <code>&lt;head&gt;</code>  标签下的内容不会显示在浏览器窗口中，但是却包含了页面重要的元信息，通常称之为网页的头部。HTML 页面大致的代码结构如下所示。</p><pre><code class="language-HTML">&lt;!doctype html&gt;&lt;html&gt;    &lt;head&gt;        &lt;!-- 页面的元信息，如字符编码、标题、关键字、媒体查询等 --&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 页面的主体，显示在浏览器窗口中的内容 --&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>标签、层叠样式表（CSS）、JavaScript 是构成 HTML 页面的三要素，其中标签用来承载页面要显示的内容，CSS 负责对页面的渲染，而 JavaScript 用来控制页面的交互式行为。要实现 HTML 页面的解析，可以使用 XPath 的语法，它原本是 XML 的一种查询语法，可以根据 HTML 标签的层次结构提取标签中的内容或标签属性；此外，也可以使用 CSS 选择器来定位页面元素，就跟用 CSS 渲染页面元素是同样的道理。</p><h3 id="xpath-解析"><a class="anchor" href="#xpath-解析">#</a> XPath 解析</h3><p>XPath 是在 XML（eXtensible Markup Language）文档中查找信息的一种语法，XML 跟 HTML 类似也是一种用标签承载数据的标签语言，不同之处在于 XML 的标签是可扩展的，可以自定义的，而且 XML 对语法有更严格的要求。XPath 使用路径表达式来选取 XML 文档中的节点或者节点集，这里所说的节点包括元素、属性、文本、命名空间、处理指令、注释、根节点等。下面我们通过一个例子来说明如何使用 XPath 对页面进行解析。</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bookstore&gt;    &lt;book&gt;      &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;      &lt;price&gt;29.99&lt;/price&gt;    &lt;/book&gt;    &lt;book&gt;      &lt;title lang=&quot;zh&quot;&gt;Learning XML&lt;/title&gt;      &lt;price&gt;39.95&lt;/price&gt;    &lt;/book&gt;&lt;/bookstore&gt;</code></pre><p>对于上面的 XML 文件，我们可以用如下所示的 XPath 语法获取文档中的节点。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>/bookstore</code></td><td>选取根元素 bookstore。<strong>注意</strong>：假如路径起始于正斜杠 (/)，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td><code>//book</code></td><td>选取所有 book 子元素，而不管它们在文档中的位置。</td></tr><tr><td><code>//@lang</code></td><td>选取名为 lang 的所有属性。</td></tr><tr><td><code>/bookstore/book[1]</code></td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td><code>/bookstore/book[last()]</code></td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td><code>/bookstore/book[last()-1]</code></td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td><code>/bookstore/book[position()&lt;3]</code></td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td><code>//title[@lang]</code></td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td><code>//title[@lang='eng']</code></td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td><code>/bookstore/book[price&gt;35.00]</code></td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td><code>/bookstore/book[price&gt;35.00]/title</code></td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table><p>XPath 还支持通配符用法，如下所示。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>/bookstore/*</code></td><td>选取 bookstore 元素的所有子元素。</td></tr><tr><td><code>//*</code></td><td>选取文档中的所有元素。</td></tr><tr><td><code>//title[@*]</code></td><td>选取所有带有属性的 title 元素。</td></tr></tbody></table><p>如果要选取多个节点，可以使用如下所示的方法。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>//book/title \| //book/price</code></td><td>选取 book 元素的所有 title 和 price 元素。</td></tr><tr><td><code>//title \| //price</code></td><td>选取文档中的所有 title 和 price 元素。</td></tr><tr><td><code>/bookstore/book/title \| //price</code></td><td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td></tr></tbody></table><blockquote><p><strong>说明</strong>：上面的例子来自于 “菜鸟教程” 网站上的 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS94cGF0aC94cGF0aC10dXRvcmlhbC5odG1s">XPath 教程</span>，有兴趣的读者可以自行阅读原文。</p></blockquote><p>当然，如果不理解或不熟悉 XPath 语法，可以在浏览器的开发者工具中按照如下所示的方法查看元素的 XPath 语法，下图是在 Chrome 浏览器的开发者工具中查看豆瓣网电影详情信息中影片标题的 XPath 语法。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210822093707.png" alt="" /></p><p>实现 XPath 解析需要三方库 <code>lxml</code>  的支持，可以使用下面的命令安装 <code>lxml</code> 。</p><pre><code class="language-Bash">pip install lxml</code></pre><p>下面我们用 XPath 解析方式改写之前获取豆瓣电影 Top250 的代码，如下所示。</p><pre><code class="language-Python">from lxml import etreeimport requestsfor page in range(1, 11):    resp = requests.get(        url=f'https://movie.douban.com/top250?start=&#123;(page - 1) * 25&#125;',        headers=&#123;'User-Agent': 'BaiduSpider'&#125;    )    tree = etree.HTML(resp.text)    # 通过XPath语法从页面中提取电影标题    title_spans = tree.xpath('//*[@id=&quot;content&quot;]/div/div[1]/ol/li/div/div[2]/div[1]/a/span[1]')    # 通过XPath语法从页面中提取电影评分    rank_spans = tree.xpath('//*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[2]/div/span[2]')    for title_span, rank_span in zip(title_spans, rank_spans):        print(title_span.text, rank_span.text)</code></pre><h3 id="css-选择器解析"><a class="anchor" href="#css-选择器解析">#</a> CSS 选择器解析</h3><p>对于熟悉 CSS 选择器和 JavaScript 的开发者来说，通过 CSS 选择器获取页面元素可能是更为简单的选择，因为浏览器中运行的 JavaScript 本身就可以 <code>document</code>  对象的 <code>querySelector()</code>  和 <code>querySelectorAll()</code>  方法基于 CSS 选择器获取页面元素。在 Python 中，我们可以利用三方库 <code>beautifulsoup4</code>  或 <code>pyquery</code>  来做同样的事情。Beautiful Soup 可以用来解析 HTML 和 XML 文档，修复含有未闭合标签等错误的文档，通过为待解析的页面在内存中创建一棵树结构，实现对从页面中提取数据操作的封装。可以用下面的命令来安装 Beautiful Soup。</p><pre><code class="language-Python">pip install beautifulsoup4</code></pre><p>下面是使用 <code>bs4</code>  改写的获取豆瓣电影 Top250 电影名称的代码。</p><pre><code class="language-Python">import bs4import requestsfor page in range(1, 11):    resp = requests.get(        url=f'https://movie.douban.com/top250?start=&#123;(page - 1) * 25&#125;',        headers=&#123;'User-Agent': 'BaiduSpider'&#125;    )    # 创建BeautifulSoup对象    soup = bs4.BeautifulSoup(resp.text, 'lxml')    # 通过CSS选择器从页面中提取包含电影标题的span标签    title_spans = soup.select('div.info &gt; div.hd &gt; a &gt; span:nth-child(1)')    # 通过CSS选择器从页面中提取包含电影评分的span标签    rank_spans = soup.select('div.info &gt; div.bd &gt; div &gt; span.rating_num')    for title_span, rank_span in zip(title_spans, rank_spans):        print(title_span.text, rank_span.text)</code></pre><p>关于 BeautifulSoup 更多的知识，可以参考它的<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3J1bW15LmNvbS9zb2Z0d2FyZS9CZWF1dGlmdWxTb3VwL2JzNC9kb2Muemgv">官方文档</span>。</p><h3 id="简单的总结"><a class="anchor" href="#简单的总结">#</a> 简单的总结</h3><p>下面我们对三种解析方式做一个简单比较。</p><table><thead><tr><th>解析方式</th><th>对应的模块</th><th>速度</th><th>使用难度</th></tr></thead><tbody><tr><td>正则表达式解析</td><td><code>re</code></td><td>快</td><td>困难</td></tr><tr><td>XPath 解析</td><td><code>lxml</code></td><td>快</td><td>一般</td></tr><tr><td>CSS 选择器解析</td><td><code>bs4</code>  或 <code>pyquery</code></td><td>不确定</td><td>简单</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python获取网络数据</title>
      <link href="/computer-science/python/basic/62.%E7%94%A8Python%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90-1/"/>
      <url>/computer-science/python/basic/62.%E7%94%A8Python%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90-1/</url>
      
        <content type="html"><![CDATA[<h2 id="用python获取网络数据"><a class="anchor" href="#用python获取网络数据">#</a> 用 Python 获取网络数据</h2><p>网络数据采集是 Python 语言非常擅长的领域，上节课我们讲到，实现网络数据采集的程序通常称之为网络爬虫或蜘蛛程序。即便是在大数据时代，数据对于中小企业来说仍然是硬伤和短板，有些数据需要通过开放或付费的数据接口来获得，其他的行业数据和竞对数据则必须要通过网络数据采集的方式来获得。不管使用哪种方式获取网络数据资源，Python 语言都是非常好的选择，因为 Python 的标准库和三方库都对网络数据采集提供了良好的支持。</p><h3 id="requests库"><a class="anchor" href="#requests库">#</a> requests 库</h3><p>要使用 Python 获取网络数据，我们推荐大家使用名为 <code>requests</code>  的三方库，这个库我们在之前的课程中其实已经使用过了。按照官方网站的解释， <code>requests</code>  是基于 Python 标准库进行了封装，简化了通过 HTTP 或 HTTPS 访问网络资源的操作。上课我们提到过，HTTP 是一个请求响应式的协议，当我们在浏览器中输入正确的 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9MZWFybi9Db21tb25fcXVlc3Rpb25zL1doYXRfaXNfYV9VUkw=">URL</span>（通常也称为网址）并按下 Enter 键时，我们就向网络上的 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9MZWFybi9Db21tb25fcXVlc3Rpb25zL1doYXRfaXNfYV93ZWJfc2VydmVy">Web 服务器</span>发送了一个 HTTP 请求，服务器在收到请求后会给我们一个 HTTP 响应。在 Chrome 浏览器中的菜单中打开 “开发者工具” 切换到 “Network” 选项卡就能够查看 HTTP 请求和响应到底是什么样子的，如下图所示。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210822093434.png" alt="" /></p><p>通过 <code>requests</code>  库，我们可以让 Python 程序向浏览器一样向 Web 服务器发起请求，并接收服务器返回的响应，从响应中我们就可以提取出想要的数据。浏览器呈现给我们的网页是用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTA==">HTML</span> 编写的，浏览器相当于是 HTML 的解释器环境，我们看到的网页中的内容都包含在 HTML 的标签中。在获取到 HTML 代码后，就可以从标签的属性或标签体中提取内容。下面例子演示了如何获取网页 HTML 代码，我们通过 <code>requests</code>  库的 <code>get</code>  函数，获取了搜狐首页的代码。</p><pre><code class="language-Python">import requestsresp = requests.get('https://www.sohu.com/')if resp.status_code == 200:    print(resp.text)</code></pre><blockquote><p><strong>说明</strong>：上面代码中的变量 <code>resp</code>  是一个 <code>Response</code>  对象（ <code>requests</code>  库封装的类型），通过该对象的 <code>status_code</code>  属性可以获取响应状态码，而该对象的 <code>text</code>  属性可以帮我们获取到页面的 HTML 代码。</p></blockquote><p>由于 <code>Response</code>  对象的 <code>text</code>  是一个字符串，所以我们可以利用之前讲过的正则表达式的知识，从页面的 HTML 代码中提取新闻的标题和链接，代码如下所示。</p><pre><code class="language-Python">import reimport requestspattern = re.compile(r'&lt;a.*?href=&quot;(.*?)&quot;.*?title=&quot;(.*?)&quot;.*?&gt;')resp = requests.get('https://www.sohu.com/')if resp.status_code == 200:    all_matches = pattern.findall(resp.text)    for href, title in all_matches:        print(href)        print(title)</code></pre><p>除了文本内容，我们也可以使用 <code>requests</code>  库通过 URL 获取二进制资源。下面的例子演示了如何获取百度 Logo 并保存到名为 <code>baidu.png</code>  的本地文件中。可以在百度的首页上右键点击百度 Logo，并通过 “复制图片地址” 菜单项获取图片的 URL。</p><pre><code class="language-Python">import requestsresp = requests.get('https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png')with open('baidu.png', 'wb') as file:    file.write(resp.content)</code></pre><blockquote><p><strong>说明</strong>： <code>Response</code>  对象的 <code>content</code>  属性可以获得服务器响应的二进制数据。</p></blockquote><p><code>requests</code>  库非常好用而且功能上也比较强大和完整，具体的内容我们在使用的过程中为大家一点点剖析。想解锁关于 <code>requests</code>  库更多的知识，可以阅读它的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi1yZXF1ZXN0cy5vcmcvemhfQ04vbGF0ZXN0Lw==">官方文档</span>。</p><h3 id="编写爬虫代码"><a class="anchor" href="#编写爬虫代码">#</a> 编写爬虫代码</h3><p>接下来，我们以 “豆瓣电影” 为例，为大家讲解如何编写爬虫代码。按照上面提供的方法，我们先使用 <code>requests</code>  获取到网页的 HTML 代码，然后将整个代码看成一个长字符串，这样我们就可以使用正则表达式的捕获组从字符串提取我们需要的内容。下面的代码演示了如何从<span class="exturl" data-url="aHR0cHM6Ly9tb3ZpZS5kb3ViYW4uY29tLw==">豆瓣电影</span>获取排前 250 名的电影的名称。<span class="exturl" data-url="aHR0cHM6Ly9tb3ZpZS5kb3ViYW4uY29tL3RvcDI1MA==">豆瓣电影 Top250</span> 的页面结构和对应代码如下图所示，可以看出，每页共展示了 25 部电影，如果要获取到 Top250 数据，我们共需要访问 10 个页面，对应的地址是<span class="exturl" data-url="aHR0cHM6Ly9tb3ZpZS5kb3ViYW4uY29tL3RvcDI1MD9zdGFydD14eHg="> https://movie.douban.com/top250?start=xxx</span>，这里的 <code>xxx</code>  如果为 <code>0</code>  就是第一页，如果 <code>xxx</code>  的值是 <code>100</code> ，那么我们可以访问到第五页。为了代码简单易读，我们只获取电影的标题和评分。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210822093447.png" alt="" /></p><pre><code class="language-Python">import randomimport reimport timeimport requestsfor page in range(1, 11):    resp = requests.get(        url=f'https://movie.douban.com/top250?start=&#123;(page - 1) * 25&#125;',        # 如果不设置HTTP请求头中的User-Agent，豆瓣会检测出不是浏览器而阻止我们的请求。        # 通过get函数的headers参数设置User-Agent的值，具体的值可以在浏览器的开发者工具查看到。        # 用爬虫访问大部分网站时，将爬虫伪装成来自浏览器的请求都是非常重要的一步。        headers=&#123;'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'&#125;    )    # 通过正则表达式获取class属性为title且标签体不以&amp;开头的span标签并用捕获组提取标签内容    pattern1 = re.compile(r'&lt;span class=&quot;title&quot;&gt;([^&amp;]*?)&lt;/span&gt;')    titles = pattern1.findall(resp.text)    # 通过正则表达式获取class属性为rating_num的span标签并用捕获组提取标签内容    pattern2 = re.compile(r'&lt;span class=&quot;rating_num&quot;.*?&gt;(.*?)&lt;/span&gt;')    ranks = pattern2.findall(resp.text)    # 使用zip压缩两个列表，循环遍历所有的电影标题和评分    for title, rank in zip(titles, ranks):        print(title, rank)    # 随机休眠1-5秒，避免爬取页面过于频繁    time.sleep(random.random() * 4 + 1)</code></pre><blockquote><p><strong>说明</strong>：通过分析豆瓣网的 robots 协议，我们发现豆瓣网并不拒绝百度爬虫获取它的数据，因此我们也可以将爬虫伪装成百度的爬虫，将 <code>get</code>  函数的 <code>headers</code>  参数修改为： <code>headers=&#123;'User-Agent': 'BaiduSpider'&#125;</code> 。</p></blockquote><h3 id="使用-ip-代理"><a class="anchor" href="#使用-ip-代理">#</a> 使用 IP 代理</h3><p>让爬虫程序隐匿自己的身份对编写爬虫程序来说是比较重要的，很多网站对爬虫都比较反感的，因为爬虫会耗费掉它们很多的网络带宽并制造很多无效的流量。要隐匿身份通常需要使用<strong>商业 IP 代理</strong>（如蘑菇代理、芝麻代理、快代理等），让被爬取的网站无法获取爬虫程序来源的真实 IP 地址，也就无法简单的通过 IP 地址对爬虫程序进行封禁。</p><p>下面以<span class="exturl" data-url="aHR0cDovL3d3dy5tb2d1cHJveHkuY29tLw==">蘑菇代理</span>为例，为大家讲解商业 IP 代理的使用方法。首先需要在该网站注册一个账号，注册账号后就可以<span class="exturl" data-url="aHR0cDovL3d3dy5tb2d1cHJveHkuY29tL2J1eQ==">购买</span>相应的套餐来获得商业 IP 代理。作为商业用途，建议大家购买不限量套餐，这样可以根据实际需要获取足够多的代理 IP 地址；作为学习用途，可以购买包时套餐或根据自己的需求来决定。蘑菇代理提供了两种接入代理的方式，分别是 API 私密代理和 HTTP 隧道代理，前者是通过请求蘑菇代理的 API 接口获取代理服务器地址，后者是直接使用统一的入口（蘑菇代理提供的域名）进行接入。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTA4MjkwODA2NDcucG5n">https://gitee.com/jackfrued/mypic/raw/master/20210829080647.png</span>&quot; width=&quot;75%&quot;&gt;</p><p>下面，我们以 HTTP 隧道代理为例，为大家讲解接入 IP 代理的方式，大家也可以直接参考蘑菇代理官网提供的代码来为爬虫设置代理。</p><pre><code class="language-Python">import requestsAPP_KEY = 'Wnp******************************XFx'PROXY_HOST = 'secondtransfer.moguproxy.com:9001'for page in range(1, 11):    resp = requests.get(        url=f'https://movie.douban.com/top250?start=&#123;(page - 1) * 25&#125;',        # 需要在HTTP请求头设置代理的身份认证方式        headers=&#123;            'Proxy-Authorization': f'Basic &#123;APP_KEY&#125;',            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36',            'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4'        &#125;,        # 设置代理服务器        proxies=&#123;            'http': f'http://&#123;PROXY_HOST&#125;',            'https': f'https://&#123;PROXY_HOST&#125;'        &#125;,        verify=False    )    pattern1 = re.compile(r'&lt;span class=&quot;title&quot;&gt;([^&amp;]*?)&lt;/span&gt;')    titles = pattern1.findall(resp.text)    pattern2 = re.compile(r'&lt;span class=&quot;rating_num&quot;.*?&gt;(.*?)&lt;/span&gt;')    ranks = pattern2.findall(resp.text)    for title, rank in zip(titles, ranks):        print(title, rank)</code></pre><blockquote><p><strong>说明</strong>：上面的代码需要修改 <code>APP_KEY</code>  为自己创建的订单对应的 <code>Appkey</code>  值，这个值可以在用户中心用户订单中查看到。蘑菇代理提供了免费的 API 代理和 HTTP 隧道代理试用，但是试用的代理接通率不能保证，建议大家还是直接购买一个在自己支付能力范围内的代理服务来体验。</p></blockquote><h3 id="简单的总结"><a class="anchor" href="#简单的总结">#</a> 简单的总结</h3><p>Python 语言能做的事情真的很多，就网络数据采集这一项而言，Python 几乎是一枝独秀的，大量的企业和个人都在使用 Python 从网络上获取自己需要的数据，这可能也是你将来日常工作的一部分。另外，用编写正则表达式的方式从网页中提取内容虽然可行，但是写出一个能够满足需求的正则表达式本身也不是件容易的事情，这一点对于新手来说尤为明显。在下一节课中，我们将会为大家介绍另外两种从页面中提取数据的方法，虽然从性能上来讲，它们可能不如正则表达式，但是却降低了编码的复杂性，相信大家会喜欢上它们的。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络数据采集概述</title>
      <link href="/computer-science/python/basic/61.%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%A6%82%E8%BF%B0/"/>
      <url>/computer-science/python/basic/61.%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="网络数据采集概述"><a class="anchor" href="#网络数据采集概述">#</a> 网络数据采集概述</h2><p>爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获取所需信息的机器人程序（自动化脚本代码），被广泛的应用于互联网搜索引擎和数据采集。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接，网络爬虫正是通过网页中的超链接信息，不断获得网络上其它页面的地址，然后持续的进行数据采集。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为爬虫或者网络蜘蛛。</p><h3 id="爬虫的应用领域"><a class="anchor" href="#爬虫的应用领域">#</a> 爬虫的应用领域</h3><p>在理想的状态下，所有 ICP（Internet Content Provider）都应该为自己的网站提供 API 接口来共享它们允许其他程序获取的数据，在这种情况下就根本不需要爬虫程序。国内比较有名的电商平台（如淘宝、京东等）、社交平台（如微博、微信等）等都提供了自己的 API 接口，但是这类 API 接口通常会对可以抓取的数据以及抓取数据的频率进行限制。对于大多数的公司而言，及时的获取行业数据和竞对数据是企业生存的重要环节之一，然而对大部分企业来说，数据都是其与生俱来的短板。在这种情况下，合理的利用爬虫来获取数据并从中提取出有商业价值的信息对这些企业来说就显得至关重要的。</p><p>爬虫的应用领域其实非常广泛，下面我们列举了其中的一部分，有兴趣的读者可以自行探索相关内容。</p><ol><li>搜索引擎</li><li>新闻聚合</li><li>社交应用</li><li>舆情监控</li><li>行业数据</li></ol><h3 id="爬虫合法性探讨"><a class="anchor" href="#爬虫合法性探讨">#</a> 爬虫合法性探讨</h3><p>经常听人说起 “爬虫写得好，牢饭吃到饱”，那么编程爬虫程序是否违法呢？关于这个问题，我们可以从以下几个角度进行解读。</p><ol><li>网络爬虫这个领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起了一定的道德规范，即 Robots 协议（全称是 “网络爬虫排除标准”），但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。</li><li>“法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。</li><li>在爬取网站的时候，需要限制自己的爬虫遵守 Robots 协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从 Web 2.0 时代开始，虽然 Web 上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。</li><li>适当的隐匿自己的身份在编写爬虫程序时必要的，而且最好不要被对方举证你的爬虫有破坏别人动产（例如服务器）的行为。</li><li>不要在公网（如代码托管平台）上去开源或者展示你的爬虫代码，这些行为通常会给自己带来不必要的麻烦。</li></ol><h4 id="robots协议"><a class="anchor" href="#robots协议">#</a> Robots 协议</h4><p>大多数网站都会定义 <code>robots.txt</code>  文件，这是一个君子协议，并不是所有爬虫都必须遵守的游戏规则。下面以淘宝的<a href="http://www.taobao.com/robots.txt"> <code>robots.txt</code> </a> 文件为例，看看淘宝网对爬虫有哪些限制。</p><pre><code>User-agent: BaiduspiderDisallow: /User-agent: baiduspiderDisallow: /</code></pre><p>通过上面的文件可以看出，淘宝禁止百度爬虫爬取它任何资源，因此当你在百度搜索 “淘宝” 的时候，搜索结果下方会出现：“由于该网站的 <code>robots.txt</code>  文件存在限制指令（限制搜索引擎抓取），系统无法提供该页面的内容描述”。百度作为一个搜索引擎，至少在表面上遵守了淘宝网的 <code>robots.txt</code>  协议，所以用户不能从百度上搜索到淘宝内部的产品信息。</p><p>图 1. 百度搜索淘宝的结果</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210824004320.png" alt="" /></p><p>下面是豆瓣网的<a href="https://www.douban.com/robots.txt"> <code>robots.txt</code> </a> 文件，大家可以自行解读，看看它做出了什么样的限制。</p><pre><code>User-agent: *Disallow: /subject_searchDisallow: /amazon_searchDisallow: /searchDisallow: /group/searchDisallow: /event/searchDisallow: /celebrities/searchDisallow: /location/drama/searchDisallow: /forum/Disallow: /new_subjectDisallow: /service/iframeDisallow: /j/Disallow: /link2/Disallow: /recommend/Disallow: /doubanapp/cardDisallow: /update/topic/Disallow: /share/Allow: /ads.txtSitemap: https://www.douban.com/sitemap_index.xmlSitemap: https://www.douban.com/sitemap_updated_index.xml# Crawl-delay: 5User-agent: Wandoujia SpiderDisallow: /User-agent: Mediapartners-GoogleDisallow: /subject_searchDisallow: /amazon_searchDisallow: /searchDisallow: /group/searchDisallow: /event/searchDisallow: /celebrities/searchDisallow: /location/drama/searchDisallow: /j/</code></pre><h3 id="超文本传输协议http"><a class="anchor" href="#超文本传输协议http">#</a> 超文本传输协议（HTTP）</h3><p>在开始讲解爬虫之前，我们稍微对超文本传输协议（HTTP）做一些回顾，因为我们在网页上看到的内容通常是浏览器执行 HTML （超文本标记语言）得到的结果，而 HTTP 就是传输 HTML 数据的协议。HTTP 和其他很多应用级协议一样是构建在 TCP（传输控制协议）之上的，它利用了 TCP 提供的可靠的传输服务实现了 Web 应用中的数据交换。按照维基百科上的介绍，设计 HTTP 最初的目的是为了提供一种发布和接收 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFRNTA==">HTML</span> 页面的方法，也就是说，这个协议是浏览器和 Web 服务器之间传输的数据的载体。关于 HTTP 的详细信息以及目前的发展状况，大家可以阅读<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDgvaHR0cC5odG1s">《HTTP 协议入门》</span>、<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDUvaW50ZXJuZXRfcHJvdG9jb2xfc3VpdGVfcGFydF9pLmh0bWw=">《互联网协议入门》</span>、<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMDkvaWxsdXN0cmF0aW9uLXNzbC5odG1s">《图解 HTTPS 协议》</span>等文章进行了解。</p><p>下图是我在四川省网络通信技术重点实验室工作期间用开源协议分析工具 Ethereal（WireShark 的前身）截取的访问百度首页时的 HTTP 请求和响应的报文（协议数据），由于 Ethereal 截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。</p><p>图 2. HTTP 请求</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210824003915.png" alt="http-request" /></p><p>HTTP 请求通常是由请求行、请求头、空行、消息体四个部分构成，如果没有数据发给服务器，消息体就不是必须的部分。请求行中包含了请求方法（GET、POST 等，如下表所示）、资源路径和协议版本；请求头由若干键值对构成，包含了浏览器、编码方式、首选语言、缓存策略等信息；请求头的后面是空行和消息体。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTA4MjUwMDI3MjAuUE5H">https://gitee.com/jackfrued/mypic/raw/master/20210825002720.PNG</span>&quot; width=&quot;65%&quot;&gt;</p><p>图 3. HTTP 响应</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210824234158.png" alt="http-response" /></p><p>HTTP 响应通常是由响应行、响应头、空行、消息体四个部分构成，其中消息体是服务响应的数据，可能是 HTML 页面，也有可能是 JSON 或二进制数据等。响应行中包含了协议版本和响应状态码，响应状态码有很多种，常见的如下表所示。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTA4MjUwMDI4MDIuUE5H">https://gitee.com/jackfrued/mypic/raw/master/20210825002802.PNG</span>&quot; width=&quot;65%&quot;&gt;</p><h4 id="相关工具"><a class="anchor" href="#相关工具">#</a> 相关工具</h4><p>下面我们先介绍一些开发爬虫程序的辅助工具，这些工具相信能帮助你事半功倍。</p><ol><li><p>Chrome Developer Tools：谷歌浏览器内置的开发者工具。该工具最常用的几个功能模块是：</p><ul><li>元素（ELements）：用于查看或修改 HTML 元素的属性、CSS 属性、监听事件等。CSS 可以即时修改，即时显示，大大方便了开发者调试页面。</li><li>控制台（Console）：用于执行一次性代码，查看 JavaScript 对象，查看调试日志信息或异常信息。控制台其实就是一个执行 JavaScript 代码的交互式环境。</li><li>源代码（Sources）：用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，此外最重要的是可以调试 JavaScript 源代码，可以给代码添加断点和单步执行。</li><li>网络（Network）：用于 HTTP 请求、HTTP 响应以及与网络连接相关的信息。</li><li>应用（Application）：用于查看浏览器本地存储、后台任务等内容，本地存储主要包括 Cookie、Local Storage、Session Storage 等。</li></ul><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210824004034.png" alt="chrome-developer-tools" /></p></li><li><p>Postman：功能强大的网页调试与 RESTful 请求工具。Postman 可以帮助我们模拟请求，非常方便的定制我们的请求以及查看服务器的响应。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210824004048.png" alt="postman" /></p></li><li><p>HTTPie：命令行 HTTP 客户端。</p><p>安装。</p><pre><code class="language-Bash">pip install httpie</code></pre><p>使用。</p><pre><code class="language-Bash">http --header http --header https://movie.douban.com/HTTP/1.1 200 OKConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Tue, 24 Aug 2021 16:48:00 GMTKeep-Alive: timeout=30Server: daeSet-Cookie: bid=58h4BdKC9lM; Expires=Wed, 24-Aug-22 16:48:00 GMT; Domain=.douban.com; Path=/Strict-Transport-Security: max-age=15552000Transfer-Encoding: chunkedX-Content-Type-Options: nosniffX-DOUBAN-NEWBID: 58h4BdKC9lM</code></pre></li><li><p><code>builtwith</code>  库：识别网站所用技术的工具。</p><p>安装。</p><pre><code class="language-Bash">pip install builtwith</code></pre><p>使用。</p><pre><code class="language-Python">import sslimport builtwithssl._create_default_https_context = ssl._create_unverified_contextprint(builtwith.parse('http://www.bootcss.com/'))</code></pre></li><li><p><code>python-whois</code>  库：查询网站所有者的工具。</p><p>安装。</p><pre><code class="language-Bash">pip3 install python-whois</code></pre><p>使用。</p><pre><code class="language-Python">import whoisprint(whois.whois('https://www.bootcss.com'))</code></pre></li></ol><h3 id="爬虫的基本工作流程"><a class="anchor" href="#爬虫的基本工作流程">#</a> 爬虫的基本工作流程</h3><p>一个基本的爬虫通常分为数据采集（网页下载）、数据处理（网页解析）和数据存储（将有用的信息持久化）三个部分的内容，当然更为高级的爬虫在数据采集和处理时会使用并发编程或分布式技术，这就需要有调度器（安排线程或进程执行对应的任务）、后台管理程序（监控爬虫的工作状态以及检查数据抓取的结果）等的参与。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210824004107.png" alt="crawler-workflow" /></p><p>一般来说，爬虫的工作流程包括以下几个步骤：</p><ol><li>设定抓取目标（种子页面 / 起始页面）并获取网页。</li><li>当服务器无法访问时，按照指定的重试次数尝试重新下载页面。</li><li>在需要的时候设置用户代理或隐藏真实 IP，否则可能无法访问页面。</li><li>对获取的页面进行必要的解码操作然后抓取出需要的信息。</li><li>在获取的页面中通过某种方式（如正则表达式）抽取出页面中的链接信息。</li><li>对链接进行进一步的处理（获取页面并重复上面的动作）。</li><li>将有用的信息进行持久化以备后续的处理。</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用FastAPI开发网络数据接口</title>
      <link href="/computer-science/python/basic/56-60.%E7%94%A8FastAPI%E5%BC%80%E5%8F%91%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3/"/>
      <url>/computer-science/python/basic/56-60.%E7%94%A8FastAPI%E5%BC%80%E5%8F%91%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="用fastapi开发网络数据接口"><a class="anchor" href="#用fastapi开发网络数据接口">#</a> 用 FastAPI 开发网络数据接口</h2><p>FastAPI 是一个用于构建 API（网络数据接口）的现代、高性能的 Web 框架，基于 Python 3.6+，使用了 Python 中的类型提示进行类型检查，非常符合工程化开发的需求，在业界有非常好的口碑。下面，我们先用代码告诉大家 FastAPI 到底能做什么，然后再来讲解它的方方面面。</p><h3 id="fastapi五分钟上手"><a class="anchor" href="#fastapi五分钟上手">#</a> FastAPI 五分钟上手</h3><ol><li><p>安装依赖库和 ASGI 服务器（支持异步 I/O 的 Python 服务器）。</p><pre><code class="language-Bash">pip install fastapipip install uvicorn</code></pre></li><li><p>编写代码 <code>main.py</code> 。</p><pre><code class="language-Python">from fastapi import FastAPIapp = FastAPI()@app.get('/')def say_hello():    return &#123;'code': 200, 'message': 'hello, world!'&#125;</code></pre></li><li><p>运行服务。</p><pre><code class="language-Bash">uvicorn main:app --reload</code></pre><blockquote><p><strong>说明</strong>：上面运行 uvicorn 时使用的 <code>--reload</code>  参数会在代码发生变更时自动重新加载新的内容，这个参数在开发阶段非常的有用。</p></blockquote></li><li><p>访问服务。</p></li></ol><p><img data-src="res/run-first-demo.png" alt="" /></p><ol start="5"><li><p>查看文档。</p><p><img data-src="res/first-demo-docs.png" alt="" /></p><blockquote><p><strong>注意</strong>：FastAPI 会基于<span class="exturl" data-url="aHR0cHM6Ly9zd2FnZ2VyLmlvL3Rvb2xzL3N3YWdnZXItdWkv"> Swagger UI</span> 自动为数据接口生成对应的文档。</p></blockquote></li></ol><h3 id="请求和响应"><a class="anchor" href="#请求和响应">#</a> 请求和响应</h3><h3 id="接入关系型数据库"><a class="anchor" href="#接入关系型数据库">#</a> 接入关系型数据库</h3><p>我们可以使用 SQLAlchemy 三方库来实现对关系型数据库的接入。SQLAlchemy 是一个 ORM（对象关系映射）框架，ORM 框架可以解决 Python 程序的面向对象模型和关系型数据库的关系模型并不匹配的问题，使得我们可以用面向对象的方式实现数据的 CRUD 操作。</p><h3 id="依赖注入"><a class="anchor" href="#依赖注入">#</a> 依赖注入</h3><h3 id="中间件"><a class="anchor" href="#中间件">#</a> 中间件</h3><h3 id="异步化"><a class="anchor" href="#异步化">#</a> 异步化</h3><h3 id="虚拟化部署docker"><a class="anchor" href="#虚拟化部署docker">#</a> 虚拟化部署（Docker）</h3><h3 id="项目实战车辆违章查询"><a class="anchor" href="#项目实战车辆违章查询">#</a> 项目实战：车辆违章查询</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目上线</title>
      <link href="/computer-science/python/basic/55.%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/"/>
      <url>/computer-science/python/basic/55.%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="项目上线"><a class="anchor" href="#项目上线">#</a> 项目上线</h2><p>请各位读者移步到<a href="../Day91-100/98.%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.md">《项目部署上线和性能调优》</a>一文。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试</title>
      <link href="/computer-science/python/basic/54.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/computer-science/python/basic/54.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="单元测试"><a class="anchor" href="#单元测试">#</a> 单元测试</h2><p>请各位读者移步到<a href="../Day91-100/95.%E4%BD%BF%E7%94%A8Django%E5%BC%80%E5%8F%91%E5%95%86%E4%B8%9A%E9%A1%B9%E7%9B%AE.md">《使用 Django 开发商业项目》</a>一文。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步任务和定时任务</title>
      <link href="/computer-science/python/basic/53.%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/computer-science/python/basic/53.%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="异步任务和定时任务"><a class="anchor" href="#异步任务和定时任务">#</a> 异步任务和定时任务</h2><p>在 Web 应用中，如果一个请求执行了耗时间的操作或者该请求的执行时间无法确定，而且对于用户来说只需要知道服务器接收了他的请求，并不需要马上得到请求的执行结果，这样的操作我们就应该对其进行异步化处理。如果说<strong>使用缓存是优化网站性能的第一要义</strong>，那么将耗时间或执行时间不确定的任务<strong>异步化则是网站性能优化的第二要义</strong>，简单的说就是<strong>能推迟做的事情都不要马上做</strong>。</p><p>上一章节中讲到的发短信和上传文件到云存储为例，这两个操作前者属于时间不确定的操作（因为作为调用者，我们不能确定三方平台响应的时间），后者属于耗时间的操作（如果文件较大或者三方平台不稳定，都可能导致上传的时间较长），很显然，这两个操作都可以做异步化处理。</p><p>在 Python 项目中实现异步化处理可以使用多线程或借助三方库 Celery 来完成。</p><h3 id="使用celery实现异步化"><a class="anchor" href="#使用celery实现异步化">#</a> 使用 Celery 实现异步化</h3><h3 id="使用多线程实现异步化"><a class="anchor" href="#使用多线程实现异步化">#</a> 使用多线程实现异步化</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接入三方平台</title>
      <link href="/computer-science/python/basic/52.%E6%8E%A5%E5%85%A5%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0/"/>
      <url>/computer-science/python/basic/52.%E6%8E%A5%E5%85%A5%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="接入三方平台"><a class="anchor" href="#接入三方平台">#</a> 接入三方平台</h2><p>在 Web 应用的开发过程中，有一些任务并不是我们自己能够完成的。例如，我们的 Web 项目中需要做个人或企业的实名认证，很显然我们并没有能力判断用户提供的认证信息的真实性，这个时候我们就要借助三方平台提供的服务来完成该项操作。再比如说，我们的项目中需要提供在线支付功能，这类业务通常也是借助支付网关来完成而不是自己去实现，我们只需要接入像微信、支付宝、银联这样的三方平台即可。</p><p>在项目中接入三方平台基本上就两种方式：API 接入和 SDK 接入。</p><ol><li>API 接入指的是通过访问三方提供的 URL 来完成操作或获取数据。国内有很多这样的平台提供了大量常用的服务，例如<span class="exturl" data-url="aHR0cHM6Ly93d3cuanVoZS5jbi8=">聚合数据</span>上提供了生活服务类、金融科技类、交通地理类、充值缴费类等各种类型的 API。我们可以通过 Python 程序发起网络请求，通过访问 URL 获取数据，这些 API 接口跟我们项目中提供的数据接口是一样的，只不过我们项目中的 API 是供自己使用的，而这类三方平台提供的 API 是开放的。当然开放并不代表免费，大多数能够提供有商业价值的数据的 API 都是需要付费才能使用的。</li><li>SDK 接入指的是通过安装三方库并使用三方库封装的类、函数来使用三方平台提供的服务的方式。例如我们刚才说到的接入支付宝，就需要先安装支付宝的 SDK，然后通过支付宝封装的类和方法完成对支付服务的调用。</li></ol><p>下面我们通过具体的例子来讲解如何接入三方平台。</p><h3 id="接入短信网关"><a class="anchor" href="#接入短信网关">#</a> 接入短信网关</h3><p>一个 Web 项目有很多地方都可以用到短信服务，例如：手机验证码登录、重要消息提醒、产品营销短信等。要实现发送短信的功能，可以通过接入短信网关来实现，国内比较有名的短信网关包括：云片短信、网易云信、螺丝帽、SendCloud 等，这些短信网关一般都提供了免费试用功能。下面我们以<span class="exturl" data-url="aHR0cHM6Ly9sdW9zaW1hby5jb20v">螺丝帽</span>平台为例，讲解如何在项目中接入短信网关，其他平台操作基本类似。</p><ol><li><p>注册账号，新用户可以免费试用。</p></li><li><p>登录到管理后台，进入短信版块。</p></li><li><p>点击 “触发发送” 可以找到自己专属的 API Key（身份标识）。</p><p><img data-src="res/luosimao-sms-apikey.png" alt="" /></p></li><li><p>点击 “签名管理” 可以添加短信签名，短信都必须携带签名，免费试用的短信要在短信中添加 “【铁壳测试】” 这个签名，否则短信无法发送。</p><p><img data-src="res/luosimao-sms-signature.png" alt="" /></p></li><li><p>点击 “IP 白名单” 将运行 Django 项目的服务器地址（公网 IP 地址，本地运行可以打开<a href=""> xxx</a> 网站查看自己本机的公网 IP 地址）填写到白名单中，否则短信无法发送。</p><p><img data-src="res/luosimao-sms-whitelist.png" alt="" /></p></li><li><p>如果没有剩余的短信条数，可以到 “充值” 页面选择 “短信服务” 进行充值。</p><p><img data-src="res/luosimao-pay-onlinebuy.png" alt="" /></p></li></ol><p>接下来，我们可以通过调用螺丝帽短信网关实现发送短信验证码的功能，代码如下所示。</p><pre><code class="language-Python">def send_mobile_code(tel, code):    &quot;&quot;&quot;发送短信验证码&quot;&quot;&quot;    resp = requests.post(        url='http://sms-api.luosimao.com/v1/send.json',        auth=('api', 'key-自己的APIKey'),        data=&#123;            'mobile': tel,            'message': f'您的短信验证码是&#123;code&#125;，打死也不能告诉别人哟。【Python小课】'        &#125;,        verify=False    )    return resp.json()</code></pre><p>运行上面的代码需要先安装 <code>requests</code>  三方库，这个三方库封装了 HTTP 网络请求的相关功能，使用起来非常的简单，我们在之前的内容中也讲到过这个三方库。 <code>send_mobile_code</code>  函数有两个参数，第一个参数是手机号，第二个参数是短信验证码的内容，第 5 行代码需要提供自己的 API Key，就是上面第 2 步中查看到的自己的 API Key。请求螺丝帽的短信网关会返回 JSON 格式的数据，对于上面的代码如果返回 <code>&#123;'err': 0, 'msg': 'ok'&#125;</code> ，则表示短信发送成功，如果 <code>err</code>  字段的值不为 <code>0</code>  而是其他值，则表示短信发送失败，可以在螺丝帽官方的<span class="exturl" data-url="aHR0cHM6Ly9sdW9zaW1hby5jb20vZG9jcy9hcGkv">开发文档</span>页面上查看到不同的数值代表的含义，例如： <code>-20</code>  表示余额不足， <code>-32</code>  表示缺少短信签名。</p><p>可以在视图函数中调用上面的函数来完成发送短信验证码的功能，稍后我们可以把这个功能跟用户注册结合起来。</p><p>生成随机验证码和验证手机号的函数。</p><pre><code class="language-Python">import randomimport reTEL_PATTERN = re.compile(r'1[3-9]\d&#123;9&#125;')def check_tel(tel):    &quot;&quot;&quot;检查手机号&quot;&quot;&quot;    return TEL_PATTERN.fullmatch(tel) is not Nonedef random_code(length=6):    &quot;&quot;&quot;生成随机短信验证码&quot;&quot;&quot;    return ''.join(random.choices('0123456789', k=length))</code></pre><p>发送短信验证码的视图函数。</p><pre><code class="language-Python">@api_view(('GET', ))def get_mobilecode(request, tel):    &quot;&quot;&quot;获取短信验证码&quot;&quot;&quot;    if check_tel(tel):        redis_cli = get_redis_connection()        if redis_cli.exists(f'vote:block-mobile:&#123;tel&#125;'):            data = &#123;'code': 30001, 'message': '请不要在60秒内重复发送短信验证码'&#125;        else:            code = random_code()            send_mobile_code(tel, code)            # 通过Redis阻止60秒内容重复发送短信验证码            redis_cli.set(f'vote:block-mobile:&#123;tel&#125;', 'x', ex=60)            # 将验证码在Redis中保留10分钟（有效期10分钟）            redis_cli.set(f'vote2:valid-mobile:&#123;tel&#125;', code, ex=600)            data = &#123;'code': 30000, 'message': '短信验证码已发送，请注意查收'&#125;    else:        data = &#123;'code': 30002, 'message': '请输入有效的手机号'&#125;    return Response(data)</code></pre><blockquote><p><strong>说明</strong>：上面的代码利用 Redis 实现了两个额外的功能，一个是阻止用户 60 秒内重复发送短信验证码，一个是将用户的短信验证码保留 10 分钟，也就是说这个短信验证码的有效期只有 10 分钟，我们可以要求用户在注册时提供该验证码来验证用户手机号的真实性。</p></blockquote><h3 id="接入云存储服务"><a class="anchor" href="#接入云存储服务">#</a> 接入云存储服务</h3><p>当我们提到<strong>云存储</strong>这个词的时候，通常是指把数据存放在由第三方提供的虚拟服务器环境下，简单的说就是将某些数据或资源通过第三平台托管。一般情况下，提供云存储服务的公司都运营着大型的数据中心，需要云存储服务的个人或组织通过向其购买或租赁存储空间来满足数据存储的需求。在开发 Web 应用时，可以将静态资源，尤其是用户上传的静态资源直接置于云存储服务中，云存储通常会提供对应的 URL 使得用户可以访问该静态资源。国内外比较有名的云存储服务（如：亚马逊的 S3、阿里的 OSS2 等）一般都物美价廉，相比自己架设静态资源服务器，云存储的代价更小，而且一般的云存储平台都提供了 CDN 服务，用于加速对静态资源的访问，所以不管从哪个角度出发，使用云存储的方式管理 Web 应用的数据和静态资源都是非常好的选择，除非这些资源涉及到个人或商业隐私，否则就可以托管到云存储中。</p><p>下面我们以接入<span class="exturl" data-url="aHR0cHM6Ly93d3cucWluaXUuY29tLw==">七牛云</span>为例，讲解如何实现将用户上传的文件保存到七牛云存储。七牛云是国内知名的云计算及数据服务提供商，七牛云在海量文件存储、CDN、视频点播、互动直播以及大规模异构数据的智能分析与处理等领域都有自己的产品，而且非付费用户也可以免费接入，使用其提供的服务。下面是接入七牛云的流程：</p><ol><li><p>注册账号，登录管理控制台。</p><p><img data-src="res/qiniu-manage-console.png" alt="" /></p></li><li><p>选择左侧菜单中的对象存储。</p><p><img data-src="res/qiniu-storage-service.png" alt="" /></p></li><li><p>在空间管理中选择新建空间（例如：myvote），如果提示空间名称已被占用，更换一个再尝试即可。注意，创建空间后会提示绑定自定义域名，如果暂时还没有自己的域名，可以使用七牛云提供的临时域名，但是临时域名会在 30 天后被回收，所以最好准备自己的域名（域名需要备案，不清楚如何操作的请自行查阅相关资料）。</p><p><img data-src="res/qiniu-storage-create.png" alt="" /></p></li><li><p>在网页的右上角点击个人头像中的 “密钥管理”，查看自己的密钥，稍后在代码中需要使用 AK（AccessKey）和 SK（SecretKey）两个密钥来认证用户身份。</p><p><img data-src="res/qiniu-secretkey-management.png" alt="" /></p></li><li><p>点击网页上方菜单中的 “文档”，进入到<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIucWluaXUuY29tLw==">七牛开发者中心</span>，选择导航菜单中的 “SDK &amp; 工具” 并点击 “官方 SDK” 子菜单，找到 Python（服务端）并点击 “文档” 查看官方文档。</p><p><img data-src="res/qiniu-document-python.png" alt="" /></p></li></ol><p>接下来，只要安装官方文档提供的示例，就可以接入七牛云，使用七牛云提供的云存储以及其他服务。首先可以通过下面的命令安装七牛云的三方库。</p><pre><code class="language-Bash">pip install qiniu</code></pre><p>接下来可以通过 <code>qiniu</code>  模块中的 <code>put_file</code>  和 <code>put_stream</code>  两个函数实现文件上传，前者可以上传指定路径的文件，后者可以将内存中的二进制数据上传至七牛云，具体的代码如下所示。</p><pre><code class="language-Python">import qiniuAUTH = qiniu.Auth('密钥管理中的AccessKey', '密钥管理中的SecretKey')BUCKET_NAME = 'myvote'def upload_file_to_qiniu(key, file_path):    &quot;&quot;&quot;上传指定路径的文件到七牛云&quot;&quot;&quot;    token = AUTH.upload_token(BUCKET_NAME, key)    return qiniu.put_file(token, key, file_path)def upload_stream_to_qiniu(key, stream, size):    &quot;&quot;&quot;上传二进制数据流到七牛云&quot;&quot;&quot;    token = AUTH.upload_token(BUCKET_NAME, key)    return qiniu.put_stream(token, key, stream, None, size)</code></pre><p>下面是一个文件上传的简单前端页。</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;上传文件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/upload/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;div&gt;            &lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p><strong>说明</strong>：前端如果使用表单实现文件上传，表单的 method 属性必须设置为 post，enctype 属性需要设置为 multipart/form-data，表单中 type 属性为 file 的 input 标签，就是上传文件的文件选择器。</p></blockquote><p>实现上传功能的视图函数如下所示。</p><pre><code class="language-Python">from django.views.decorators.csrf import csrf_exempt@csrf_exemptdef upload(request):    # 如果上传的文件小于2.5M，则photo对象的类型为InMemoryUploadedFile，文件在内存中    # 如果上传的文件超过2.5M，则photo对象的类型为TemporaryUploadedFile，文件在临时路径下    photo = request.FILES.get('photo')    _, ext = os.path.splitext(photo.name)    # 通过UUID和原来文件的扩展名生成独一无二的新的文件名    filename = f'&#123;uuid.uuid1().hex&#125;&#123;ext&#125;'    # 对于内存中的文件，可以使用上面封装好的函数upload_stream_to_qiniu上传文件到七牛云    # 如果文件保存在临时路径下，可以使用upload_file_to_qiniu实现文件上传    upload_stream_to_qiniu(filename, photo.file, photo.size)    return redirect('/static/html/upload.html')</code></pre><blockquote><p><strong>注意</strong>：上面的视图函数使用了 <code>csrf_exempt</code>  装饰器，该装饰器能够让表单免除必须提供 CSRF 令牌的要求。此外，代码第 11 行使用了 <code>uuid</code>  模块的 <code>uuid1</code>  函数来生成全局唯一标识符。</p></blockquote><p>运行项目尝试文件上传的功能，文件上传成功后，可以在七牛云 “空间管理” 中点击自己空间并进入 “文件管理” 界面，在这里可以看到我们刚才上传成功的文件，而且可以通过七牛云提供的域名获取该文件。</p><p><img data-src="res/qiniu-file-management.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用缓存</title>
      <link href="/computer-science/python/basic/51.%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/"/>
      <url>/computer-science/python/basic/51.%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="使用缓存"><a class="anchor" href="#使用缓存">#</a> 使用缓存</h2><p>通常情况下，Web 应用的性能瓶颈都会出现在关系型数据库上，当并发访问量较大时，如果所有的请求都需要通过关系型数据库完成数据持久化操作，那么数据库一定会不堪重负。优化 Web 应用性能最为重要的一点就是使用缓存，把那些数据体量不大但访问频率非常高的数据提前加载到缓存服务器中，这又是典型的空间换时间的方法。通常缓存服务器都是直接将数据置于内存中而且使用了非常高效的数据存取策略（哈希存储、键值对方式等），在读写性能上远远优于关系型数据库的，因此我们可以让 Web 应用接入缓存服务器来优化其性能，其中一个非常好的选择就是使用 Redis。</p><p>Web 应用的缓存架构大致如下图所示。</p><p><img data-src="res/redis-cache-service.png" alt="" /></p><h3 id="django项目接入redis"><a class="anchor" href="#django项目接入redis">#</a> Django 项目接入 Redis</h3><p>在此前的课程中，我们介绍过 Redis 的安装和使用，此处不再进行赘述。如果需要在 Django 项目中接入 Redis，可以使用三方库 <code>django-redis</code> ，这个三方库又依赖了一个名为 <code>redis</code>  的三方库，它封装了对 Redis 的各种操作。</p><p>安装 <code>django-redis</code> 。</p><pre><code class="language-Bash">pip install django-redis</code></pre><p>修改 Django 配置文件中关于缓存的配置。</p><pre><code class="language-Python">CACHES = &#123;    'default': &#123;        # 指定通过django-redis接入Redis服务        'BACKEND': 'django_redis.cache.RedisCache',        # Redis服务器的URL        'LOCATION': ['redis://1.2.3.4:6379/0', ],        # Redis中键的前缀（解决命名冲突）        'KEY_PREFIX': 'vote',        # 其他的配置选项        'OPTIONS': &#123;            'CLIENT_CLASS': 'django_redis.client.DefaultClient',            # 连接池（预置若干备用的Redis连接）参数            'CONNECTION_POOL_KWARGS': &#123;                # 最大连接数                'max_connections': 512,            &#125;,            # 连接Redis的用户口令            'PASSWORD': 'foobared',        &#125;    &#125;,&#125;</code></pre><p>至此，我们的 Django 项目已经可以接入 Redis，接下来我们修改项目代码，用 Redis 为之写的获取学科数据的接口提供缓存服务。</p><h3 id="为视图提供缓存服务"><a class="anchor" href="#为视图提供缓存服务">#</a> 为视图提供缓存服务</h3><h4 id="声明式缓存"><a class="anchor" href="#声明式缓存">#</a> 声明式缓存</h4><p>所谓声明式缓存是指不修改原来的代码，通过 Python 中的装饰器（代理）为原有的代码增加缓存功能。对于 FBV，代码如下所示。</p><pre><code class="language-Python">from django.views.decorators.cache import cache_page@api_view(('GET', ))@cache_page(timeout=86400, cache='default')def show_subjects(request):    &quot;&quot;&quot;获取学科数据&quot;&quot;&quot;    queryset = Subject.objects.all()    data = SubjectSerializer(queryset, many=True).data    return Response(&#123;'code': 20000, 'subjects': data&#125;)</code></pre><p>上面的代码通过 Django 封装的 <code>cache_page</code>  装饰器缓存了视图函数的返回值（响应对象）， <code>cache_page</code>  的本意是缓存视图函数渲染的页面，对于返回 JSON 数据的视图函数，相当于是缓存了 JSON 数据。在使用 <code>cache_page</code>  装饰器时，可以传入 <code>timeout</code>  参数来指定缓存过期时间，还可以使用 <code>cache</code>  参数来指定需要使用哪一组缓存服务来缓存数据。Django 项目允许在配置文件中配置多组缓存服务，上面的 <code>cache='default'</code>  指定了使用默认的缓存服务（因为之前的配置文件中我们也只配置了名为 <code>default</code>  的缓存服务）。视图函数的返回值会被序列化成字节串放到 Redis 中（Redis 中的 str 类型可以接收字节串），缓存数据的序列化和反序列化也不需要我们自己处理，因为 <code>cache_page</code>  装饰器会调用 <code>django-redis</code>  库中的 <code>RedisCache</code>  来对接 Redis，该类使用了 <code>DefaultClient</code>  来连接 Redis 并使用了<span class="exturl" data-url="aHR0cHM6Ly9weXRob24zLWNvb2tib29rLnJlYWR0aGVkb2NzLmlvL3poX0NOL2xhdGVzdC9jMDUvcDIxX3NlcmlhbGl6aW5nX3B5dGhvbl9vYmplY3RzLmh0bWw="> pickle 序列化</span>， <code>django_redis.serializers.pickle.PickleSerializer</code>  是默认的序列化类。</p><p>如果缓存中没有学科的数据，那么通过接口访问学科数据时，我们的视图函数会通过执行 <code>Subject.objects.all()</code>  向数据库发出 SQL 语句来获得数据，视图函数的返回值会被缓存，因此下次请求该视图函数如果缓存没有过期，可以直接从缓存中获取视图函数的返回值，无需再次查询数据库。如果想了解缓存的使用情况，可以配置数据库日志或者使用 Django-Debug-Toolbar 来查看，第一次访问学科数据接口时会看到查询学科数据的 SQL 语句，再次获取学科数据时，不会再向数据库发出 SQL 语句，因为可以直接从缓存中获取数据。</p><p>对于 CBV，可以利用 Django 中名为 <code>method_decorator</code>  的装饰器将 <code>cache_page</code>  这个装饰函数的装饰器放到类中的方法上，效果跟上面的代码是一样的。需要提醒大家注意的是， <code>cache_page</code>  装饰器不能直接放在类上，因为它是装饰函数的装饰器，所以 Django 框架才提供了 <code>method_decorator</code>  来解决这个问题，很显然， <code>method_decorator</code>  是一个装饰类的装饰器。</p><pre><code class="language-Python">from django.utils.decorators import method_decoratorfrom django.views.decorators.cache import cache_page@method_decorator(decorator=cache_page(timeout=86400, cache='default'), name='get')class SubjectView(ListAPIView):    &quot;&quot;&quot;获取学科数据的视图类&quot;&quot;&quot;    queryset = Subject.objects.all()    serializer_class = SubjectSerializer</code></pre><h4 id="编程式缓存"><a class="anchor" href="#编程式缓存">#</a> 编程式缓存</h4><p>所谓编程式缓存是指通过自己编写的代码来使用缓存服务，这种方式虽然代码量会稍微大一些，但是相较于声明式缓存，它对缓存的操作和使用更加灵活，在实际开发中使用得更多。下面的代码去掉了之前使用的 <code>cache_page</code>  装饰器，通过 <code>django-redis</code>  提供的 <code>get_redis_connection</code>  函数直接获取 Redis 连接来操作 Redis。</p><pre><code class="language-Python">def show_subjects(request):    &quot;&quot;&quot;获取学科数据&quot;&quot;&quot;    redis_cli = get_redis_connection()    # 先尝试从缓存中获取学科数据    data = redis_cli.get('vote:polls:subjects')    if data:        # 如果获取到学科数据就进行反序列化操作        data = json.loads(data)    else:        # 如果缓存中没有获取到学科数据就查询数据库        queryset = Subject.objects.all()        data = SubjectSerializer(queryset, many=True).data        # 将查到的学科数据序列化后放到缓存中        redis_cli.set('vote:polls:subjects', json.dumps(data), ex=86400)    return Response(&#123;'code': 20000, 'subjects': data&#125;)</code></pre><p>需要说明的是，Django 框架提供了 <code>cache</code>  和 <code>caches</code>  两个现成的变量来支持缓存操作，前者访问的是默认的缓存（名为 <code>default</code>  的缓存），后者可以通过索引运算获取指定的缓存服务（例如： <code>caches['default']</code> ）。向 <code>cache</code>  对象发送 <code>get</code>  和 <code>set</code>  消息就可以实现对缓存的读和写操作，但是这种方式能做的操作有限，不如上面代码中使用的方式灵活。还有一个值得注意的地方，由于可以通过 <code>get_redis_connection</code>  函数获得的 Redis 连接对象向 Redis 发起各种操作，包括 <code>FLUSHDB</code> 、 <code>SHUTDOWN</code>  等危险的操作，所以在实际商业项目开发中，一般都会对 <code>django-redis</code>  再做一次封装，例如封装一个工具类，其中只提供了项目需要用到的缓存操作的方法，从而避免了直接使用 <code>get_redis_connection</code>  的潜在风险。当然，自己封装对缓存的操作还可以使用 “Read Through” 和 “Write Through” 的方式实现对缓存的更新，这个在下面会介绍到。</p><h3 id="缓存相关问题"><a class="anchor" href="#缓存相关问题">#</a> 缓存相关问题</h3><h4 id="缓存数据的更新"><a class="anchor" href="#缓存数据的更新">#</a> 缓存数据的更新</h4><p>在使用缓存时，一个必须搞清楚的问题就是，当数据改变时，如何更新缓存中的数据。通常更新缓存有如下几种套路，分别是：</p><ol><li>Cache Aside Pattern</li><li>Read/Write Through Pattern</li><li>Write Behind Caching Pattern</li></ol><p>第 1 种方式的具体做法就是，当数据更新时，先更新数据库，再删除缓存。注意，不能够使用先更新数据库再更新缓存的方式，也不能够使用先删除缓存再更新数据库的方式，大家可以自己想一想为什么（考虑一下有并发的读操作和写操作的场景）。当然，先更新数据库再删除缓存的做法在理论上也存在风险，但是发生问题的概率是极低的，所以不少的项目都使用了这种方式。</p><p>第 1 种方式相当于编写业务代码的开发者要自己负责对两套存储系统（缓存和关系型数据库）的操作，代码写起来非常的繁琐。第 2 种方式的主旨是将后端的存储系统变成一套代码，对缓存的维护封装在这套代码中。其中，Read Through 指在查询操作中更新缓存，也就是说，当缓存失效的时候，由缓存服务自己负责对数据的加载，从而对应用方是透明的；而 Write Through 是指在更新数据时，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存服务自己更新数据库（同步更新）。刚才我们说过，如果自己对项目中的 Redis 操作再做一次封装，就可以实现 “Read Through” 和 “Write Through” 模式，这样做虽然会增加工作量，但无疑是一件 “一劳永逸” 且 “功在千秋” 的事情。</p><p>第 3 种方式是在更新数据的时候，只更新缓存，不更新数据库，而缓存服务这边会<strong>异步的批量更新</strong>数据库。这种做法会大幅度提升性能，但代价是牺牲数据的<strong>强一致性</strong>。第 3 种方式的实现逻辑比较复杂，因为他需要追踪有哪数据是被更新了的，然后再批量的刷新到持久层上。</p><h4 id="缓存穿透"><a class="anchor" href="#缓存穿透">#</a> 缓存穿透</h4><p>缓存是为了缓解数据库压力而添加的一个中间层，如果恶意的访问者频繁的访问缓存中没有的数据，那么缓存就失去了存在的意义，瞬间所有请求的压力都落在了数据库上，这样会导致数据库承载着巨大的压力甚至连接异常，类似于分布式拒绝服务攻击（DDoS）的做法。解决缓存穿透的一个办法是约定如果查询返回为空值，把这个空值也缓存起来，但是需要为这个空值的缓存设置一个较短的超时时间，毕竟缓存这样的值就是对缓存空间的浪费。另一个解决缓存穿透的办法是使用布隆过滤器，具体的做法大家可以自行了解。</p><h4 id="缓存击穿"><a class="anchor" href="#缓存击穿">#</a> 缓存击穿</h4><p>在实际的项目中，可能存在某个缓存的 key 某个时间点过期，但恰好在这个时间点对有对该 key 的大量的并发请求过来，这些请求没有从缓存中找到 key 对应的数据，就会直接从数据库中获取数据并写回到缓存，这个时候大并发的请求可能会瞬间把数据库压垮，这种现象称为缓存击穿。比较常见的解决缓存击穿的办法是使用互斥锁，简单的说就是在缓存失效的时候，不是立即去数据库加载数据，而是先设置互斥锁（例如：Redis 中的 setnx），只有设置互斥锁的操作成功的请求，才能执行查询从数据库中加载数据并写入缓存，其他设置互斥锁失败的请求，可以先执行一个短暂的休眠，然后尝试重新从缓存中获取数据，如果缓存还没有数据，则重复刚才的设置互斥锁的操作，大致的参考代码如下所示。</p><pre><code class="language-Python">data = redis_cli.get(key)while not data:    if redis_cli.setnx('mutex', 'x'):        redis.expire('mutex', timeout)        data = db.query(...)        redis.set(key, data)        redis.delete('mutex')    else:        time.sleep(0.1)        data = redis_cli.get(key)</code></pre><h4 id="缓存雪崩"><a class="anchor" href="#缓存雪崩">#</a> 缓存雪崩</h4><p>缓存雪崩是指在将数据放入缓存时采用了相同的过期时间，这样就导致缓存在某一时刻同时失效，请求全部转发到数据库，导致数据库瞬时压力过大而崩溃。解决缓存雪崩问题的方法也比较简单，可以在既定的缓存过期时间上加一个随机时间，这样可以从一定程度上避免不同的 key 在同一时间集体失效。还有一种办法就是使用多级缓存，每一级缓存的过期时间都不一样，这样的话即便某个级别的缓存集体失效，但是其他级别的缓存还能够提供数据，避免所有的请求都落到数据库上。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful架构和DRF进阶</title>
      <link href="/computer-science/python/basic/50.RESTful%E6%9E%B6%E6%9E%84%E5%92%8CDRF%E8%BF%9B%E9%98%B6/"/>
      <url>/computer-science/python/basic/50.RESTful%E6%9E%B6%E6%9E%84%E5%92%8CDRF%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="restful架构和drf进阶"><a class="anchor" href="#restful架构和drf进阶">#</a> RESTful 架构和 DRF 进阶</h2><p>除了上一节讲到的方法，使用 DRF 创建 REST 风格的数据接口也可以通过 CBV（基于类的视图）的方式。使用 CBV 创建数据接口的特点是代码简单，开发效率高，但是没有 FBV（基于函数的视图）灵活，因为使用 FBV 的方式，数据接口对应的视图函数执行什么样的代码以及返回什么的数据是高度可定制的。下面我们以定制学科的数据接口为例，讲解通过 CBV 方式定制数据接口的具体做法。</p><h3 id="使用cbv"><a class="anchor" href="#使用cbv">#</a> 使用 CBV</h3><h4 id="继承apiview的子类"><a class="anchor" href="#继承apiview的子类">#</a> 继承 APIView 的子类</h4><p>修改之前项目中的 <code>polls/views.py</code> ，去掉 <code>show_subjects</code>  视图函数，添加一个名为 <code>SubjectView</code>  的类，该类继承自 <code>ListAPIView</code> ， <code>ListAPIView</code>  能接收 GET 请求，它封装了获取数据列表并返回 JSON 数据的 <code>get</code>  方法。 <code>ListAPIView</code>  是 <code>APIView</code>  的子类， <code>APIView</code>  还有很多的子类，例如 <code>CreateAPIView</code>  可以支持 POST 请求， <code>UpdateAPIView</code>  可以支持 PUT 和 PATCH 请求， <code>DestoryAPIView</code>  可以支持 DELETE 请求。 <code>SubjectView</code>  的代码如下所示。</p><pre><code class="language-Python">from rest_framework.generics import ListAPIViewclass SubjectView(ListAPIView):    # 通过queryset指定如何获取学科数据    queryset = Subject.objects.all()    # 通过serializer_class指定如何序列化学科数据    serializer_class = SubjectSerializer</code></pre><p>刚才说过，由于 <code>SubjectView</code>  的父类 <code>ListAPIView</code>  已经实现了 <code>get</code>  方法来处理获取学科列表的 GET 请求，所以我们只需要声明如何获取学科数据以及如何序列化学科数据，前者用 <code>queryset</code>  属性指定，后者用 <code>serializer_class</code>  属性指定。要使用上面的 <code>SubjectView</code> ，需要修改 <code>urls.py</code>  文件，如下所示。</p><pre><code class="language-Python">urlpatterns = [    path('api/subjects/', SubjectView.as_view()),   ]</code></pre><p>很显然，上面的做法较之之前讲到的 FBV 要简单很多。</p><h4 id="继承modelviewset"><a class="anchor" href="#继承modelviewset">#</a> 继承 ModelViewSet</h4><p>如果学科对应的数据接口需要支持 GET、POST、PUT、PATCH、DELETE 请求来支持对学科资源的获取、新增、更新、删除操作，更为简单的做法是继承 <code>ModelViewSet</code>  来编写学科视图类。再次修改 <code>polls/views.py</code>  文件，去掉 <code>SubjectView</code>  类，添加一个名为 <code>SubjectViewSet</code>  的类，代码如下所示。</p><pre><code class="language-Python">from rest_framework.viewsets import ModelViewSetclass SubjectViewSet(ModelViewSet):    queryset = Subject.objects.all()    serializer_class = SubjectSerializer</code></pre><p>通过查看 <code>ModelViewSet</code>  类的源代码可以发现，该类共有 6 个父类，其中前 5 个父类分别实现对 POST（新增学科）、GET（获取指定学科）、PUT/PATCH（更新学科）、DELETE（删除学科）和 GET（获取学科列表）操作的支持，对应的方法分别是 <code>create</code> 、 <code>retrieve</code> 、 <code>update</code> 、 <code>destroy</code>  和 <code>list</code> 。由于 <code>ModelViewSet</code>  的父类中已经实现了这些方法，所以我们几乎没有编写任何代码就完成了学科数据全套接口的开发，我们要做的仅仅是指出如何获取到数据（通过 <code>queryset</code>  属性指定）以及如何序列化数据（通过 <code>serializer_class</code>  属性指定），这一点跟上面继承 <code>APIView</code>  的子类做法是一致的。</p><pre><code class="language-Python">class ModelViewSet(mixins.CreateModelMixin,                   mixins.RetrieveModelMixin,                   mixins.UpdateModelMixin,                   mixins.DestroyModelMixin,                   mixins.ListModelMixin,                   GenericViewSet):    &quot;&quot;&quot;    A viewset that provides default `create()`, `retrieve()`, `update()`,    `partial_update()`, `destroy()` and `list()` actions.    &quot;&quot;&quot;    pass</code></pre><p>要使用上面的 <code>SubjectViewSet</code> ，需要在 <code>urls.py</code>  文件中进行 URL 映射。由于 <code>ModelViewSet</code>  相当于是多个视图函数的汇总，所以不同于之前映射 URL 的方式，我们需要先创建一个路由器并通过它注册 <code>SubjectViewSet</code> ，然后将注册成功后生成的 URL 一并添加到 <code>urlspattern</code>  列表中，代码如下所示。</p><pre><code class="language-Python">from rest_framework.routers import DefaultRouterrouter = DefaultRouter()router.register('api/subjects', SubjectViewSet)urlpatterns += router.urls</code></pre><p>除了 <code>ModelViewSet</code>  类外，DRF 还提供了一个名为 <code>ReadOnlyModelViewSet</code>  的类，从名字上就可以看出，该类是只读视图的集合，也就意味着，继承该类定制的数据接口只能支持 GET 请求，也就是获取单个资源和资源列表的请求。</p><h3 id="数据分页"><a class="anchor" href="#数据分页">#</a> 数据分页</h3><p>在使用 GET 请求获取资源列表时，我们通常不会一次性的加载所有的数据，除非数据量真的很小。大多数获取资源列表的操作都支持数据分页展示，也就说我们可以通过指定页码（或类似于页码的标识）和页面大小（一次加载多少条数据）来获取不同的数据。我们可以通过对 <code>QuerySet</code>  对象的切片操作来实现分页，也可以利用 Django 框架封装的 <code>Paginator</code>  和 <code>Page</code>  对象来实现分页。使用 DRF 时，可以在 Django 配置文件中修改 <code>REST_FRAMEWORK</code>  并配置默认的分页类和页面大小来实现分页，如下所示。</p><pre><code class="language-Python">REST_FRAMEWORK = &#123;    'PAGE_SIZE': 10,    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination'&#125;</code></pre><p>除了上面配置的 <code>PageNumberPagination</code>  分页器之外，DRF 还提供了 <code>LimitOffsetPagination</code>  和 <code>CursorPagination</code>  分页器，值得一提的是 <code>CursorPagination</code> ，它可以避免使用页码分页时暴露网站的数据体量，有兴趣的读者可以自行了解。如果不希望使用配置文件中默认的分页设定，可以在视图类中添加一个 <code>pagination_class</code>  属性来重新指定分页器，通常可以将该属性指定为自定义的分页器，如下所示。</p><pre><code class="language-Python">from rest_framework.pagination import PageNumberPaginationclass CustomizedPagination(PageNumberPagination):    # 默认页面大小    page_size = 5    # 页面大小对应的查询参数    page_size_query_param = 'size'    # 页面大小的最大值    max_page_size = 50</code></pre><pre><code class="language-Python">class SubjectView(ListAPIView):    # 指定如何获取数据    queryset = Subject.objects.all()    # 指定如何序列化数据    serializer_class = SubjectSerializer    # 指定如何分页    pagination_class = CustomizedPagination</code></pre><p>如果不希望数据分页，可以将 <code>pagination_class</code>  属性设置为 <code>None</code>  来取消默认的分页器。</p><h3 id="数据筛选"><a class="anchor" href="#数据筛选">#</a> 数据筛选</h3><p>如果希望使用 CBV 定制获取老师信息的数据接口，也可以通过继承 <code>ListAPIView</code>  来实现。但是因为要通过指定的学科来获取对应的老师信息，因此需要对老师数据进行筛选而不是直接获取所有老师的数据。如果想从请求中获取学科编号并通过学科编号对老师进行筛选，可以通过重写 <code>get_queryset</code>  方法来做到，代码如下所示。</p><pre><code class="language-Python">class TeacherView(ListAPIView):    serializer_class = TeacherSerializer    def get_queryset(self):        queryset = Teacher.objects.defer('subject')        try:            sno = self.request.GET.get('sno', '')            queryset = queryset.filter(subject__no=sno)            return queryset        except ValueError:            raise Http404('No teachers found.')</code></pre><p>除了上述方式之外，还可以使用三方库 <code>django-filter</code>  来配合 DRF 实现对数据的筛选，使用 <code>django-filter</code>  后，可以通过为视图类配置 <code>filter-backends</code>  属性并指定使用 <code>DjangoFilterBackend</code>  来支持数据筛选。在完成上述配置后，可以使用 <code>filter_fields</code>  属性或 <code>filterset_class</code>  属性来指定如何筛选数据，有兴趣的读者可以自行研究。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful架构和DRF入门</title>
      <link href="/computer-science/python/basic/49.RESTful%E6%9E%B6%E6%9E%84%E5%92%8CDRF%E5%85%A5%E9%97%A8/"/>
      <url>/computer-science/python/basic/49.RESTful%E6%9E%B6%E6%9E%84%E5%92%8CDRF%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="restful架构和drf入门"><a class="anchor" href="#restful架构和drf入门">#</a> RESTful 架构和 DRF 入门</h2><p>把软件（Software）、平台（Platform）、基础设施（Infrastructure）做成服务（Service）是很多 IT 企业都一直在做的事情，这就是大家经常听到的 SasS（软件即服务）、PasS（平台即服务）和 IasS（基础设置即服务）。实现面向服务的架构（SOA）有诸多的方式，包括 RPC（远程过程调用）、Web Service、REST 等，在技术层面上，SOA 是一种<strong>抽象的、松散耦合的粗粒度软件架构</strong>；在业务层面上，SOA 的核心概念是 “<strong>重用</strong>” 和 “<strong>互操作</strong>”，它将系统资源整合成可操作的、标准的服务，使得这些资源能够被重新组合和应用。在实现 SOA 的诸多方案中，REST 被认为是最适合互联网应用的架构，符合 REST 规范的架构也经常被称作 RESTful 架构。</p><h3 id="rest概述"><a class="anchor" href="#rest概述">#</a> REST 概述</h3><p>REST 这个词，是<strong> Roy Thomas Fielding</strong> 在他 2000 年的博士论文中提出的，Roy 是 HTTP 协议（1.0 和 1.1 版）的主要设计者、Apache 服务器软件主要作者、Apache 基金会第一任主席。在他的博士论文中，Roy 把他对互联网软件的架构原则定名为 REST，即<strong> RE</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer 的缩写，中文通常翻译为 “<strong>表现层状态转移</strong>” 或 “<strong>表述状态转移</strong>”。</p><p>这里的 “表现层” 其实指的是 “资源” 的 “表现层”。所谓资源，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲或一种服务。我们可以用一个 URI（统一资源定位符）指向资源，要获取到这个资源，访问它的 URI 即可，URI 就是资源在互联网上的唯一标识。资源可以有多种外在表现形式。我们把资源具体呈现出来的形式，叫做它的 “表现层”。比如，文本可以用 <code>text/plain</code>  格式表现，也可以用 <code>text/html</code>  格式、 <code>text/xml</code>  格式、 <code>application/json</code>  格式表现，甚至可以采用二进制格式；图片可以用 <code>image/jpeg</code>  格式表现，也可以用 <code>image/png</code>  格式表现。URI 只代表资源的实体，不代表它的表现形式。严格地说，有些网址最后的 <code>.html</code>  后缀名是不必要的，因为这个后缀名表示格式，属于 “表现层” 范畴，而 URI 应该只代表 “资源” 的位置，它的具体表现形式，应该在 HTTP 请求的头信息中用 <code>Accept</code>  和 <code>Content-Type</code>  字段指定，这两个字段才是对 “表现层” 的描述。</p><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。Web 应用通常使用 HTTP 作为其通信协议，客户端想要操作服务器，必须通过 HTTP 请求，让服务器端发生 “状态转移”，而这种转移是建立在表现层之上的，所以就是 “表现层状态转移”。客户端通过 HTTP 的动词 GET、POST、PUT（或 PATCH）、DELETE，分别对应对资源的四种基本操作，其中 GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT（或 PATCH）用来更新资源，DELETE 用来删除资源。</p><p>简单的说 RESTful 架构就是：“每一个 URI 代表一种资源，客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现资源的表现层状态转移”。</p><p>我们在设计 Web 应用时，如果需要向客户端提供资源，就可以使用 REST 风格的 URI，这是实现 RESTful 架构的第一步。当然，真正的 RESTful 架构并不只是 URI 符合 REST 风格，更为重要的是 “无状态” 和 “幂等性” 两个词，我们在后面的课程中会为大家阐述这两点。下面的例子给出了一些符合 REST 风格的 URI，供大家在设计 URI 时参考。</p><table><thead><tr><th>请求方法（HTTP 动词）</th><th>URI</th><th>解释</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td><code>/students/</code></td><td>获取所有学生</td></tr><tr><td><strong>POST</strong></td><td><code>/students/</code></td><td>新建一个学生</td></tr><tr><td><strong>GET</strong></td><td><code>/students/ID/</code></td><td>获取指定 ID 的学生信息</td></tr><tr><td><strong>PUT</strong></td><td><code>/students/ID/</code></td><td>更新指定 ID 的学生信息（提供该学生的全部信息）</td></tr><tr><td><strong>PATCH</strong></td><td><code>/students/ID/</code></td><td>更新指定 ID 的学生信息（提供该学生的部分信息）</td></tr><tr><td><strong>DELETE</strong></td><td><code>/students/ID/</code></td><td>删除指定 ID 的学生信息</td></tr><tr><td><strong>GET</strong></td><td><code>/students/ID/friends/</code></td><td>列出指定 ID 的学生的所有朋友</td></tr><tr><td><strong>DELETE</strong></td><td><code>/students/ID/friends/ID/</code></td><td>删除指定 ID 的学生的指定 ID 的朋友</td></tr></tbody></table><h3 id="drf使用入门"><a class="anchor" href="#drf使用入门">#</a> DRF 使用入门</h3><p>在 Django 项目中，如果要实现 REST 架构，即将网站的资源发布成 REST 风格的 API 接口，可以使用著名的三方库 <code>djangorestframework</code>  ，我们通常将其简称为 DRF。</p><h4 id="安装和配置drf"><a class="anchor" href="#安装和配置drf">#</a> 安装和配置 DRF</h4><p>安装 DRF。</p><pre><code class="language-Shell">pip install djangorestframework</code></pre><p>配置 DRF。</p><pre><code class="language-Python">INSTALLED_APPS = [    'rest_framework',    ]# 下面的配置根据项目需要进行设置REST_FRAMEWORK = &#123;    # 配置默认页面大小    # 'PAGE_SIZE': 10,    # 配置默认的分页类    # 'DEFAULT_PAGINATION_CLASS': '...',    # 配置异常处理器    # 'EXCEPTION_HANDLER': '...',    # 配置默认解析器    # 'DEFAULT_PARSER_CLASSES': (    #     'rest_framework.parsers.JSONParser',    #     'rest_framework.parsers.FormParser',    #     'rest_framework.parsers.MultiPartParser',    # ),    # 配置默认限流类    # 'DEFAULT_THROTTLE_CLASSES': (    #     '...'    # ),    # 配置默认授权类    # 'DEFAULT_PERMISSION_CLASSES': (    #     '...',    # ),    # 配置默认认证类    # 'DEFAULT_AUTHENTICATION_CLASSES': (    #     '...',    # ),&#125;</code></pre><h4 id="编写序列化器"><a class="anchor" href="#编写序列化器">#</a> 编写序列化器</h4><p>前后端分离的开发需要后端为前端、移动端提供 API 数据接口，而 API 接口通常情况下都是返回 JSON 格式的数据，这就需要对模型对象进行序列化处理。DRF 中封装了 <code>Serializer</code>  类和 <code>ModelSerializer</code>  类用于实现序列化操作，通过继承 <code>Serializer</code>  类或 <code>ModelSerializer</code>  类，我们可以自定义序列化器，用于将对象处理成字典，代码如下所示。</p><pre><code class="language-Python">from rest_framework import serializers class SubjectSerializer(serializers.ModelSerializer):    class Meta:        model = Subject        fields = '__all__'</code></pre><p>上面的代码直接继承了 <code>ModelSerializer</code> ，通过 <code>Meta</code>  类的 <code>model</code>  属性指定要序列化的模型以及 <code>fields</code>  属性指定需要序列化的模型字段，稍后我们就可以在视图函数中使用该类来实现对 <code>Subject</code>  模型的序列化。</p><h4 id="编写视图函数"><a class="anchor" href="#编写视图函数">#</a> 编写视图函数</h4><p>DRF 框架支持两种实现数据接口的方式，一种是 FBV（基于函数的视图），另一种是 CBV（基于类的视图）。我们先看看 FBV 的方式如何实现数据接口，代码如下所示。</p><pre><code class="language-Python">from rest_framework.decorators import api_viewfrom rest_framework.response import Response@api_view(('GET', ))def show_subjects(request: HttpRequest) -&gt; HttpResponse:    subjects = Subject.objects.all().order_by('no')    # 创建序列化器对象并指定要序列化的模型    serializer = SubjectSerializer(subjects, many=True)    # 通过序列化器的data属性获得模型对应的字典并通过创建Response对象返回JSON格式的数据    return Response(serializer.data)</code></pre><p>对比上一个章节的使用 <code>bpmapper</code>  实现模型序列化的代码，使用 DRF 的代码更加简单明了，而且 DRF 本身自带了一套页面，可以方便我们查看我们使用 DRF 定制的数据接口，如下图所示。</p><p><img data-src="res/drf-app.png" alt="" /></p><p>直接使用上一节写好的页面，就可以通过 Vue.js 把上面接口提供的学科数据渲染并展示出来，此处不再进行赘述。</p><h4 id="实现老师信息数据接口"><a class="anchor" href="#实现老师信息数据接口">#</a> 实现老师信息数据接口</h4><p>编写序列化器。</p><pre><code class="language-Python">class SubjectSimpleSerializer(serializers.ModelSerializer):    class Meta:        model = Subject        fields = ('no', 'name')class TeacherSerializer(serializers.ModelSerializer):    class Meta:        model = Teacher        exclude = ('subject', )</code></pre><p>编写视图函数。</p><pre><code class="language-Python">@api_view(('GET', ))def show_teachers(request: HttpRequest) -&gt; HttpResponse:    try:        sno = int(request.GET.get('sno'))        subject = Subject.objects.only('name').get(no=sno)        teachers = Teacher.objects.filter(subject=subject).defer('subject').order_by('no')        subject_seri = SubjectSimpleSerializer(subject)        teacher_seri = TeacherSerializer(teachers, many=True)        return Response(&#123;'subject': subject_seri.data, 'teachers': teacher_seri.data&#125;)    except (TypeError, ValueError, Subject.DoesNotExist):        return Response(status=404)</code></pre><p>配置 URL 映射。</p><pre><code class="language-Python">urlpatterns = [        path('api/teachers/', show_teachers),    ]</code></pre><p>通过 Vue.js 渲染页面。</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;老师信息&lt;/title&gt;    &lt;style&gt;        /* 此处省略掉层叠样式表 */    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;h1&gt;&#123;&#123; subject.name &#125;&#125;学科的老师信息&lt;/h1&gt;        &lt;hr&gt;        &lt;h2 v-if=&quot;loaded &amp;&amp; teachers.length == 0&quot;&gt;暂无该学科老师信息&lt;/h2&gt;        &lt;div class=&quot;teacher&quot; v-for=&quot;teacher in teachers&quot;&gt;            &lt;div class=&quot;photo&quot;&gt;                &lt;img :src=&quot;'/static/images/' + teacher.photo&quot; height=&quot;140&quot; alt=&quot;&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;info&quot;&gt;                &lt;div&gt;                    &lt;span&gt;&lt;strong&gt;姓名：&#123;&#123; teacher.name &#125;&#125;&lt;/strong&gt;&lt;/span&gt;                    &lt;span&gt;性别：&#123;&#123; teacher.sex | maleOrFemale &#125;&#125;&lt;/span&gt;                    &lt;span&gt;出生日期：&#123;&#123; teacher.birth &#125;&#125;&lt;/span&gt;                &lt;/div&gt;                &lt;div class=&quot;intro&quot;&gt;&#123;&#123; teacher.intro &#125;&#125;&lt;/div&gt;                &lt;div class=&quot;comment&quot;&gt;                    &lt;a href=&quot;&quot; @click.prevent=&quot;vote(teacher, true)&quot;&gt;好评&lt;/a&gt;&amp;nbsp;&amp;nbsp;                    (&lt;strong&gt;&#123;&#123; teacher.good_count &#125;&#125;&lt;/strong&gt;)                    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                    &lt;a href=&quot;&quot; @click.prevent=&quot;vote(teacher, false)&quot;&gt;差评&lt;/a&gt;&amp;nbsp;&amp;nbsp;                    (&lt;strong&gt;&#123;&#123; teacher.bad_count &#125;&#125;&lt;/strong&gt;)                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;a href=&quot;/static/html/subjects.html&quot;&gt;返回首页&lt;/a&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        let app = new Vue(&#123;            el: '#container',            data: &#123;                subject: &#123;&#125;,                teachers: [],                loaded: false            &#125;,            created() &#123;                fetch('/api/teachers/' + location.search)                    .then(resp =&gt; resp.json())                    .then(json =&gt; &#123;                        this.subject = json.subject                        this.teachers = json.teachers                    &#125;)            &#125;,            filters: &#123;                maleOrFemale(sex) &#123;                    return sex? '男': '女'                &#125;            &#125;,            methods: &#123;               vote(teacher, flag) &#123;                    let url = flag? '/praise/' : '/criticize/'                    url += '?tno=' + teacher.no                    fetch(url).then(resp =&gt; resp.json()).then(json =&gt; &#123;                        if (json.code === 10000) &#123;                            if (flag) &#123;                                teacher.good_count = json.count                            &#125; else &#123;                                teacher.bad_count = json.count                            &#125;                        &#125;                    &#125;)                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="前后端分离下的用户登录"><a class="anchor" href="#前后端分离下的用户登录">#</a> 前后端分离下的用户登录</h3><p>之前我们提到过， HTTP 是无状态的，一次请求结束连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。但是对于一个 Web 应用而言，它是需要有状态管理的，这样才能让服务器知道 HTTP 请求来自哪个用户，从而判断是否允许该用户请求以及为用户提供更好的服务，这个过程就是常说的<strong>会话管理</strong>。</p><p>之前我们做会话管理（用户跟踪）的方法是：用户登录成功后，在服务器端通过一个 session 对象保存用户相关数据，然后把 session 对象的 ID 写入浏览器的 cookie 中；下一次请求时，HTTP 请求头中携带 cookie 的数据，服务器从 HTTP 请求头读取 cookie 中的 sessionid，根据这个标识符找到对应的 session 对象，这样就能够获取到之前保存在 session 中的用户数据。我们刚才说过，REST 架构是最适合互联网应用的架构，它强调了 HTTP 的无状态性，这样才能保证应用的水平扩展能力（当并发访问量增加时，可以通过增加新的服务器节点来为系统扩容）。显然，基于 session 实现用户跟踪的方式需要服务器保存 session 对象，在做水平扩展增加新的服务器节点时，需要复制和同步 session 对象，这显然是非常麻烦的。解决这个问题有两种方案，一种是架设缓存服务器（如 Redis），让多个服务器节点共享缓存服务并将 session 对象直接置于缓存服务器中；另一种方式放弃基于 session 的用户跟踪，使用<strong>基于 token 的用户跟踪</strong>。</p><p>基于 token 的用户跟踪是在用户登录成功后，为用户生成身份标识并保存在浏览器本地存储（localStorage、sessionStorage、cookie 等）中，这样的话服务器不需要保存用户状态，从而可以很容易的做到水平扩展。基于 token 的用户跟踪具体流程如下：</p><ol><li>用户登录时，如果登录成功就按照某种方式为用户生成一个令牌（token），该令牌中通常包含了用户标识、过期时间等信息而且需要加密并生成指纹（避免伪造或篡改令牌），服务器将令牌返回给前端；</li><li>前端获取到服务器返回的 token，保存在浏览器本地存储中（可以保存在 <code>localStorage</code>  或 <code>sessionStorage</code>  中，对于使用 Vue.js 的前端项目来说，还可以通过 Vuex 进行状态管理）；</li><li>对于使用了前端路由的项目来说，前端每次路由跳转，可以先判断 <code>localStroage</code>  中有无 token，如果没有则跳转到登录页；</li><li>每次请求后端数据接口，在 HTTP 请求头里携带 token；后端接口判断请求头有无 token，如果没有 token 以及 token 是无效的或过期的，服务器统一返回 401；</li><li>如果前端收到 HTTP 响应状态码 401，则重定向到登录页面。</li></ol><p>通过上面的描述，相信大家已经发现了，基于 token 的用户跟踪最为关键是在用户登录成功时，要为用户生成一个 token 作为用户的身份标识。生成 token 的方法很多，其中一种比较成熟的解决方案是使用 JSON Web Token。</p><h4 id="jwt概述"><a class="anchor" href="#jwt概述">#</a> JWT 概述</h4><p>JSON Web Token 通常简称为 JWT，它是一种开放标准（RFC 7519）。随着 RESTful 架构的流行，越来越多的项目使用 JWT 作为用户身份认证的方式。JWT 相当于是三个 JSON 对象经过编码后，用 <code>.</code>  分隔并组合到一起，这三个 JSON 对象分别是头部（header）、载荷（payload）和签名（signature），如下图所示。</p><p><img data-src="res/json-web-token.png" alt="" /></p><ol><li><p>头部</p><pre><code class="language-JSON">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;</code></pre><p>其中， <code>alg</code>  属性表示签名的算法，默认是 HMAC SHA256（简写成 <code>HS256</code> ）； <code>typ</code>  属性表示这个令牌的类型，JWT 中都统一书写为 <code>JWT</code> 。</p></li><li><p>载荷</p><p>载荷部分用来存放实际需要传递的数据。JWT 官方文档中规定了 7 个可选的字段：</p><ul><li>iss ：签发人</li><li>exp：过期时间</li><li>sub：主题</li><li>aud：受众</li><li>nbf：生效时间</li><li>iat：签发时间</li><li>jti：编号</li></ul><p>除了官方定义的字典，我们可以根据应用的需要添加自定义的字段，如下所示。</p><pre><code class="language-JSON">&#123;  &quot;sub&quot;: &quot;1234567890&quot;,  &quot;nickname&quot;: &quot;jackfrued&quot;,  &quot;role&quot;: &quot;admin&quot;&#125;</code></pre></li><li><p>签名</p><p>签名部分是对前面两部分生成一个指纹，防止数据伪造和篡改。实现签名首先需要指定一个密钥。这个密钥只有服务器才知道，不能泄露给用户。然后，使用头部指定的签名算法（默认是 <code>HS256</code> ），按照下面的公式产生签名。</p><pre><code class="language-Python">HS256(base64Encode(header) + '.' + base64Encode(payload), secret)</code></pre><p>算出签名以后，把头部、载荷、签名三个部分拼接成一个字符串，每个部分用 <code>.</code>  进行分隔，这样一个 JWT 就生成好了。</p></li></ol><h4 id="jwt的优缺点"><a class="anchor" href="#jwt的优缺点">#</a> JWT 的优缺点</h4><p>使用 JWT 的优点非常明显，包括：</p><ol><li>更容易实现水平扩展，因为令牌保存在浏览器中，服务器不需要做状态管理。</li><li>更容易防范 CSRF 攻击，因为在请求头中添加 <code>localStorage</code>  或 <code>sessionStorage</code>  中的 token 必须靠 JavaScript 代码完成，而不是自动添加到请求头中的。</li><li>可以防伪造和篡改，因为 JWT 有签名，伪造和篡改的令牌无法通过签名验证，会被认定是无效的令牌。</li></ol><p>当然，任何技术不可能只有优点没有缺点，JWT 也有诸多缺点，大家需要在使用的时候引起注意，具体包括：</p><ol><li>可能会遭受到 XSS 攻击（跨站脚本攻击），通过注入恶意脚本执行 JavaScript 代码获取到用户令牌。</li><li>在令牌过期之前，无法作废已经颁发的令牌，要解决这个问题，还需要额外的中间层和代码来辅助。</li><li>JWT 是用户的身份令牌，一旦泄露，任何人都可以获得该用户的所有权限。为了降低令牌被盗用后产生的风险，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应通过其他方式再次对用户进行认证，例如短信验证码等。</li></ol><h4 id="使用pyjwt"><a class="anchor" href="#使用pyjwt">#</a> 使用 PyJWT</h4><p>在 Python 代码中，可以使用三方库 <code>PyJWT</code>  生成和验证 JWT，下面是安装 <code>PyJWT</code>  的命令。</p><pre><code class="language-Bash">pip install pyjwt</code></pre><p>生成令牌。</p><pre><code class="language-Python">payload = &#123;    'exp': datetime.datetime.utcnow() + datetime.timedelta(days=1),    'userid': 10001&#125;token = jwt.encode(payload, settings.SECRET_KEY).decode()</code></pre><p>验证令牌。</p><pre><code class="language-Python">try:    token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1OTQ4NzIzOTEsInVzZXJpZCI6MTAwMDF9.FM-bNxemWLqQQBIsRVvc4gq71y42I9m2zt5nlFxNHUo'    payload = jwt.decode(token, settings.SECRET_KEY)except InvalidTokenError:    raise AuthenticationFailed('无效的令牌或令牌已经过期')</code></pre><p>如果不清楚 JWT 具体的使用方式，可以先看看第 55 天的内容，里面提供了完整的投票项目代码的地址。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离开发入门</title>
      <link href="/computer-science/python/basic/48.%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
      <url>/computer-science/python/basic/48.%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前后端分离开发入门"><a class="anchor" href="#前后端分离开发入门">#</a> 前后端分离开发入门</h2><p>在传统的 Web 应用开发中，大多数的程序员会将浏览器作为前后端的分界线。将浏览器中为用户进行页面展示的部分称之为前端，而将运行在服务器为前端提供业务逻辑和数据准备的所有代码统称为后端。所谓前后端分离的开发，就是前后端工程师约定好数据交互接口，并行的进行开发和测试，后端只提供数据，不负责将数据渲染到页面上，前端通过 HTTP 请求获取数据并负责将数据渲染到页面上，这个工作是交给浏览器中的 JavaScript 代码来完成。</p><p>使用前后端分离开发有诸多的好处，下面我们简要的说下这些好处：</p><ol><li><strong>提升开发效率</strong>。前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。在这种情况下，前后端工程师都可以只专注于自己的开发工作，有助于打造出更好的团队。除此之外，在前后端分离的开发模式下，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。</li><li><strong>增强代码的可维护性</strong>。前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系，这样的话维护代码的工作将变得轻松愉快很多，再不会牵一发而动全身。当你的代码变得简明且整洁时，代码的可读性和可维护性都会有质的提升。</li><li><strong>支持多终端和服务化架构</strong>。前后端分离后，同一套数据接口可以为不同的终端提供服务，更有助于打造多终端应用；此外，由于后端提供的接口之间可以通过 HTTP (S) 进行调用，有助于打造服务化架构（包括微服务）。</li></ol><p>接下来我们就用前后端分离的方式来改写之前的投票应用。</p><h3 id="返回json格式的数据"><a class="anchor" href="#返回json格式的数据">#</a> 返回 JSON 格式的数据</h3><p>刚才说过，在前后端分离的开发模式下，后端需要为前端提供数据接口，这些接口通常返回 JSON 格式的数据。在 Django 项目中，我们可以先将对象处理成字典，然后就可以利用 Django 封装的 <code>JsonResponse</code>  向浏览器返回 JSON 格式的数据，具体的做法如下所示。</p><pre><code class="language-Python">def show_subjects(request):    queryset = Subject.objects.all()    subjects = []    for subject in queryset:        subjects.append(&#123;            'no': subject.no,            'name': subject.name,            'intro': subject.intro,            'isHot': subject.is_hot        &#125;)    return JsonResponse(subjects, safe=False)</code></pre><p>上面的代码中，我们通过循环遍历查询学科得到的 <code>QuerySet</code>  对象，将每个学科的数据处理成一个字典，在将字典保存在名为 <code>subjects</code>  的列表容器中，最后利用 <code>JsonResponse</code>  完成对列表的序列化，向浏览器返回 JSON 格式的数据。由于 <code>JsonResponse</code>  序列化的是一个列表而不是字典，所以需要指定 <code>safe</code>  参数的值为 <code>False</code>  才能完成对 <code>subjects</code>  的序列化，否则会产生 <code>TypeError</code>  异常。</p><p>可能大家已经发现了，自己写代码将一个对象转成字典是比较麻烦的，如果对象的属性很多而且某些属性又关联到一个比较复杂的对象时，情况会变得更加糟糕。为此我们可以使用一个名为 <code>bpmappers</code>  的三方库来简化将对象转成字典的操作，这个三方库本身也提供了对 Django 框架的支持。</p><p>安装三方库 <code>bpmappers</code> 。</p><pre><code class="language-Shell">pip install bpmappers</code></pre><p>编写映射器（实现对象到字典转换）。</p><pre><code class="language-Python">from bpmappers.djangomodel import ModelMapperfrom poll2.models import Subjectclass SubjectMapper(ModelMapper):       class Meta:        model = Subject</code></pre><p>修改视图函数。</p><pre><code class="language-Python">def show_subjects(request):    queryset = Subject.objects.all()    subjects = []    for subject in queryset:        subjects.append(SubjectMapper(subject).as_dict())    return JsonResponse(subjects, safe=False)</code></pre><p>配置 URL 映射。</p><pre><code class="language-Python">urlpatterns = [        path('api/subjects/', show_subjects),    ]</code></pre><p>然后访问该接口，可以得到如下所示的 JSON 格式数据。</p><pre><code class="language-JSON">[    &#123;        &quot;no&quot;: 1,        &quot;name&quot;: &quot;Python全栈+人工智能&quot;,        &quot;intro&quot;: &quot;Python是一种计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。&quot;,        &quot;is_hot&quot;: true    &#125;,    // 此处省略下面的内容]</code></pre><p>如果不希望在 JSON 数据中显示学科的成立时间，我们可以在映射器中排除 <code>create_date</code>  属性；如果希望将是否为热门学科对应的键取名为 <code>isHot</code> （默认的名字是 <code>is_hot</code> ），也可以通过修改映射器来做到。具体的做法如下所示：</p><pre><code class="language-Python">from bpmappers import RawFieldfrom bpmappers.djangomodel import ModelMapperfrom poll2.models import Subjectclass SubjectMapper(ModelMapper):    isHot = RawField('is_hot')    class Meta:        model = Subject        exclude = ('is_hot', )</code></pre><p>再次查看学科接口返回的 JSON 数据。</p><pre><code class="language-JSON">[    &#123;        &quot;no&quot;: 101,        &quot;name&quot;: &quot;Python全栈+人工智能&quot;,        &quot;intro&quot;: &quot;Python是一种计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。&quot;,        &quot;isHot&quot;: true    &#125;,    // 此处省略下面的内容]</code></pre><p>关于 <code>bpmappers</code>  详细的使用指南，请参考它的<span class="exturl" data-url="aHR0cHM6Ly9icG1hcHBlcnMucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlLw==">官方文档</span>，这个官方文档是用日语书写的，可以使用浏览器的翻译功能将它翻译成你熟悉的语言即可。</p><h3 id="使用vuejs渲染页面"><a class="anchor" href="#使用vuejs渲染页面">#</a> 使用 Vue.js 渲染页面</h3><p>接下来我们通过前端框架 Vue.js 来实现页面的渲染。如果希望全面的了解和学习 Vue.js，建议阅读它的<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUv">官方教程</span>或者在<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20v"> YouTube</span> 上搜索 Vue.js 的新手教程（Vue.js Crash Course）进行学习。</p><p>重新改写 subjects.html 页面，使用 Vue.js 来渲染页面。</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;学科信息&lt;/title&gt;    &lt;style&gt;/* 此处省略层叠样式表 */    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;h1&gt;扣丁学堂所有学科&lt;/h1&gt;        &lt;hr&gt;        &lt;div id=&quot;main&quot;&gt;            &lt;dl v-for=&quot;subject in subjects&quot;&gt;                &lt;dt&gt;                    &lt;a :href=&quot;'/static/html/teachers.html?sno=' + subject.no&quot;&gt;                        &#123;&#123; subject.name &#125;&#125;                    &lt;/a&gt;                    &lt;img v-if=&quot;subject.is_hot&quot; src=&quot;/static/images/hot-icon-small.png&quot;&gt;                &lt;/dt&gt;                &lt;dd&gt;&#123;&#123; subject.intro &#125;&#125;&lt;/dd&gt;            &lt;/dl&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        let app = new Vue(&#123;            el: '#main',            data: &#123;                subjects: []            &#125;,            created() &#123;                fetch('/api/subjects/')                    .then(resp =&gt; resp.json())                    .then(json =&gt; &#123;                        this.subjects = json                    &#125;)            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>前后端分离的开发需要将前端页面作为静态资源进行部署，项目实际上线的时候，我们会对整个 Web 应用进行动静分离，静态资源通过 Nginx 或 Apache 服务器进行部署，生成动态内容的 Python 程序部署在 uWSGI 或者 Gunicorn 服务器上，对动态内容的请求由 Nginx 或 Apache 路由到 uWSGI 或 Gunicorn 服务器上。</p><p>在开发阶段，我们通常会使用 Django 自带的测试服务器，如果要尝试前后端分离，可以先将静态页面放在之前创建的放静态资源的目录下，具体的做法可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL2RqYW5nbzE5MDYy">项目完整代码</span>。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件的应用</title>
      <link href="/computer-science/python/basic/47.%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/computer-science/python/basic/47.%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="中间件的应用"><a class="anchor" href="#中间件的应用">#</a> 中间件的应用</h2><p>之前我们已经实现了用户必须登录才能投票的限制，但是一个新的问题来了。如果我们的应用中有很多功能都需要用户先登录才能执行，例如将前面导出 Excel 报表和查看统计图表的功能都做了必须登录才能访问的限制，那么我们是不是需要在每个视图函数中添加代码来检查 session 中是否包含 <code>userid</code>  的代码呢？答案是否定的，如果这样做了，我们的视图函数中必然会充斥着大量的重复代码。编程大师<em> Martin Fowler</em> 曾经说过：<strong>代码有很多种坏味道，重复是最坏的一种</strong>。在 Python 程序中，我们可以通过装饰器来为函数提供额外的能力；在 Django 项目中，我们可以把类似于验证用户是否登录这样的重复性代码放到<strong>中间件</strong>中。</p><h3 id="django中间件概述"><a class="anchor" href="#django中间件概述">#</a> Django 中间件概述</h3><p>中间件是安插在 Web 应用请求和响应过程之间的组件，它在整个 Web 应用中扮演了拦截过滤器的角色，通过中间件可以拦截请求和响应，并对请求和响应进行过滤（简单的说就是执行额外的处理）。通常，一个中间件组件只专注于完成一件特定的事，例如：Django 框架通过 <code>SessionMiddleware</code>  中间件实现了对 session 的支持，又通过 <code>AuthenticationMiddleware</code>  中间件实现了基于 session 的请求认证。通过把多个中间件组合在一起，我们可以完成更为复杂的任务，Django 框架就是这么做的。</p><p>Django 项目的配置文件中就包含了对中间件的配置，代码如下所示。</p><pre><code class="language-Python">MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',]</code></pre><p>我们稍微为大家解释一下这些中间件的作用：</p><ol><li><code>CommonMiddleware</code>  - 基础设置中间件，可以处理以下一些配置参数。<ul><li>DISALLOWED_USER_AGENTS - 不被允许的用户代理（浏览器）</li><li>APPEND_SLASH - 是否追加 <code>/</code></li><li>USE_ETAG - 浏览器缓存相关</li></ul></li><li><code>SecurityMiddleware</code>  - 安全相关中间件，可以处理和安全相关的配置项。<ul><li>SECURE_HSTS_SECONDS - 强制使用 HTTPS 的时间</li><li>SECURE_HSTS_INCLUDE_SUBDOMAINS - HTTPS 是否覆盖子域名</li><li>SECURE_CONTENT_TYPE_NOSNIFF - 是否允许浏览器推断内容类型</li><li>SECURE_BROWSER_XSS_FILTER - 是否启用跨站脚本攻击过滤器</li><li>SECURE_SSL_REDIRECT - 是否重定向到 HTTPS 连接</li><li>SECURE_REDIRECT_EXEMPT - 免除重定向到 HTTPS</li></ul></li><li><code>SessionMiddleware</code>  - 会话中间件。</li><li><code>CsrfViewMiddleware</code>  - 通过生成令牌，防范跨请求份伪的造中间件。</li><li><code>XFrameOptionsMiddleware</code>  - 通过设置请求头参数，防范点击劫持攻击的中间件。</li></ol><p>在请求的过程中，上面的中间件会按照书写的顺序从上到下执行，然后是 URL 解析，最后请求才会来到视图函数；在响应的过程中，上面的中间件会按照书写的顺序从下到上执行，与请求时中间件执行的顺序正好相反。</p><h3 id="自定义中间件"><a class="anchor" href="#自定义中间件">#</a> 自定义中间件</h3><p>Django 中的中间件有两种实现方式：基于类的实现方式和基于函数的实现方式，后者更接近于装饰器的写法。装饰器实际上是代理模式的应用，将横切关注功能（与正常业务逻辑没有必然联系的功能，例如：身份认证、日志记录、编码转换之类的功能）置于代理中，由代理对象来完成被代理对象的行为并添加额外的功能。中间件对用户请求和响应进行拦截过滤并增加额外的处理，在这一点上它跟装饰器是完全一致的，所以基于函数的写法来实现中间件就跟装饰器的写法几乎一模一样。下面我们用自定义的中间件来实现用户登录验证的功能。</p><pre><code class="language-Python">&quot;&quot;&quot;middlewares.py&quot;&quot;&quot;from django.http import JsonResponsefrom django.shortcuts import redirect# 需要登录才能访问的资源路径LOGIN_REQUIRED_URLS = &#123;'/praise/', '/criticize/', '/excel/', '/teachers_data/'&#125;def check_login_middleware(get_resp):    def wrapper(request, *args, **kwargs):        # 请求的资源路径在上面的集合中        if request.path in LOGIN_REQUIRED_URLS:            # 会话中包含userid则视为已经登录            if 'userid' not in request.session:                # 判断是不是Ajax请求                if request.is_ajax():                    # Ajax请求返回JSON数据提示用户登录                    return JsonResponse(&#123;'code': 10003, 'hint': '请先登录'&#125;)                else:                    backurl = request.get_full_path()                    # 非Ajax请求直接重定向到登录页                    return redirect(f'/login/?backurl=&#123;backurl&#125;')        return get_resp(request, *args, **kwargs)    return wrapper</code></pre><p>当然，我们也可以定义一个类来充当装饰器，如果类中有 <code>__call__</code> 魔术方法，这个类的对象就像函数一样可调用，所以下面是另一种实现中间件的方式，道理跟上面的代码完全一样。</p><p>还有一种基于类实现中间件的方式，这种方式在较新版本的 Django 中已经不推荐使用了，但是大家接触到的代码中，仍然有可能遇到这种写法，大致的代码如下所示。</p><pre><code class="language-Python">from django.utils.deprecation import MiddlewareMixinclass MyMiddleware(MiddlewareMixin):    def process_request(self, request):        pass    def process_view(self, request, view_func, view_args, view_kwargs):        pass    def process_template_response(self, request, response):        pass    def process_response(self, request, response):        pass    def process_exception(self, request, exception):        pass</code></pre><p>上面类中的五个方法都是中间件的钩子函数，分别在收到用户请求、进入视图函数之前、渲染模板、返回响应和出现异常的时候被回调。当然，写不写这些方法是根据中间件的需求来确定的，并不是所有的场景都需要重写五个方法，下面的图相信能够帮助大家理解这种写法。</p><p><img data-src="res/django-middleware.png" alt="" /></p><p>写好中间件代码后，需要修改配置文件来激活中间件使其生效。</p><pre><code class="language-Python">MIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',    'debug_toolbar.middleware.DebugToolbarMiddleware',    'vote.middlewares.check_login_middleware',]</code></pre><p>注意上面这个中间件列表中元素的顺序，当收到来自用户的请求时，中间件按照从上到下的顺序依次执行，这行完这些中间件以后，请求才会最终到达视图函数。当然，在这个过程中，用户的请求可以被拦截，就像上面我们自定义的中间件那样，如果用户在没有登录的情况下访问了受保护的资源，中间件会将请求直接重定向到登录页，后面的中间件和视图函数将不再执行。在响应用户请求的过程中，上面的中间件会按照从下到上的顺序依次执行，这样的话我们还可以对响应做进一步的处理。</p><p>中间件执行的顺序是非常重要的，对于有依赖关系的中间件必须保证被依赖的中间件要置于依赖它的中间件的前面，就好比我们刚才自定义的中间件要放到 <code>SessionMiddleware</code>  的后面，因为我们要依赖这个中间件为请求绑定的 <code>session</code>  对象才能判定用户是否登录。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志和调试工具栏</title>
      <link href="/computer-science/python/basic/46.%E6%97%A5%E5%BF%97%E5%92%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E6%A0%8F/"/>
      <url>/computer-science/python/basic/46.%E6%97%A5%E5%BF%97%E5%92%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="日志和调试工具栏"><a class="anchor" href="#日志和调试工具栏">#</a> 日志和调试工具栏</h2><h3 id="配置日志"><a class="anchor" href="#配置日志">#</a> 配置日志</h3><p>项目开发阶段，显示足够的调试信息以辅助开发人员调试代码还是非常必要的；项目上线以后，将系统运行时出现的警告、错误等信息记录下来以备相关人员了解系统运行状况并维护代码也是很有必要的。与此同时，采集日志数据也是为网站做数字化运营奠定一个基础，通过对系统运行日志的分析，我们可以监测网站的流量以及流量分布，同时还可以挖掘出用户的使用习惯和行为模式。</p><p>接下来，我们先看看如何通过 Django 的配置文件来配置日志。Django 的日志配置基本可以参照官方文档再结合项目实际需求来进行，这些内容基本上可以从官方文档上复制下来，然后进行局部的调整即可，下面给出一些参考配置。</p><pre><code class="language-Python">LOGGING = &#123;    'version': 1,    # 是否禁用已经存在的日志器    'disable_existing_loggers': False,    # 日志格式化器    'formatters': &#123;        'simple': &#123;            'format': '%(asctime)s %(module)s.%(funcName)s: %(message)s',            'datefmt': '%Y-%m-%d %H:%M:%S',        &#125;,        'verbose': &#123;            'format': '%(asctime)s %(levelname)s [%(process)d-%(threadName)s] '                      '%(module)s.%(funcName)s line %(lineno)d: %(message)s',            'datefmt': '%Y-%m-%d %H:%M:%S',        &#125;    &#125;,    # 日志过滤器    'filters': &#123;        # 只有在Django配置文件中DEBUG值为True时才起作用        'require_debug_true': &#123;            '()': 'django.utils.log.RequireDebugTrue',        &#125;,    &#125;,    # 日志处理器    'handlers': &#123;        # 输出到控制台        'console': &#123;            'class': 'logging.StreamHandler',            'level': 'DEBUG',            'filters': ['require_debug_true'],            'formatter': 'simple',        &#125;,        # 输出到文件(每周切割一次)        'file1': &#123;            'class': 'logging.handlers.TimedRotatingFileHandler',            'filename': 'access.log',            'when': 'W0',            'backupCount': 12,            'formatter': 'simple',            'level': 'INFO',        &#125;,        # 输出到文件(每天切割一次)        'file2': &#123;            'class': 'logging.handlers.TimedRotatingFileHandler',            'filename': 'error.log',            'when': 'D',            'backupCount': 31,            'formatter': 'verbose',            'level': 'WARNING',        &#125;,    &#125;,    # 日志器记录器    'loggers': &#123;        'django': &#123;            # 需要使用的日志处理器            'handlers': ['console', 'file1', 'file2'],            # 是否向上传播日志信息            'propagate': True,            # 日志级别(不一定是最终的日志级别)            'level': 'DEBUG',        &#125;,    &#125;&#125;</code></pre><p>大家可能已经注意到了，上面日志配置中的 <code>formatters</code>  是<strong>日志格式化器</strong>，它代表了如何格式化输出日志，其中格式占位符分别表示：</p><ol><li><code>%(name)s</code>  - 记录器的名称</li><li><code>%(levelno)s</code>  - 数字形式的日志记录级别</li><li><code>%(levelname)s</code>  - 日志记录级别的文本名称</li><li><code>%(filename)s</code>  - 执行日志记录调用的源文件的文件名称</li><li><code>%(pathname)s</code>  - 执行日志记录调用的源文件的路径名称</li><li><code>%(funcName)s</code>  - 执行日志记录调用的函数名称</li><li><code>%(module)s</code>  - 执行日志记录调用的模块名称</li><li><code>%(lineno)s</code>  - 执行日志记录调用的行号</li><li><code>%(created)s</code>  - 执行日志记录的时间</li><li><code>%(asctime)s</code>  - 日期和时间</li><li><code>%(msecs)s</code>  - 毫秒部分</li><li><code>%(thread)d</code>  - 线程 ID（整数）</li><li><code>%(threadName)s</code>  - 线程名称</li><li><code>%(process)d</code>  - 进程 ID （整数）</li></ol><p>日志配置中的 handlers 用来指定<strong>日志处理器</strong>，简单的说就是指定将日志输出到控制台还是文件又或者是网络上的服务器，可用的处理器包括：</p><ol><li><code>logging.StreamHandler(stream=None)</code>  - 可以向类似与 <code>sys.stdout</code>  或者 <code>sys.stderr</code>  的任何文件对象输出信息</li><li><code>logging.FileHandler(filename, mode='a', encoding=None, delay=False)</code>  - 将日志消息写入文件</li><li><code>logging.handlers.DatagramHandler(host, port)</code>  - 使用 UDP 协议，将日志信息发送到指定主机和端口的网络主机上</li><li><code>logging.handlers.HTTPHandler(host, url)</code>  - 使用 HTTP 的 GET 或 POST 方法将日志消息上传到一台 HTTP 服务器</li><li><code>logging.handlers.RotatingFileHandler(filename, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=False)</code>  - 将日志消息写入文件，如果文件的大小超出 <code>maxBytes</code>  指定的值，那么将重新生成一个文件来记录日志</li><li><code>logging.handlers.SocketHandler(host, port)</code>  - 使用 TCP 协议，将日志信息发送到指定主机和端口的网络主机上</li><li><code>logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None, timeout=1.0)</code>  - 将日志输出到指定的邮件地址</li><li><code>logging.MemoryHandler(capacity, flushLevel=ERROR, target=None, flushOnClose=True)</code>  - 将日志输出到内存指定的缓冲区中</li></ol><p>上面每个日志处理器都指定了一个名为 <code>level</code>  的属性，它代表了日志的级别，不同的日志级别反映出日志中记录信息的严重性。Python 中定义了六个级别的日志，按照从低到高的顺序依次是：NOTSET、DEBUG、INFO、WARNING、ERROR、CRITICAL。</p><p>最后配置的<strong>日志记录器</strong>是用来真正输出日志的，Django 框架提供了如下所示的内置记录器：</p><ol><li><code>django</code>  - 在 Django 层次结构中的所有消息记录器</li><li><code>django.request</code>  - 与请求处理相关的日志消息。5xx 响应被视为错误消息；4xx 响应被视为为警告消息</li><li><code>django.server</code>  - 与通过 runserver 调用的服务器所接收的请求相关的日志消息。5xx 响应被视为错误消息；4xx 响应被记录为警告消息；其他一切都被记录为 INFO</li><li><code>django.template</code>  - 与模板渲染相关的日志消息</li><li><code>django.db.backends</code>  - 有与数据库交互产生的日志消息，如果希望显示 ORM 框架执行的 SQL 语句，就可以使用该日志记录器。</li></ol><p>日志记录器中配置的日志级别有可能不是最终的日志级别，因为还要参考日志处理器中配置的日志级别，取二者中级别较高者作为最终的日志级别。</p><h3 id="配置django-debug-toolbar"><a class="anchor" href="#配置django-debug-toolbar">#</a> 配置 Django-Debug-Toolbar</h3><p>如果想调试你的 Django 项目，你一定不能不过名为 Django-Debug-Toolbar 的神器，它是项目开发阶段辅助调试和优化的必备工具，只要配置了它，就可以很方便的查看到如下表所示的项目运行信息，这些信息对调试项目和优化 Web 应用性能都是至关重要的。</p><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>Versions</td><td>Django 的版本</td></tr><tr><td>Time</td><td>显示视图耗费的时间</td></tr><tr><td>Settings</td><td>配置文件中设置的值</td></tr><tr><td>Headers</td><td>HTTP 请求头和响应头的信息</td></tr><tr><td>Request</td><td>和请求相关的各种变量及其信息</td></tr><tr><td>StaticFiles</td><td>静态文件加载情况</td></tr><tr><td>Templates</td><td>模板的相关信息</td></tr><tr><td>Cache</td><td>缓存的使用情况</td></tr><tr><td>Signals</td><td>Django 内置的信号信息</td></tr><tr><td>Logging</td><td>被记录的日志信息</td></tr><tr><td>SQL</td><td>向数据库发送的 SQL 语句及其执行时间</td></tr></tbody></table><ol><li><p>安装 Django-Debug-Toolbar。</p><pre><code class="language-Shell">pip install django-debug-toolbar</code></pre></li><li><p>配置 - <span class="exturl" data-url="aHR0cDovL3huLS1zZXR0aW5ncy0wbjNtbTI3by5weQ==">修改 settings.py</span>。</p><pre><code class="language-Python">INSTALLED_APPS = [    'debug_toolbar',]MIDDLEWARE = [    'debug_toolbar.middleware.DebugToolbarMiddleware',]DEBUG_TOOLBAR_CONFIG = &#123;    # 引入jQuery库    'JQUERY_URL': 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js',    # 工具栏是否折叠    'SHOW_COLLAPSED': True,    # 是否显示工具栏    'SHOW_TOOLBAR_CALLBACK': lambda x: True,&#125;</code></pre></li><li><p>配置 - <span class="exturl" data-url="aHR0cDovL3huLS11cmxzLTQ4NmZ4MTRpLnB5">修改 urls.py</span>。</p><pre><code class="language-Python">if settings.DEBUG:    import debug_toolbar    urlpatterns.insert(0, path('__debug__/', include(debug_toolbar.urls)))</code></pre></li><li><p>在配置好 Django-Debug-Toolbar 之后，页面右侧会看到一个调试工具栏，如下图所示，上面包括了如前所述的各种调试信息，包括执行时间、项目设置、请求头、SQL、静态资源、模板、缓存、信号等，查看起来非常的方便。</p><p><img data-src="res/debug-toolbar.png" alt="" /></p></li></ol><h3 id="优化orm代码"><a class="anchor" href="#优化orm代码">#</a> 优化 ORM 代码</h3><p>在配置了日志或 Django-Debug-Toolbar 之后，我们可以查看一下之前将老师数据导出成 Excel 报表的视图函数执行情况，这里我们关注的是 ORM 框架生成的 SQL 查询到底是什么样子的，相信这里的结果会让你感到有一些意外。执行 <code>Teacher.objects.all()</code>  之后我们可以注意到，在控制台看到的或者通过 Django-Debug-Toolbar 输出的 SQL 是下面这样的：</p><pre><code class="language-SQL">SELECT `tb_teacher`.`no`, `tb_teacher`.`name`, `tb_teacher`.`detail`, `tb_teacher`.`photo`, `tb_teacher`.`good_count`, `tb_teacher`.`bad_count`, `tb_teacher`.`sno` FROM `tb_teacher`; args=()SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 101; args=(101,)SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 101; args=(101,)SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 101; args=(101,)SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 101; args=(101,)SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 103; args=(103,)SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 103; args=(103,)</code></pre><p>这里的问题通常被称为 “1+N 查询”（有的地方也将其称之为 “N+1 查询”），原本获取老师的数据只需要一条 SQL，但是由于老师关联了学科，当我们查询到 <code>N</code>  条老师的数据时，Django 的 ORM 框架又向数据库发出了 <code>N</code>  条 SQL 去查询老师所属学科的信息。每条 SQL 执行都会有较大的开销而且会给数据库服务器带来压力，如果能够在一条 SQL 中完成老师和学科的查询肯定是更好的做法，这一点也很容易做到，相信大家已经想到怎么做了。是的，我们可以使用连接查询，但是在使用 Django 的 ORM 框架时如何做到这一点呢？对于多对一关联（如投票应用中的老师和学科），我们可以使用 <code>QuerySet</code>  的用 <code>select_related()</code>  方法来加载关联对象；而对于多对多关联（如电商网站中的订单和商品），我们可以使用 <code>prefetch_related()</code>  方法来加载关联对象。</p><p>在导出老师 Excel 报表的视图函数中，我们可以按照下面的方式优化代码。</p><pre><code class="language-Python">queryset = Teacher.objects.all().select_related('subject')</code></pre><p>事实上，用 ECharts 生成前端报表的视图函数中，查询老师好评和差评数据的操作也能够优化，因为在这个例子中，我们只需要获取老师的姓名、好评数和差评数这三项数据，但是在默认的情况生成的 SQL 会查询老师表的所有字段。可以用 <code>QuerySet</code>  的 <code>only()</code>  方法来指定需要查询的属性，也可以用 <code>QuerySet</code>  的 <code>defer()</code>  方法来指定暂时不需要查询的属性，这样生成的 SQL 会通过投影操作来指定需要查询的列，从而改善查询性能，代码如下所示：</p><pre><code class="language-Python">queryset = Teacher.objects.all().only('name', 'good_count', 'bad_count')</code></pre><p>当然，如果要统计出每个学科的老师好评和差评的平均数，利用 Django 的 ORM 框架也能够做到，代码如下所示：</p><pre><code class="language-Python">queryset = Teacher.objects.values('subject').annotate(good=Avg('good_count'), bad=Avg('bad_count'))</code></pre><p>这里获得的 <code>QuerySet</code>  中的元素是字典对象，每个字典中有三组键值对，分别是代表学科编号的 <code>subject</code> 、代表好评数的 <code>good</code>  和代表差评数的 <code>bad</code> 。如果想要获得学科的名称而不是编号，可以按照如下所示的方式调整代码：</p><pre><code class="language-Python">queryset = Teacher.objects.values('subject__name').annotate(good=Avg('good_count'), bad=Avg('bad_count'))</code></pre><p>可见，Django 的 ORM 框架允许我们用面向对象的方式完成关系数据库中的分组和聚合查询。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作报表</title>
      <link href="/computer-science/python/basic/45.%E5%88%B6%E4%BD%9C%E6%8A%A5%E8%A1%A8/"/>
      <url>/computer-science/python/basic/45.%E5%88%B6%E4%BD%9C%E6%8A%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="制作报表"><a class="anchor" href="#制作报表">#</a> 制作报表</h2><h3 id="导出excel报表"><a class="anchor" href="#导出excel报表">#</a> 导出 Excel 报表</h3><p>报表就是用表格、图表等格式来动态显示数据，所以有人用这样的公式来描述报表：</p><pre><code>报表 = 多样的格式 + 动态的数据</code></pre><p>有很多的三方库支持在 Python 程序中写 Excel 文件，包括<a href="https://xlwt.readthedocs.io/en/latest/"> <code>xlwt</code> </a>、<a href="https://docs.xlwings.org/en/latest/quickstart.html"> <code>xlwings</code> </a>、<a href="https://openpyxl.readthedocs.io/en/latest/"> <code>openpyxl</code> </a>、<a href="https://xlsxwriter.readthedocs.io/"> <code>xlswriter</code> </a> 等，其中的 xlwt 虽然只支持写 xls 格式的 Excel 文件，但在性能方面的表现还是不错的。下面我们就以 <code>xlwt</code>  为例，来演示如何在 Django 项目中导出 Excel 报表。</p><p>安装 <code>xlwt</code> 。</p><pre><code class="language-Bash">pip install xlwt</code></pre><p>导出包含所有老师信息的 Excel 表格的视图函数。</p><pre><code class="language-Python">def export_teachers_excel(request):    # 创建工作簿    wb = xlwt.Workbook()    # 添加工作表    sheet = wb.add_sheet('老师信息表')    # 查询所有老师的信息    queryset = Teacher.objects.all()    # 向Excel表单中写入表头    colnames = ('姓名', '介绍', '好评数', '差评数', '学科')    for index, name in enumerate(colnames):        sheet.write(0, index, name)    # 向单元格中写入老师的数据    props = ('name', 'detail', 'good_count', 'bad_count', 'subject')    for row, teacher in enumerate(queryset):        for col, prop in enumerate(props):            value = getattr(teacher, prop, '')            if isinstance(value, Subject):                value = value.name            sheet.write(row + 1, col, value)    # 保存Excel    buffer = BytesIO()    wb.save(buffer)    # 将二进制数据写入响应的消息体中并设置MIME类型    resp = HttpResponse(buffer.getvalue(), content_type='application/vnd.ms-excel')    # 中文文件名需要处理成百分号编码    filename = quote('老师.xls')    # 通过响应头告知浏览器下载该文件以及对应的文件名    resp['content-disposition'] = f'attachment; filename*=utf-8\'\'&#123;filename&#125;'    return resp</code></pre><p>映射 URL。</p><pre><code class="language-Python">urlpatterns = [        path('excel/', views.export_teachers_excel),    ]</code></pre><h3 id="导出pdf报表"><a class="anchor" href="#导出pdf报表">#</a> 导出 PDF 报表</h3><p>在 Django 项目中，如果需要导出 PDF 报表，可以借助三方库 <code>reportlab</code>  来生成 PDF 文件的内容，再将文件的二进制数据输出给浏览器并指定 MIME 类型为 <code>application/pdf</code> ，具体的代码如下所示。</p><pre><code class="language-Python">def export_pdf(request: HttpRequest) -&gt; HttpResponse:    buffer = io.BytesIO()    pdf = canvas.Canvas(buffer)    pdf.setFont(&quot;Helvetica&quot;, 80)    pdf.setFillColorRGB(0.2, 0.5, 0.3)    pdf.drawString(100, 550, 'hello, world!')    pdf.showPage()    pdf.save()    resp = HttpResponse(buffer.getvalue(), content_type='application/pdf')    resp['content-disposition'] = 'inline; filename=&quot;demo.pdf&quot;'    return resp</code></pre><p>关于如何用 <code>reportlab</code>  定制 PDF 报表的内容，可以参考 reportlab 的<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVwb3J0bGFiLmNvbS9kb2NzL3JlcG9ydGxhYi11c2VyZ3VpZGUucGRm">官方文档</span>。</p><h3 id="生成前端统计图表"><a class="anchor" href="#生成前端统计图表">#</a> 生成前端统计图表</h3><p>如果项目中需要生成前端统计图表，可以使用百度的<span class="exturl" data-url="aHR0cHM6Ly9lY2hhcnRzLmJhaWR1LmNvbS8="> ECharts</span>。具体的做法是后端通过提供数据接口返回统计图表所需的数据，前端使用 ECharts 来渲染出柱状图、折线图、饼图、散点图等图表。例如我们要生成一个统计所有老师好评数和差评数的报表，可以按照下面的方式来做。</p><pre><code class="language-Python">def get_teachers_data(request):    queryset = Teacher.objects.all()    names = [teacher.name for teacher in queryset]    good_counts = [teacher.good_count for teacher in queryset]    bad_counts = [teacher.bad_count for teacher in queryset]    return JsonResponse(&#123;'names': names, 'good': good_counts, 'bad': bad_counts&#125;)</code></pre><p>映射 URL。</p><pre><code class="language-Python">urlpatterns = [    path('teachers_data/', views.get_teachers_data),]</code></pre><p>使用 ECharts 生成柱状图。</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;老师评价统计&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;main&quot; style=&quot;width: 600px; height: 400px&quot;&gt;&lt;/div&gt;    &lt;p&gt;        &lt;a href=&quot;/&quot;&gt;返回首页&lt;/a&gt;    &lt;/p&gt;    &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var myChart = echarts.init(document.querySelector('#main'))        fetch('/teachers_data/')            .then(resp =&gt; resp.json())            .then(json =&gt; &#123;                var option = &#123;                    color: ['#f00', '#00f'],                    title: &#123;                        text: '老师评价统计图'                    &#125;,                    tooltip: &#123;&#125;,                    legend: &#123;                        data:['好评', '差评']                    &#125;,                    xAxis: &#123;                        data: json.names                    &#125;,                    yAxis: &#123;&#125;,                    series: [                        &#123;                            name: '好评',                            type: 'bar',                            data: json.good                        &#125;,                        &#123;                            name: '差评',                            type: 'bar',                            data: json.bad                        &#125;                    ]                &#125;                myChart.setOption(option)            &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行效果如下图所示。</p><p><img data-src="./res/echarts_bar_graph.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和Session</title>
      <link href="/computer-science/python/basic/44.Cookie%E5%92%8CSession/"/>
      <url>/computer-science/python/basic/44.Cookie%E5%92%8CSession/</url>
      
        <content type="html"><![CDATA[<h2 id="cookie和session"><a class="anchor" href="#cookie和session">#</a> Cookie 和 Session</h2><p>我们继续来完成上一章节中的项目，实现 “用户登录” 的功能，并限制只有登录的用户才能投票。</p><h3 id="用户登录的准备工作"><a class="anchor" href="#用户登录的准备工作">#</a> 用户登录的准备工作</h3><p>我们先为实现用户登录做一些准备工作。</p><ol><li><p>创建用户模型。之前我们讲解过如果通过 Django 的 ORM 实现从二维表到模型的转换（反向工程），这次我们尝试把模型变成二维表（正向工程）。</p><pre><code class="language-Python">class User(models.Model):    &quot;&quot;&quot;用户&quot;&quot;&quot;    no = models.AutoField(primary_key=True, verbose_name='编号')    username = models.CharField(max_length=20, unique=True, verbose_name='用户名')    password = models.CharField(max_length=32, verbose_name='密码')    tel = models.CharField(max_length=20, verbose_name='手机号')    reg_date = models.DateTimeField(auto_now_add=True, verbose_name='注册时间')    last_visit = models.DateTimeField(null=True, verbose_name='最后登录时间')    class Meta:        db_table = 'tb_user'        verbose_name = '用户'        verbose_name_plural = '用户'</code></pre></li><li><p>使用下面的命令生成迁移文件并执行迁移，将 <code>User</code>  模型直接变成关系型数据库中的二维表 <code>tb_user</code> 。</p><pre><code class="language-Bash">python manage.py makemigrations pollspython manage.py migrate polls</code></pre></li><li><p>用下面的 SQL 语句直接插入两条测试数据，通常不能将用户的密码直接保存在数据库中，因此我们将用户密码处理成对应的 MD5 摘要。MD5 消息摘要算法是一种被广泛使用的密码哈希函数（散列函数），可以产生出一个 128 位（比特）的哈希值（散列值），用于确保信息传输完整一致。在使用哈希值时，通常会将哈希值表示为 16 进制字符串，因此 128 位的 MD5 摘要通常表示为 32 个十六进制符号。</p><pre><code class="language-SQL">insert into `tb_user`    (`username`, `password`, `tel`, `reg_date`)values    ('wangdachui', '1c63129ae9db9c60c3e8aa94d3e00495', '13122334455', now()),    ('hellokitty', 'c6f8cf68e5f68b0aa4680e089ee4742c', '13890006789', now());</code></pre><blockquote><p><strong>说明</strong>：上面创建的两个用户 <code>wangdachui</code>  和 <code>hellokitty</code>  密码分别是 <code>1qaz2wsx</code>  和 <code>Abc123!!</code> 。</p></blockquote></li><li><p>我们在应用下增加一个名为 <code>utils.py</code>  的模块用来保存需要使用的工具函数。Python 标准库中的 <code>hashlib</code>  模块封装了常用的哈希算法，包括：MD5、SHA1、SHA256 等。下面是使用 <code>hashlib</code>  中的 <code>md5</code>  类将字符串处理成 MD5 摘要的函数如下所示。</p><pre><code class="language-Python">import hashlibdef gen_md5_digest(content):    return hashlib.md5(content.encode()).hexdigest()</code></pre></li><li><p>编写用户登录的视图函数和模板页。</p><p>添加渲染登录页面的视图函数：</p><pre><code class="language-Python">def login(request: HttpRequest) -&gt; HttpResponse:    hint = ''    return render(request, 'login.html', &#123;'hint': hint&#125;)</code></pre><p>增加 <code>login.html</code>  模板页：</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;用户登录&lt;/title&gt;    &lt;style&gt;        #container &#123;            width: 520px;            margin: 10px auto;        &#125;        .input &#123;            margin: 20px 0;            width: 460px;            height: 40px;        &#125;        .input&gt;label &#123;            display: inline-block;            width: 140px;            text-align: right;        &#125;        .input&gt;img &#123;            width: 150px;            vertical-align: middle;        &#125;        input[name=captcha] &#123;            vertical-align: middle;        &#125;        form+div &#123;            margin-top: 20px;        &#125;        form+div&gt;a &#123;            text-decoration: none;            color: darkcyan;            font-size: 1.2em;        &#125;        .button &#123;            width: 500px;            text-align: center;            margin-top: 20px;        &#125;        .hint &#123;            color: red;            font-size: 12px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;h1&gt;用户登录&lt;/h1&gt;        &lt;hr&gt;        &lt;p class=&quot;hint&quot;&gt;&#123;&#123; hint &#125;&#125;&lt;/p&gt;        &lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt;            &#123;% csrf_token %&#125;            &lt;fieldset&gt;                &lt;legend&gt;用户信息&lt;/legend&gt;                &lt;div class=&quot;input&quot;&gt;                    &lt;label&gt;用户名：&lt;/label&gt;                    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;                &lt;/div&gt;                &lt;div class=&quot;input&quot;&gt;                    &lt;label&gt;密码：&lt;/label&gt;                    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;                &lt;/div&gt;                &lt;div class=&quot;input&quot;&gt;                    &lt;label&gt;验证码：&lt;/label&gt;                    &lt;input type=&quot;text&quot; name=&quot;captcha&quot;&gt;                    &lt;img id=&quot;code&quot; src=&quot;/captcha/&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;40&quot;&gt;                &lt;/div&gt;            &lt;/fieldset&gt;            &lt;div class=&quot;button&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;                &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;            &lt;/div&gt;        &lt;/form&gt;        &lt;div&gt;            &lt;a href=&quot;/&quot;&gt;返回首页&lt;/a&gt;            &lt;a href=&quot;/register/&quot;&gt;注册新用户&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>注意，在上面的表单中，我们使用了模板指令 <code>&#123;% csrf_token %&#125;</code>  为表单添加一个隐藏域（大家可以在浏览器中显示网页源代码就可以看到这个指令生成的 <code>type</code>  属性为 <code>hidden</code>  的 <code>input</code>  标签），它的作用是在表单中生成一个随机令牌（token）来防范<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUE4JUU3JUFCJTk5JUU4JUFGJUI3JUU2JUIxJTgyJUU0JUJDJUFBJUU5JTgwJUEw">跨站请求伪造</span>（简称为 CSRF），这也是 Django 在提交表单时的硬性要求。如果我们的表单中没有这样的令牌，那么提交表单时，Django 框架会产生一个响应状态码为 <code>403</code>  的响应（禁止访问），除非我们设置了免除 CSRF 令牌。下图是一个关于 CSRF 简单生动的例子。</p><p><img data-src="./res/csrf-simple.png" alt="" /></p></li></ol><p>接下来，我们可以编写提供验证码和实现用户登录的视图函数，在此之前，我们先说说一个 Web 应用实现用户跟踪的方式以及 Django 框架对实现用户跟踪所提供的支持。对一个 Web 应用来说，用户登录成功后必然要让服务器能够记住该用户已经登录，这样服务器才能为这个用户提供更好的服务，而且上面说到的 CSRF 也是通过钓鱼网站来套取用户登录信息进行恶意操作的攻击手段，这些都是以用户跟踪技术为基础的。在理解了这些背景知识后，我们就清楚用户登录时到底需要执行哪些操作。</p><h3 id="实现用户跟踪"><a class="anchor" href="#实现用户跟踪">#</a> 实现用户跟踪</h3><p>如今，一个网站如果不通过某种方式记住你是谁以及你之前在网站的活动情况，失去的就是网站的可用性和便利性，继而很有可能导致网站用户的流式，所以记住一个用户（更专业的说法叫<strong>用户跟踪</strong>）对绝大多数 Web 应用来说都是必需的功能。</p><p>在服务器端，我们想记住一个用户最简单的办法就是创建一个对象，通过这个对象就可以把用户相关的信息都保存起来，这个对象就是我们常说的 session（用户会话对象）。那么问题来了，HTTP 本身是一个<strong>无连接</strong>（每次请求和响应的过程中，服务器一旦完成对客户端请求的响应之后就断开连接）、<strong>无状态</strong>（客户端再次发起对服务器的请求时，服务器无法得知这个客户端之前的任何信息）的协议，即便服务器通过 session 对象保留了用户数据，还得通过某种方式来确定当前的请求与之前保存过的哪一个 session 是有关联的。相信很多人都能想到，我们可以给每个 session 对象分配一个全局唯一的标识符来识别 session 对象，我们姑且称之为 sessionid，每次客户端发起请求时，只要携带上这个 sessionid，就有办法找到与之对应的 session 对象，从而实现在两次请求之间记住该用户的信息，也就是我们之前说的用户跟踪。</p><p>要让客户端记住并在每次请求时带上 sessionid 又有以下几种做法：</p><ol><li><p>URL 重写。所谓 URL 重写就是在 URL 中携带 sessionid，例如： <code>http://www.example.com/index.html?sessionid=123456</code> ，服务器通过获取 sessionid 参数的值来取到与之对应的 session 对象。</p></li><li><p>隐藏域（隐式表单域）。在提交表单的时候，可以通过在表单中设置隐藏域向服务器发送额外的数据。例如： <code>&lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;123456&quot;&gt;</code> 。</p></li><li><p>本地存储。现在的浏览器都支持多种本地存储方案，包括：cookie、localStorage、sessionStorage、IndexedDB 等。在这些方案中，cookie 是历史最为悠久也是被诟病得最多的一种方案，也是我们接下来首先为大家讲解的一种方案。简单的说，cookie 是一种以键值对方式保存在浏览器临时文件中的数据，每次请求时，请求头中会携带本站点的 cookie 到服务器，那么只要将 sessionid 写入 cookie，下次请求时服务器只要读取请求头中的 cookie 就能够获得这个 sessionid，如下图所示。</p><p><img data-src="./res/sessionid_from_cookie.png" alt="" /></p><p>在 HTML5 时代要，除了 cookie，还可以使用新的本地存储 API 来保存数据，就是刚才提到的 localStorage、sessionStorage、IndexedDB 等技术，如下图所示。</p><p><img data-src="./res/cookie_xstorage_indexeddb.png" alt="" /></p></li></ol><p><strong>总结一下</strong>，要实现用户跟踪，服务器端可以为每个用户会话创建一个 session 对象并将 session 对象的 ID 写入到浏览器的 cookie 中；用户下次请求服务器时，浏览器会在 HTTP 请求头中携带该网站保存的 cookie 信息，这样服务器就可以从 cookie 中找到 session 对象的 ID 并根据此 ID 获取到之前创建的 session 对象；由于 session 对象可以用键值对的方式保存用户数据，这样之前保存在 session 对象中的信息可以悉数取出，服务器也可以根据这些信息判定用户身份和了解用户偏好，为用户提供更好的个性化服务。</p><h3 id="django框架对session的支持"><a class="anchor" href="#django框架对session的支持">#</a> Django 框架对 session 的支持</h3><p>在创建 Django 项目时，默认的配置文件 <code>settings.py</code>  文件中已经激活了一个名为 <code>SessionMiddleware</code>  的中间件（关于中间件的知识我们在后面的章节做详细讲解，这里只需要知道它的存在即可），因为这个中间件的存在，我们可以直接通过请求对象的 <code>session</code>  属性来操作会话对象。前面我们说过， <code>session</code>  属性是一个像字典一样可以读写数据的容器对象，因此我们可以使用 “键值对” 的方式来保留用户数据。与此同时， <code>SessionMiddleware</code>  中间件还封装了对 cookie 的操作，在 cookie 中保存了 sessionid，这一点我们在上面已经提到过了。</p><p>在默认情况下，Django 将 session 的数据序列化后保存在关系型数据库中，在 Django 1.6 以后的版本中，默认的序列化数据的方式是 JSON 序列化，而在此之前一直使用 Pickle 序列化。JSON 序列化和 Pickle 序列化的差别在于前者将对象序列化为字符串（字符形式），而后者将对象序列化为字节串（二进制形式），因为安全方面的原因，JSON 序列化成为了目前 Django 框架默认序列化数据的方式，这就要求在我们保存在 session 中的数据必须是能够 JSON 序列化的，否则就会引发异常。还有一点需要说明的是，使用关系型数据库保存 session 中的数据在大多数时候并不是最好的选择，因为数据库可能会承受巨大的压力而成为系统性能的瓶颈，在后面的章节中我们会告诉大家如何将 session 保存到缓存服务中以提升系统的性能。</p><h3 id="实现用户登录验证"><a class="anchor" href="#实现用户登录验证">#</a> 实现用户登录验证</h3><p>首先，我们在刚才的 <code>polls/utils.py</code>  文件中编写生成随机验证码的函数 <code>gen_random_code</code> ，内容如下所示。</p><pre><code class="language-Python">import randomALL_CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'def gen_random_code(length=4):    return ''.join(random.choices(ALL_CHARS, k=length))</code></pre><p>编写生成验证码图片的类 <code>Captcha</code> 。</p><pre><code class="language-Python">&quot;&quot;&quot;图片验证码&quot;&quot;&quot;import osimport randomfrom io import BytesIOfrom PIL import Imagefrom PIL import ImageFilterfrom PIL.ImageDraw import Drawfrom PIL.ImageFont import truetypeclass Bezier:    &quot;&quot;&quot;贝塞尔曲线&quot;&quot;&quot;    def __init__(self):        self.tsequence = tuple([t / 20.0 for t in range(21)])        self.beziers = &#123;&#125;    def make_bezier(self, n):        &quot;&quot;&quot;绘制贝塞尔曲线&quot;&quot;&quot;        try:            return self.beziers[n]        except KeyError:            combinations = pascal_row(n - 1)            result = []            for t in self.tsequence:                tpowers = (t ** i for i in range(n))                upowers = ((1 - t) ** i for i in range(n - 1, -1, -1))                coefs = [c * a * b for c, a, b in zip(combinations,                                                      tpowers, upowers)]                result.append(coefs)            self.beziers[n] = result            return resultclass Captcha:    &quot;&quot;&quot;验证码&quot;&quot;&quot;    def __init__(self, width, height, fonts=None, color=None):        self._image = None        self._fonts = fonts if fonts else \            [os.path.join(os.path.dirname(__file__), 'fonts', font)             for font in ['Arial.ttf', 'Georgia.ttf', 'Action.ttf']]        self._color = color if color else random_color(0, 200, random.randint(220, 255))        self._width, self._height = width, height    @classmethod    def instance(cls, width=200, height=75):        &quot;&quot;&quot;用于获取Captcha对象的类方法&quot;&quot;&quot;        prop_name = f'_instance_&#123;width&#125;_&#123;height&#125;'        if not hasattr(cls, prop_name):            setattr(cls, prop_name, cls(width, height))        return getattr(cls, prop_name)    def _background(self):        &quot;&quot;&quot;绘制背景&quot;&quot;&quot;        Draw(self._image).rectangle([(0, 0), self._image.size],                                    fill=random_color(230, 255))    def _smooth(self):        &quot;&quot;&quot;平滑图像&quot;&quot;&quot;        return self._image.filter(ImageFilter.SMOOTH)    def _curve(self, width=4, number=6, color=None):        &quot;&quot;&quot;绘制曲线&quot;&quot;&quot;        dx, height = self._image.size        dx /= number        path = [(dx * i, random.randint(0, height))                for i in range(1, number)]        bcoefs = Bezier().make_bezier(number - 1)        points = []        for coefs in bcoefs:            points.append(tuple(sum([coef * p for coef, p in zip(coefs, ps)])                                for ps in zip(*path)))        Draw(self._image).line(points, fill=color if color else self._color, width=width)    def _noise(self, number=50, level=2, color=None):        &quot;&quot;&quot;绘制扰码&quot;&quot;&quot;        width, height = self._image.size        dx, dy = width / 10, height / 10        width, height = width - dx, height - dy        draw = Draw(self._image)        for i in range(number):            x = int(random.uniform(dx, width))            y = int(random.uniform(dy, height))            draw.line(((x, y), (x + level, y)),                      fill=color if color else self._color, width=level)    def _text(self, captcha_text, fonts, font_sizes=None, drawings=None, squeeze_factor=0.75, color=None):        &quot;&quot;&quot;绘制文本&quot;&quot;&quot;        color = color if color else self._color        fonts = tuple([truetype(name, size)                       for name in fonts                       for size in font_sizes or (65, 70, 75)])        draw = Draw(self._image)        char_images = []        for c in captcha_text:            font = random.choice(fonts)            c_width, c_height = draw.textsize(c, font=font)            char_image = Image.new('RGB', (c_width, c_height), (0, 0, 0))            char_draw = Draw(char_image)            char_draw.text((0, 0), c, font=font, fill=color)            char_image = char_image.crop(char_image.getbbox())            for drawing in drawings:                d = getattr(self, drawing)                char_image = d(char_image)            char_images.append(char_image)        width, height = self._image.size        offset = int((width - sum(int(i.size[0] * squeeze_factor)                                  for i in char_images[:-1]) -                      char_images[-1].size[0]) / 2)        for char_image in char_images:            c_width, c_height = char_image.size            mask = char_image.convert('L').point(lambda i: i * 1.97)            self._image.paste(char_image,                              (offset, int((height - c_height) / 2)),                              mask)            offset += int(c_width * squeeze_factor)    @staticmethod    def _warp(image, dx_factor=0.3, dy_factor=0.3):        &quot;&quot;&quot;图像扭曲&quot;&quot;&quot;        width, height = image.size        dx = width * dx_factor        dy = height * dy_factor        x1 = int(random.uniform(-dx, dx))        y1 = int(random.uniform(-dy, dy))        x2 = int(random.uniform(-dx, dx))        y2 = int(random.uniform(-dy, dy))        warp_image = Image.new(            'RGB',            (width + abs(x1) + abs(x2), height + abs(y1) + abs(y2)))        warp_image.paste(image, (abs(x1), abs(y1)))        width2, height2 = warp_image.size        return warp_image.transform(            (width, height),            Image.QUAD,            (x1, y1, -x1, height2 - y2, width2 + x2, height2 + y2, width2 - x2, -y1))    @staticmethod    def _offset(image, dx_factor=0.1, dy_factor=0.2):        &quot;&quot;&quot;图像偏移&quot;&quot;&quot;        width, height = image.size        dx = int(random.random() * width * dx_factor)        dy = int(random.random() * height * dy_factor)        offset_image = Image.new('RGB', (width + dx, height + dy))        offset_image.paste(image, (dx, dy))        return offset_image    @staticmethod    def _rotate(image, angle=25):        &quot;&quot;&quot;图像旋转&quot;&quot;&quot;        return image.rotate(random.uniform(-angle, angle),                            Image.BILINEAR, expand=1)    def generate(self, captcha_text='', fmt='PNG'):        &quot;&quot;&quot;生成验证码(文字和图片)        :param captcha_text: 验证码文字        :param fmt: 生成的验证码图片格式        :return: 验证码图片的二进制数据        &quot;&quot;&quot;        self._image = Image.new('RGB', (self._width, self._height), (255, 255, 255))        self._background()        self._text(captcha_text, self._fonts,                   drawings=['_warp', '_rotate', '_offset'])        self._curve()        self._noise()        self._smooth()        image_bytes = BytesIO()        self._image.save(image_bytes, format=fmt)        return image_bytes.getvalue()def pascal_row(n=0):    &quot;&quot;&quot;生成毕达哥拉斯三角形（杨辉三角）&quot;&quot;&quot;    result = [1]    x, numerator = 1, n    for denominator in range(1, n // 2 + 1):        x *= numerator        x /= denominator        result.append(x)        numerator -= 1    if n &amp; 1 == 0:        result.extend(reversed(result[:-1]))    else:        result.extend(reversed(result))    return resultdef random_color(start=0, end=255, opacity=255):    &quot;&quot;&quot;获得随机颜色&quot;&quot;&quot;    red = random.randint(start, end)    green = random.randint(start, end)    blue = random.randint(start, end)    if opacity is None:        return red, green, blue    return red, green, blue, opacity</code></pre><blockquote><p><strong>说明</strong>：上面的代码中用到了三个字体文件，字体文件位于 <code>polls/fonts</code>  目录下，大家可以自行添加字体文件，但是需要注意字体文件的文件名跟上面代码的第 45 行保持一致。</p></blockquote><p>接下来，我们先完成提供验证码的视图函数。</p><pre><code class="language-Python">def get_captcha(request: HttpRequest) -&gt; HttpResponse:    &quot;&quot;&quot;验证码&quot;&quot;&quot;    captcha_text = gen_random_code()    request.session['captcha'] = captcha_text    image_data = Captcha.instance().generate(captcha_text)    return HttpResponse(image_data, content_type='image/png')</code></pre><p>注意上面代码中的第 4 行，我们将随机生成的验证码字符串保存到 session 中，稍后用户登录时，我们要将保存在 session 中的验证码字符串和用户输入的验证码字符串进行比对，如果用户输入了正确的验证码才能够执行后续的登录流程，代码如下所示。</p><pre><code class="language-Python">def login(request: HttpRequest) -&gt; HttpResponse:    hint = ''    if request.method == 'POST':        username = request.POST.get('username')        password = request.POST.get('password')        if username and password:            password = gen_md5_digest(password)            user = User.objects.filter(username=username, password=password).first()            if user:                request.session['userid'] = user.no                request.session['username'] = user.username                return redirect('/')            else:                hint = '用户名或密码错误'        else:            hint = '请输入有效的用户名和密码'    return render(request, 'login.html', &#123;'hint': hint&#125;)</code></pre><blockquote><p><strong>说明</strong>：上面的代码没有对用户名和密码没有进行验证，实际项目中建议使用正则表达式验证用户输入信息，否则有可能将无效的数据交给数据库进行处理或者造成其他安全方面的隐患。</p></blockquote><p>上面的代码中，我们设定了登录成功后会在 session 中保存用户的编号（ <code>userid</code> ）和用户名（ <code>username</code> ），页面会重定向到首页。接下来我们可以稍微对首页的代码进行调整，在页面的右上角显示出登录用户的用户名。我们将这段代码单独写成了一个名为 header.html 的 HTML 文件，首页中可以通过在 <code>&lt;body&gt;</code>  标签中添加 <code>&#123;% include 'header.html' %&#125;</code>  来包含这个页面，代码如下所示。</p><pre><code class="language-HTML">&lt;div class=&quot;user&quot;&gt;    &#123;% if request.session.userid %&#125;    <span>&#123;&#123; request.session.username &#125;&#125;</span>    <a href="/logout">注销</a>    &#123;% else %&#125;    <a href="/login">登录</a>&nbsp;&nbsp;    &#123;% endif %&#125;    &lt;a href=&quot;/register&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;</code></pre><p>如果用户没有登录，页面会显示登录和注册的超链接；而用户登录成功后，页面上会显示用户名和注销的链接，注销链接对应的视图函数如下所示，URL 的映射与之前讲过的类似，不再赘述。</p><pre><code class="language-Python">def logout(request):    &quot;&quot;&quot;注销&quot;&quot;&quot;    request.session.flush()    return redirect('/')</code></pre><p>上面的代码通过 session 对象 <code>flush</code>  方法来销毁 session，一方面清除了服务器上 session 对象保存的用户数据，一方面将保存在浏览器 cookie 中的 sessionid 删除掉，稍后我们会对如何读写 cookie 的操作加以说明。</p><p>我们可以通过项目使用的数据库中名为 <code>django_session</code>  的表来找到所有的 session，该表的结构如下所示：</p><table><thead><tr><th>session_key</th><th>session_data</th><th>expire_date</th></tr></thead><tbody><tr><td>c9g2gt5cxo0k2evykgpejhic5ae7bfpl</td><td>MmI4YzViYjJhOGMyMDJkY2M5Yzg3...</td><td>2019-05-25 23:16:13.898522</td></tr></tbody></table><p>其中，第 1 列就是浏览器 cookie 中保存的 sessionid；第 2 列是经过 BASE64 编码后的 session 中的数据，如果使用 Python 的 <code>base64</code>  对其进行解码，解码的过程和结果如下所示。</p><pre><code class="language-Python">import base64base64.b64decode('MmI4YzViYjJhOGMyMDJkY2M5Yzg3ZWIyZGViZmUzYmYxNzdlNDdmZjp7ImNhcHRjaGEiOiJzS3d0Iiwibm8iOjEsInVzZXJuYW1lIjoiamFja2ZydWVkIn0=')</code></pre><p>第 3 列是 session 的过期时间，session 过期后浏览器保存的 cookie 中的 sessionid 就会失效，但是数据库中的这条对应的记录仍然会存在，如果想清除过期的数据，可以使用下面的命令。</p><pre><code class="language-Shell">python manage.py clearsessions</code></pre><p>Django 框架默认的 session 过期时间为两周（1209600 秒），如果想修改这个时间，可以在项目的配置文件中添加如下所示的代码。</p><pre><code class="language-Python"># 配置会话的超时时间为1天（86400秒）SESSION_COOKIE_AGE = 86400</code></pre><p>有很多对安全性要求较高的应用都必须在关闭浏览器窗口时让会话过期，不再保留用户的任何信息，如果希望在关闭浏览器窗口时就让会话过期（cookie 中的 sessionid 失效），可以加入如下所示的配置。</p><pre><code class="language-Python"># 设置为True在关闭浏览器窗口时session就过期SESSION_EXPIRE_AT_BROWSER_CLOSE = True</code></pre><p>如果不希望将 session 的数据保存在数据库中，可以将其放入缓存中，对应的配置如下所示，缓存的配置和使用我们在后面讲解。</p><pre><code class="language-Python"># 配置将会话对象放到缓存中存储SESSION_ENGINE = 'django.contrib.sessions.backends.cache'# 配置使用哪一组缓存来保存会话SESSION_CACHE_ALIAS = 'default'</code></pre><p>如果要修改 session 数据默认的序列化方式，可以将默认的 <code>JSONSerializer</code>  修改为 <code>PickleSerializer</code> 。</p><pre><code class="language-Python">SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'</code></pre><p>接下来，我们就可以限制只有登录用户才能为老师投票，修改后的 <code>praise_or_criticize</code>  函数如下所示，我们通过从 <code>request.session</code>  中获取 <code>userid</code>  来判定用户是否登录。</p><pre><code class="language-Python">def praise_or_criticize(request: HttpRequest) -&gt; HttpResponse:    if request.session.get('userid'):        try:            tno = int(request.GET.get('tno'))            teacher = Teacher.objects.get(no=tno)            if request.path.startswith('/praise/'):                teacher.good_count += 1                count = teacher.good_count            else:                teacher.bad_count += 1                count = teacher.bad_count            teacher.save()            data = &#123;'code': 20000, 'mesg': '投票成功', 'count': count&#125;        except (ValueError, Teacher.DoesNotExist):            data = &#123;'code': 20001, 'mesg': '投票失败'&#125;    else:        data = &#123;'code': 20002, 'mesg': '请先登录'&#125;    return JsonResponse(data)</code></pre><p>当然，在修改了视图函数后， <code>teachers.html</code>  也需要进行调整，用户如果没有登录，就将用户引导至登录页，登录成功再返回到投票页，此处不再赘述。</p><h3 id="在视图函数中读写cookie"><a class="anchor" href="#在视图函数中读写cookie">#</a> 在视图函数中读写 cookie</h3><p>下面我们对如何使用 cookie 做一个更为细致的说明以便帮助大家在 Web 项目中更好的使用这项技术。Django 封装的 <code>HttpRequest</code>  和 <code>HttpResponse</code>  对象分别提供了读写 cookie 的操作。</p><p>HttpRequest 封装的属性和方法：</p><ol><li><code>COOKIES</code>  属性 - 该属性包含了 HTTP 请求携带的所有 cookie。</li><li><code>get_signed_cookie</code>  方法 - 获取带签名的 cookie，如果签名验证失败，会产生 <code>BadSignature</code>  异常。</li></ol><p>HttpResponse 封装的方法：</p><ol><li><code>set_cookie</code>  方法 - 该方法可以设置一组键值对并将其最终将写入浏览器。</li><li><code>set_signed_cookie</code>  方法 - 跟上面的方法作用相似，但是会对 cookie 进行签名来达到防篡改的作用。因为如果篡改了 cookie 中的数据，在不知道<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFGJTg2JUU5JTkyJUE1">密钥</span>和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTlCJTkwXyglRTUlQUYlODYlRTclQTAlODElRTUlQUQlQTYp">盐</span>的情况下是无法生成有效的签名，这样服务器在读取 cookie 时会发现数据与签名不一致从而产生 <code>BadSignature</code>  异常。需要说明的是，这里所说的密钥就是我们在 Django 项目配置文件中指定的 <code>SECRET_KEY</code> ，而盐是程序中设定的一个字符串，你愿意设定为什么都可以，只要是一个有效的字符串。</li></ol><p>上面提到的方法，如果不清楚它们的具体用法，可以自己查阅一下 Django 的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRqYW5nb3Byb2plY3QuY29tL2VuLzIuMS9yZWYvcmVxdWVzdC1yZXNwb25zZS8=">官方文档</span>，没有什么资料比官方文档能够更清楚的告诉你这些方法到底如何使用。</p><p>刚才我们说过了，激活 <code>SessionMiddleware</code>  之后，每个 <code>HttpRequest</code>  对象都会绑定一个 session 属性，它是一个类似字典的对象，除了保存用户数据之外还提供了检测浏览器是否支持 cookie 的方法，包括：</p><ol><li><code>set_test_cookie</code>  方法 - 设置用于测试的 cookie。</li><li><code>test_cookie_worked</code>  方法 - 检测测试 cookie 是否工作。</li><li><code>delete_test_cookie</code>  方法 - 删除用于测试的 cookie。</li><li><code>set_expiry</code>  方法 - 设置会话的过期时间。</li><li><code>get_expire_age</code> / <code>get_expire_date</code>  方法 - 获取会话的过期时间。</li><li><code>clear_expired</code>  方法 - 清理过期的会话。</li></ol><p>下面是在执行登录之前检查浏览器是否支持 cookie 的代码。通常情况下，浏览器默认开启了对 cookie 的支持，但是可能因为某种原因，用户禁用了浏览器的 cookie 功能，遇到这种情况我们可以在视图函数中提供一个检查功能，如果检查到用户浏览器不支持 cookie，可以给出相应的提示。</p><pre><code class="language-Python">def login(request):    if request.method == 'POST':        if request.session.test_cookie_worked():            request.session.delete_test_cookie()            # Add your code to perform login process here        else:            return HttpResponse(&quot;Please enable cookies and try again.&quot;)    request.session.set_test_cookie()    return render_to_response('login.html')</code></pre><h3 id="cookie的替代品"><a class="anchor" href="#cookie的替代品">#</a> Cookie 的替代品</h3><p>之前我们说过了，cookie 的名声一直都不怎么好，当然我们在实际开发中是不会在 cookie 中保存用户的敏感信息（如用户的密码、信用卡的账号等）的，而且保存在 cookie 中的数据一般也会做好编码和签名的工作。对于支持 HTML5 的浏览器来说，可以使用 localStorage 和 sessionStorage 做为 cookie 的替代方案，相信从名字上你就能听出二者的差别，存储在 <code>localStorage</code>  的数据可以长期保留；而存储在 <code>sessionStorage</code>  的数据会在浏览器关闭时会被清除 。关于这些 cookie 替代品的用法，建议大家查阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWI="> MDN</span> 来进行了解。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态资源和Ajax请求</title>
      <link href="/computer-science/python/basic/43.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%92%8CAjax%E8%AF%B7%E6%B1%82/"/>
      <url>/computer-science/python/basic/43.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%92%8CAjax%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="静态资源和ajax请求"><a class="anchor" href="#静态资源和ajax请求">#</a> 静态资源和 Ajax 请求</h2><h3 id="加载静态资源"><a class="anchor" href="#加载静态资源">#</a> 加载静态资源</h3><p>如果要在 Django 项目中使用静态资源，可以先创建一个用于保存静态资源的目录。在 <code>vote</code>  项目中，我们将静态资源置于名为 <code>static</code>  的文件夹中，在该文件夹包含了三个子文件夹：css、js 和 images，分别用来保存外部 CSS 文件、外部 JavaScript 文件和图片资源，如下图所示。</p><p><img data-src="res/pycharm-django-static.png" alt="" /></p><p>为了能够找到保存静态资源的文件夹，我们还需要修改 Django 项目的配置文件 <code>settings.py</code> ，如下所示：</p><pre><code class="language-Python">STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'), ]STATIC_URL = '/static/'</code></pre><p>配置好静态资源之后，大家可以运行项目，然后看看之前我们写的页面上的图片是否能够正常加载出来。需要说明的是，在项目正式部署到线上环境后，我们通常会把静态资源交给专门的静态资源服务器（如 Nginx、Apache）来处理，而不是有运行 Python 代码的服务器来管理静态资源，所以上面的配置并不适用于生产环境，仅供项目开发阶段测试使用。使用静态资源的正确姿势我们会在后续的章节为大家讲解。</p><h3 id="ajax概述"><a class="anchor" href="#ajax概述">#</a> Ajax 概述</h3><p>接下来就可以实现 “好评” 和 “差评” 的功能了，很明显如果能够在不刷新页面的情况下实现这两个功能会带来更好的用户体验，因此我们考虑使用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQUpBWA=="> Ajax</span> 技术来实现 “好评” 和 “差评”。Ajax 是 Asynchronous Javascript And XML 的缩写，简单的说，使用 Ajax 技术可以在不重新加载整个页面的情况下对页面进行局部刷新。</p><p>对于传统的 Web 应用，每次页面上需要加载新的内容都需要重新请求服务器并刷新整个页面，如果服务器短时间内无法给予响应或者网络状况并不理想，那么可能会造成浏览器长时间的空白并使得用户处于等待状态，在这个期间用户什么都做不了，如下图所示。很显然，这样的 Web 应用并不能带来很好的用户体验。</p><p><img data-src="res/synchronous-web-request.png" alt="" /></p><p>对于使用 Ajax 技术的 Web 应用，浏览器可以向服务器发起异步请求来获取数据。异步请求不会中断用户体验，当服务器返回了新的数据，我们可以通过 JavaScript 代码进行 DOM 操作来实现对页面的局部刷新，这样就相当于在不刷新整个页面的情况下更新了页面的内容，如下图所示。</p><p><img data-src="res/asynchronous-web-request.png" alt="" /></p><p>在使用 Ajax 技术时，浏览器跟服务器通常会交换 XML 或 JSON 格式的数据，XML 是以前使用得非常多的一种数据格式，近年来几乎已经完全被 JSON 取代，下面是两种数据格式的对比。</p><p>XML 格式：</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;message&gt;&lt;from&gt;Alice&lt;/from&gt;    &lt;to&gt;Bob&lt;/to&gt;    &lt;content&gt;Dinner is on me!&lt;/content&gt;&lt;/message&gt;</code></pre><p>JSON 格式：</p><pre><code class="language-JSON">&#123;    &quot;from&quot;: &quot;Alice&quot;,    &quot;to&quot;: &quot;Bob&quot;,    &quot;content&quot;: &quot;Dinner is on me!&quot;&#125;</code></pre><p>通过上面的对比，明显 JSON 格式的数据要紧凑得多，所以传输效率更高，而且 JSON 本身也是 JavaScript 中的一种对象表达式语法，在 JavaScript 代码中处理 JSON 格式的数据更加方便。</p><h3 id="用ajax实现投票功能"><a class="anchor" href="#用ajax实现投票功能">#</a> 用 Ajax 实现投票功能</h3><p>下面，我们使用 Ajax 技术来实现投票的功能，首先修改项目的 <code>urls.py</code>  文件，为 “好评” 和 “差评” 功能映射对应的 URL。</p><pre><code class="language-Python">from django.contrib import adminfrom django.urls import pathfrom vote import viewsurlpatterns = [    path('', views.show_subjects),    path('teachers/', views.show_teachers),    path('praise/', views.praise_or_criticize),    path('criticize/', views.praise_or_criticize),    path('admin/', admin.site.urls),]</code></pre><p>设计视图函数 <code>praise_or_criticize</code>  来支持 “好评” 和 “差评” 功能，该视图函数通过 Django 封装的 JsonResponse 类将字典序列化成 JSON 字符串作为返回给浏览器的响应内容。</p><pre><code class="language-Python">def praise_or_criticize(request):    &quot;&quot;&quot;好评&quot;&quot;&quot;    try:        tno = int(request.GET.get('tno'))        teacher = Teacher.objects.get(no=tno)        if request.path.startswith('/praise'):            teacher.good_count += 1            count = teacher.good_count        else:            teacher.bad_count += 1            count = teacher.bad_count        teacher.save()        data = &#123;'code': 20000, 'mesg': '操作成功', 'count': count&#125;    except (ValueError, Teacher.DoseNotExist):        data = &#123;'code': 20001, 'mesg': '操作失败'&#125;    return JsonResponse(data)</code></pre><p>修改显示老师信息的模板页，引入 jQuery 库来实现事件处理、Ajax 请求和 DOM 操作。</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;老师信息&lt;/title&gt;    &lt;style&gt;        #container &#123;            width: 80%;            margin: 10px auto;        &#125;        .teacher &#123;            width: 100%;            margin: 0 auto;            padding: 10px 0;            border-bottom: 1px dashed gray;            overflow: auto;        &#125;        .teacher&gt;div &#123;            float: left;        &#125;        .photo &#123;            height: 140px;            border-radius: 75px;            overflow: hidden;            margin-left: 20px;        &#125;        .info &#123;            width: 75%;            margin-left: 30px;        &#125;        .info div &#123;            clear: both;            margin: 5px 10px;        &#125;        .info span &#123;            margin-right: 25px;        &#125;        .info a &#123;            text-decoration: none;            color: darkcyan;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;h1&gt;&#123;&#123; subject.name &#125;&#125;学科的老师信息&lt;/h1&gt;        &lt;hr&gt;        &#123;% if not teachers %&#125;            <h2>暂无该学科老师信息</h2>        &#123;% endif %&#125;        &#123;% for teacher in teachers %&#125;        <div class="teacher">            <div class="photo">                <img data-src="/static/images/&#123;&#123; teacher.photo &#125;&#125;" height="140" alt="">            </div>            <div class="info">                <div>                    <span><strong>姓名：&#123;&#123; teacher.name &#125;&#125;</strong></span>                    <span>性别：&#123;&#123; teacher.sex | yesno:'男,女' &#125;&#125;</span>                    <span>出生日期：&#123;&#123; teacher.birth &#125;&#125;</span>                </div>                <div class="intro">&#123;&#123; teacher.intro &#125;&#125;</div>                <div class="comment">                    <a href="/praise/?tno=&#123;&#123; teacher.no &#125;&#125;">好评</a>&nbsp;&nbsp;                    (<strong>&#123;&#123; teacher.good_count &#125;&#125;</strong>)                    &nbsp;&nbsp;&nbsp;&nbsp;                    <a href="/criticize/?tno=&#123;&#123; teacher.no &#125;&#125;">差评</a>&nbsp;&nbsp;                    (<strong>&#123;&#123; teacher.bad_count &#125;&#125;</strong>)                </div>            </div>        </div>        &#123;% endfor %&#125;        &lt;a href=&quot;/&quot;&gt;返回首页&lt;/a&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(() =&gt; &#123;            $('.comment&gt;a').on('click', (evt) =&gt; &#123;                evt.preventDefault()                let url = $(evt.target).attr('href')                $.getJSON(url, (json) =&gt; &#123;                    if (json.code == 20000) &#123;                        $(evt.target).next().text(json.count)                    &#125; else &#123;                        alert(json.mesg)                    &#125;                &#125;)            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上面的前端代码中，使用了 jQuery 库封装的 <code>getJSON</code>  方法向服务器发送异步请求，如果不熟悉前端的 jQuery 库，可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9tYW51YWwvanF1ZXJ5Lw==">《jQuery API 手册》</span>。</p><h3 id="小结"><a class="anchor" href="#小结">#</a> 小结</h3><p>到此为止，这个投票项目的核心功能已然完成，在下面的章节中我们会要求用户必须登录才能投票，没有账号的用户可以通过注册功能注册一个账号。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入模型</title>
      <link href="/computer-science/python/basic/42.%E6%B7%B1%E5%85%A5%E6%A8%A1%E5%9E%8B/"/>
      <url>/computer-science/python/basic/42.%E6%B7%B1%E5%85%A5%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="深入模型"><a class="anchor" href="#深入模型">#</a> 深入模型</h2><p>在上一个章节中，我们提到了 Django 是基于 MVC 架构的 Web 框架，MVC 架构追求的是 “模型” 和 “视图” 的解耦合。所谓 “模型” 说得更直白一些就是数据（的表示），所以通常也被称作 “数据模型”。在实际的项目中，数据模型通常通过数据库实现持久化操作，而关系型数据库在过去和当下都是持久化的首选方案，下面我们通过完成一个投票项目来讲解和模型相关的知识点。投票项目的首页会展示某在线教育平台所有的学科；点击学科可以查看到该学科的老师及其信息；用户登录后在查看老师的页面为老师投票，可以投赞成票和反对票；未登录的用户可以通过登录页进行登录；尚未注册的用户可以通过注册页输入个人信息进行注册。在这个项目中，我们使用 MySQL 数据库来实现数据持久化操作。</p><h3 id="创建项目和应用"><a class="anchor" href="#创建项目和应用">#</a> 创建项目和应用</h3><p>我们首先创建 Django 项目 <code>vote</code>  并为其添加虚拟环境和依赖项。接下来，在项目下创建名为 <code>polls</code>  的应用和保存模板页的文件夹 <code>tempaltes</code> ，项目文件夹的结构如下所示。</p><p><img data-src="res/pycharm-vote-project.png" alt="" /></p><p>根据上面描述的项目需求，我们准备了四个静态页面，分别是展示学科的页面 <code>subjects.html</code> ，显示学科老师的页面 <code>teachers.html</code> ，登录页面 <code>login.html</code> ，注册页面 <code>register.html</code> ，稍后我们会将静态页修改为 Django 项目所需的模板页。</p><h3 id="配置关系型数据库mysql"><a class="anchor" href="#配置关系型数据库mysql">#</a> 配置关系型数据库 MySQL</h3><ol><li><p>在 MySQL 中创建数据库，创建用户，授权用户访问该数据库。</p><pre><code class="language-SQL">create database vote default charset utf8;create user 'hellokitty'@'%' identified by 'Hellokitty.618';grant all privileges on vote.* to 'hellokitty'@'%';flush privileges;</code></pre></li><li><p>在 MySQL 中创建保存学科和老师信息的二维表（保存用户信息的表稍后处理）。</p><pre><code class="language-SQL">use vote;-- 创建学科表create table `tb_subject`(`no` integer auto_increment comment '学科编号',    `name` varchar(50) not null comment '学科名称',    `intro` varchar(1000) not null default '' comment '学科介绍',    `is_hot` boolean not null default 0 comment '是不是热门学科',    primary key (`no`));-- 创建老师表create table `tb_teacher`(    `no` integer auto_increment comment '老师编号',    `name` varchar(20) not null comment '老师姓名',    `sex` boolean not null default 1 comment '老师性别',    `birth` date not null comment '出生日期',    `intro` varchar(1000) not null default '' comment '老师介绍',    `photo` varchar(255) not null default '' comment '老师照片',    `gcount` integer not null default 0 comment '好评数',    `bcount` integer not null default 0 comment '差评数',    `sno` integer not null comment '所属学科',    primary key (`no`),    foreign key (`sno`) references `tb_subject` (`no`));</code></pre></li><li><p>在虚拟环境中安装连接 MySQL 数据库所需的依赖项。</p><pre><code class="language-Bash">pip install mysqlclient</code></pre><blockquote><p><strong>说明</strong>：如果因为某些原因无法安装 <code>mysqlclient</code>  三方库，可以使用它的替代品 <code>pymysql</code> ， <code>pymysql</code>  是用纯 Python 开发的连接 MySQL 的 Python 库，安装更容易成功，但是需要在 Django 项目文件夹的 <code>__init__.py</code>  中添加如下所示的代码。</p><pre><code class="language-Python">import pymysqlpymysql.install_as_MySQLdb()</code></pre><p>如果使用 Django 2.2 及以上版本，还会遇到 PyMySQL 跟 Django 框架的兼容性问题，兼容性问题会导致项目无法运行，需要按照 GitHub 上 PyMySQL 仓库<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1B5TXlTUUwvUHlNeVNRTC9pc3N1ZXMvNzkw"> Issues</span> 中提供的方法进行处理。总体来说，使用 <code>pymysql</code>  会比较麻烦，强烈建议大家首选安装 <code>mysqlclient</code> 。</p></blockquote></li><li><p>修改项目的 settings.py 文件，首先将我们创建的应用 <code>polls</code>  添加已安装的项目（ <code>INSTALLED_APPS</code> ）中，然后配置 MySQL 作为持久化方案。</p><pre><code class="language-Python">INSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'polls',]DATABASES = &#123;    'default': &#123;        # 数据库引擎配置        'ENGINE': 'django.db.backends.mysql',        # 数据库的名字        'NAME': 'vote',        # 数据库服务器的IP地址（本机可以写localhost或127.0.0.1）        'HOST': 'localhost',        # 启动MySQL服务的端口号        'PORT': 3306,        # 数据库用户名和口令        'USER': 'hellokitty',        'PASSWORD': 'Hellokitty.618',        # 数据库使用的字符集        'CHARSET': 'utf8',        # 数据库时间日期的时区设定        'TIME_ZONE': 'Asia/Chongqing',    &#125;&#125;</code></pre><p>在配置 ENGINE 属性时，常用的可选值包括：</p><ul><li><code>'django.db.backends.sqlite3'</code> ：SQLite 嵌入式数据库。</li><li><code>'django.db.backends.postgresql'</code> ：BSD 许可证下发行的开源关系型数据库产品。</li><li><code>'django.db.backends.mysql'</code> ：甲骨文公司经济高效的数据库产品。</li><li><code>'django.db.backends.oracle'</code> ：甲骨文公司关系型数据库旗舰产品。</li></ul><p>其他的配置可以参考官方文档中<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRqYW5nb3Byb2plY3QuY29tL3poLWhhbnMvMi4wL3JlZi9kYXRhYmFzZXMvI3RoaXJkLXBhcnR5LW5vdGVz">数据库配置</span>的部分。</p></li><li><p>Django 框架提供了 ORM 来解决数据持久化问题，ORM 翻译成中文叫 “对象关系映射”。因为 Python 是面向对象的编程语言，我们在 Python 程序中使用对象模型来保存数据，而关系型数据库使用关系模型，用二维表来保存数据，这两种模型并不匹配。使用 ORM 是为了实现对象模型到关系模型的<strong>双向转换</strong>，这样就不用在 Python 代码中书写 SQL 语句和游标操作，因为这些都会由 ORM 自动完成。利用 Django 的 ORM，我们可以直接将刚才创建的学科表和老师表变成 Django 中的模型类。</p><pre><code class="language-Bash">python manage.py inspectdb &gt; polls/models.py</code></pre><p>我们可以对自动生成的模型类稍作调整，代码如下所示。</p><pre><code class="language-Python">from django.db import modelsclass Subject(models.Model):    no = models.AutoField(primary_key=True, verbose_name='编号')    name = models.CharField(max_length=50, verbose_name='名称')    intro = models.CharField(max_length=1000, verbose_name='介绍')    is_hot = models.BooleanField(verbose_name='是否热门')    class Meta:        managed = False        db_table = 'tb_subject'class Teacher(models.Model):    no = models.AutoField(primary_key=True, verbose_name='编号')    name = models.CharField(max_length=20, verbose_name='姓名')    sex = models.BooleanField(default=True, verbose_name='性别')    birth = models.DateField(verbose_name='出生日期')    intro = models.CharField(max_length=1000, verbose_name='个人介绍')    photo = models.ImageField(max_length=255, verbose_name='照片')    good_count = models.IntegerField(default=0, db_column='gcount', verbose_name='好评数')    bad_count = models.IntegerField(default=0, db_column='bcount', verbose_name='差评数')    subject = models.ForeignKey(Subject, models.DO_NOTHING, db_column='sno')    class Meta:        managed = False        db_table = 'tb_teacher'</code></pre><blockquote><p><strong>说明</strong>：模型类都直接或间接继承自 <code>Model</code>  类，模型类跟关系型数据库的二维表对应，模型对象跟表中的记录对应，模型对象的属性跟表中的字段对应。如果对上面模型类的属性定义不是特别理解，可以看看本文后面提供的 “模型定义参考” 部分的内容。</p></blockquote></li></ol><h3 id="使用orm完成模型的crud操作"><a class="anchor" href="#使用orm完成模型的crud操作">#</a> 使用 ORM 完成模型的 CRUD 操作</h3><p>有了 Django 框架的 ORM，我们可以直接使用面向对象的方式来实现对数据的 CRUD（增删改查）操作。我们可以在 PyCharm 的终端中输入下面的命令进入到 Django 项目的交互式环境，然后尝试对模型的操作。</p><pre><code class="language-Bash">python manage.py shell</code></pre><h4 id="新增"><a class="anchor" href="#新增">#</a> 新增</h4><pre><code class="language-Python">from polls.models import Subjectsubject1 = Subject(name='Python全栈开发', intro='当下最热门的学科', is_hot=True)subject1.save()subject2 = Subject(name='全栈软件测试', intro='学习自动化测试的学科', is_hot=False)subject2.save()subject3 = Subject(name='JavaEE分布式开发', intro='基于Java语言的服务器应用开发', is_hot=True)</code></pre><h4 id="删除"><a class="anchor" href="#删除">#</a> 删除</h4><pre><code class="language-Python">subject = Subject.objects.get(no=2)subject.delete()</code></pre><h4 id="更新"><a class="anchor" href="#更新">#</a> 更新</h4><pre><code class="language-Shell">subject = Subject.objects.get(no=1)subject.name = 'Python全栈+人工智能'subject.save()</code></pre><h4 id="查询"><a class="anchor" href="#查询">#</a> 查询</h4><ol><li>查询所有对象。</li></ol><pre><code class="language-Shell">Subjects.objects.all()</code></pre><ol start="2"><li>过滤数据。</li></ol><pre><code class="language-Shell"># 查询名称为“Python全栈+人工智能”的学科Subject.objects.filter(name='Python全栈+人工智能')# 查询名称包含“全栈”的学科（模糊查询）Subject.objects.filter(name__contains='全栈')Subject.objects.filter(name__startswith='全栈')Subject.objects.filter(name__endswith='全栈')# 查询所有热门学科Subject.objects.filter(is_hot=True)# 查询编号大于3小于10的学科Subject.objects.filter(no__gt=3).filter(no__lt=10)Subject.objects.filter(no__gt=3, no__lt=10)# 查询编号在3到7之间的学科Subject.objects.filter(no__ge=3, no__le=7)Subject.objects.filter(no__range=(3, 7))</code></pre><ol start="3"><li>查询单个对象。</li></ol><pre><code class="language-Shell"># 查询主键为1的学科Subject.objects.get(pk=1)Subject.objects.get(no=1)Subject.objects.filter(no=1).first()Subject.objects.filter(no=1).last()</code></pre><ol start="4"><li>排序。</li></ol><pre><code class="language-Shell"># 查询所有学科按编号升序排列Subject.objects.order_by('no')# 查询所有部门按部门编号降序排列Subject.objects.order_by('-no')</code></pre><ol start="5"><li>切片（分页查询）。</li></ol><pre><code class="language-Shell"># 按编号从小到大查询前3个学科Subject.objects.order_by('no')[:3]</code></pre><ol start="6"><li>计数。</li></ol><pre><code class="language-Python"># 查询一共有多少个学科Subject.objects.count()</code></pre><ol start="7"><li>高级查询。</li></ol><pre><code class="language-Shell"># 查询编号为1的学科的老师Teacher.objects.filter(subject__no=1)Subject.objects.get(pk=1).teacher_set.all() # 查询学科名称有“全栈”二字的学科的老师Teacher.objects.filter(subject__name__contains='全栈') </code></pre><blockquote><p><strong>说明 1</strong>：由于老师与学科之间存在多对一外键关联，所以能通过学科反向查询到该学科的老师（从一对多关系中 “一” 的一方查询 “多” 的一方），反向查询属性默认的名字是 <code>类名小写_set</code> （如上面例子中的 <code>teacher_set</code> ），当然也可以在创建模型时通过 <code>ForeingKey</code>  的 <code>related_name</code>  属性指定反向查询属性的名字。如果不希望执行反向查询可以将 <code>related_name</code>  属性设置为 <code>'+'</code>  或者以 <code>'+'</code>  开头的字符串。</p></blockquote><blockquote><p><strong>说明 2</strong>：ORM 查询多个对象时会返回 QuerySet 对象，QuerySet 使用了惰性查询，即在创建 QuerySet 对象的过程中不涉及任何数据库活动，等真正用到对象时（对 QuerySet 求值）才向数据库发送 SQL 语句并获取对应的结果，这一点在实际开发中需要引起注意！</p></blockquote><blockquote><p><strong>说明 3</strong>：如果希望更新多条数据，不用先逐一获取模型对象再修改对象属性，可以直接使用 QuerySet 对象的 <code>update()</code>  方法一次性更新多条数据。</p></blockquote><h3 id="利用django后台管理模型"><a class="anchor" href="#利用django后台管理模型">#</a> 利用 Django 后台管理模型</h3><p>在创建好模型类之后，可以通过 Django 框架自带的后台管理应用（ <code>admin</code>  应用）实现对模型的管理。虽然实际应用中，这个后台可能并不能满足我们的需求，但是在学习 Django 框架时，我们可以利用 <code>admin</code>  应用来管理我们的模型，同时也通过它来了解一个项目的后台管理系统需要哪些功能。使用 Django 自带的 <code>admin</code>  应用步骤如下所示。</p><ol><li><p>将 <code>admin</code>  应用所需的表迁移到数据库中。 <code>admin</code>  应用本身也需要数据库的支持，而且在 <code>admin</code>  应用中已经定义好了相关的数据模型类，我们只需要通过模型迁移操作就能自动在数据库中生成所需的二维表。</p><pre><code class="language-Bash">python manage.py migrate</code></pre></li><li><p>创建访问 <code>admin</code>  应用的超级用户账号，这里需要输入用户名、邮箱和口令。</p><pre><code class="language-Shell">python manage.py createsuperuser</code></pre><blockquote><p><strong>说明</strong>：输入口令时没有回显也不能退格，需要一气呵成完成输入。</p></blockquote></li><li><p>运行项目，在浏览器中访问 <code>http://127.0.0.1:8000/admin</code> ，输入刚才创建的超级用户账号和密码进行登录。</p><p><img data-src="/Users/Hao/Desktop/Python-100-Days/Day41-55/res/django-admin-login.png" alt="" /></p><p>登录后进入管理员操作平台。</p><p><img data-src="res/django-admin-apps.png" alt="" /></p><p>注意，我们暂时还没能在 <code>admin</code>  应用中看到之前创建的模型类，为此需要在 <code>polls</code>  应用的 <code>admin.py</code>  文件中对需要管理的模型进行注册。</p></li><li><p>注册模型类。</p><pre><code class="language-Python">from django.contrib import adminfrom polls.models import Subject, Teacheradmin.site.register(Subject)admin.site.register(Teacher)</code></pre><p>注册模型类后，就可以在后台管理系统中看到它们。</p><p><img data-src="./res/django-admin-models.png" alt="" /></p></li><li><p>对模型进行 CRUD 操作。</p><p>可以在管理员平台对模型进行 C（新增）、R（查看）、U（更新）、D（删除）操作，如下图所示。</p><ul><li><p>添加学科。</p><p><img data-src="res/django-admin-add-model.png" alt="" /></p></li><li><p>查看所有学科。</p><p><img data-src="res/django-admin-view-models.png" alt="" /></p></li><li><p>删除和更新学科。</p><p><img data-src="res/django-admin-delete-update-model.png" alt="" /></p></li></ul></li><li><p>注册模型管理类。</p><p>可能大家已经注意到了，刚才在后台查看部门信息的时候，显示的部门信息并不直观，为此我们再修改 <code>admin.py</code>  文件，通过注册模型管理类，可以在后台管理系统中更好的管理模型。</p><pre><code class="language-Python">from django.contrib import adminfrom polls.models import Subject, Teacherclass SubjectModelAdmin(admin.ModelAdmin):    list_display = ('no', 'name', 'intro', 'is_hot')    search_fields = ('name', )    ordering = ('no', )class TeacherModelAdmin(admin.ModelAdmin):    list_display = ('no', 'name', 'sex', 'birth', 'good_count', 'bad_count', 'subject')    search_fields = ('name', )    ordering = ('no', )admin.site.register(Subject, SubjectModelAdmin)admin.site.register(Teacher, TeacherModelAdmin)</code></pre><p><img data-src="res/django-admin-view-models-subject.png" alt="" /></p><p><img data-src="res/django-admin-view-models-teacher.png" alt="" /></p><p>为了更好的查看模型，我们为 <code>Subject</code>  类添加 <code>__str__</code> 魔法方法，并在该方法中返回学科名字。这样在如上图所示的查看老师的页面上显示老师所属学科时，就不再是 <code>Subject object(1)</code>  这样晦涩的信息，而是学科的名称。</p></li></ol><h3 id="实现学科页和老师页效果"><a class="anchor" href="#实现学科页和老师页效果">#</a> 实现学科页和老师页效果</h3><ol><li><p>修改 <code>polls/views.py</code>  文件，编写视图函数实现对学科页和老师页的渲染。</p><pre><code class="language-Python">from django.shortcuts import render, redirectfrom polls.models import Subject, Teacherdef show_subjects(request):    subjects = Subject.objects.all().order_by('no')    return render(request, 'subjects.html', &#123;'subjects': subjects&#125;)def show_teachers(request):    try:        sno = int(request.GET.get('sno'))        teachers = []        if sno:            subject = Subject.objects.only('name').get(no=sno)            teachers = Teacher.objects.filter(subject=subject).order_by('no')        return render(request, 'teachers.html', &#123;            'subject': subject,            'teachers': teachers        &#125;)    except (ValueError, Subject.DoesNotExist):        return redirect('/')</code></pre></li><li><p>修改 <code>templates/subjects.html</code>  和 <code>templates/teachers.html</code>  模板页。</p><p><code>subjects.html</code></p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;title&gt;学科信息&lt;/title&gt;   &lt;style&gt;       #container &#123;           width: 80%;           margin: 10px auto;       &#125;       .user &#123;           float: right;           margin-right: 10px;       &#125;       .user&gt;a &#123;           margin-right: 10px;       &#125;       #main&gt;dl&gt;dt &#123;           font-size: 1.5em;           font-weight: bold;       &#125;       #main&gt;dl&gt;dd &#123;           font-size: 1.2em;       &#125;       a &#123;           text-decoration: none;           color: darkcyan;       &#125;   &lt;/style&gt;&lt;/head&gt;&lt;body&gt;   &lt;div id=&quot;container&quot;&gt;       &lt;div class=&quot;user&quot;&gt;           &lt;a href=&quot;login.html&quot;&gt;用户登录&lt;/a&gt;           &lt;a href=&quot;register.html&quot;&gt;快速注册&lt;/a&gt;       &lt;/div&gt;       &lt;h1&gt;扣丁学堂所有学科&lt;/h1&gt;       &lt;hr&gt;       &lt;div id=&quot;main&quot;&gt;           &#123;% for subject in subjects %&#125;                <dl>                    <dt>                        <a href="/teachers/?sno=&#123;&#123; subject.no &#125;&#125;">&#123;&#123; subject.name &#125;&#125;</a>                        &#123;% if subject.is_hot %&#125;                        <img data-src="/static/images/hot-icon-small.png">                        &#123;% endif %&#125;                    </dt>                    <dd>&#123;&#123; subject.intro &#125;&#125;</dd>                </dl>                &#123;% endfor %&#125;       &lt;/div&gt;   &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>teachers.html</code></p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;老师信息&lt;/title&gt;    &lt;style&gt;        #container &#123;            width: 80%;            margin: 10px auto;        &#125;        .teacher &#123;            width: 100%;            margin: 0 auto;            padding: 10px 0;            border-bottom: 1px dashed gray;            overflow: auto;        &#125;        .teacher&gt;div &#123;            float: left;        &#125;        .photo &#123;            height: 140px;            border-radius: 75px;            overflow: hidden;            margin-left: 20px;        &#125;        .info &#123;            width: 75%;            margin-left: 30px;        &#125;        .info div &#123;            clear: both;            margin: 5px 10px;        &#125;        .info span &#123;            margin-right: 25px;        &#125;        .info a &#123;            text-decoration: none;            color: darkcyan;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;h1&gt;&#123;&#123; subject.name &#125;&#125;学科的老师信息&lt;/h1&gt;        &lt;hr&gt;        &#123;% if not teachers %&#125;                <h2>暂无该学科老师信息</h2>            &#123;% endif %&#125;        &#123;% for teacher in teachers %&#125;            <div class="teacher">                <div class="photo">                    <img data-src="/static/images/&#123;&#123; teacher.photo &#125;&#125;" height="140" alt="">                </div>                <div class="info">                    <div>                        <span><strong>姓名：&#123;&#123; teacher.name &#125;&#125;</strong></span>                        <span>性别：&#123;&#123; teacher.sex | yesno:'男,女' &#125;&#125;</span>                        <span>出生日期：&#123;&#123; teacher.birth | date:'Y年n月j日'&#125;&#125;</span>                    </div>                    <div class="intro">&#123;&#123; teacher.intro &#125;&#125;</div>                    <div class="comment">                        <a href="">好评</a>&nbsp;(<strong>&#123;&#123; teacher.good_count &#125;&#125;</strong>)                        &nbsp;&nbsp;&nbsp;&nbsp;                        <a href="">差评</a>&nbsp;<strong>&#123;&#123; teacher.bad_count &#125;&#125;</strong>)                    </div>                </div>            </div>            &#123;% endfor %&#125;        &lt;a href=&quot;/&quot;&gt;返回首页&lt;/a&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>修改 <code>vote/urls.py</code>  文件，实现映射 URL。</p><pre><code class="language-Python">from django.contrib import adminfrom django.urls import pathfrom polls.views import show_subjects, show_teachersurlpatterns = [    path('admin/', admin.site.urls),    path('', show_subjects),    path('teachers/', show_teachers),]</code></pre></li></ol><p>到此为止，页面上需要的图片（静态资源）还没有能够正常展示，我们在下一章节中为大家介绍如何处理模板页上的需要的静态资源。</p><h3 id="补充内容"><a class="anchor" href="#补充内容">#</a> 补充内容</h3><h4 id="django模型最佳实践"><a class="anchor" href="#django模型最佳实践">#</a> Django 模型最佳实践</h4><ol><li>正确的为模型和关系字段命名。</li><li>设置适当的 <code>related_name</code>  属性。</li><li>用 <code>OneToOneField</code>  代替 <code>ForeignKeyField(unique=True)</code> 。</li><li>通过 “迁移操作”（migrate）来添加模型。</li><li>用 NoSQL 来应对需要降低范式级别的场景。</li><li>如果布尔类型可以为空要使用 <code>NullBooleanField</code> 。</li><li>在模型中放置业务逻辑。</li><li>用 <code>&lt;ModelName&gt;.DoesNotExists</code>  取代 <code>ObjectDoesNotExists</code> 。</li><li>在数据库中不要出现无效数据。</li><li>不要对 <code>QuerySet</code>  调用 <code>len()</code>  函数。</li><li>将 <code>QuerySet</code>  的 <code>exists()</code>  方法的返回值用于 <code>if</code>  条件。</li><li>用 <code>DecimalField</code>  来存储货币相关数据而不是 <code>FloatField</code> 。</li><li>定义 <code>__str__</code> 方法。</li><li>不要将数据文件放在同一个目录中。</li></ol><blockquote><p><strong>说明</strong>：以上内容来自于 STEELKIWI 网站的<a href="https://steelkiwi.com/blog/best-practices-working-django-models-python/"><em> Best Practice working with Django models in Python</em></a>，有兴趣的小伙伴可以阅读原文。</p></blockquote><h4 id="模型定义参考"><a class="anchor" href="#模型定义参考">#</a> 模型定义参考</h4><h5 id="字段"><a class="anchor" href="#字段">#</a> 字段</h5><p>对字段名称的限制</p><ul><li>字段名不能是 Python 的保留字，否则会导致语法错误</li><li>字段名不能有多个连续下划线，否则影响 ORM 查询操作</li></ul><p>Django 模型字段类</p><table><thead><tr><th>字段类</th><th>说明</th></tr></thead><tbody><tr><td><code>AutoField</code></td><td>自增 ID 字段</td></tr><tr><td><code>BigIntegerField</code></td><td>64 位有符号整数</td></tr><tr><td><code>BinaryField</code></td><td>存储二进制数据的字段，对应 Python 的 <code>bytes</code>  类型</td></tr><tr><td><code>BooleanField</code></td><td>存储 <code>True</code>  或 <code>False</code></td></tr><tr><td><code>CharField</code></td><td>长度较小的字符串</td></tr><tr><td><code>DateField</code></td><td>存储日期，有 <code>auto_now</code>  和 <code>auto_now_add</code>  属性</td></tr><tr><td><code>DateTimeField</code></td><td>存储日期和日期，两个附加属性同上</td></tr><tr><td><code>DecimalField</code></td><td>存储固定精度小数，有 <code>max_digits</code> （有效位数）和 <code>decimal_places</code> （小数点后面）两个必要的参数</td></tr><tr><td><code>DurationField</code></td><td>存储时间跨度</td></tr><tr><td><code>EmailField</code></td><td>与 <code>CharField</code>  相同，可以用 <code>EmailValidator</code>  验证</td></tr><tr><td><code>FileField</code></td><td>文件上传字段</td></tr><tr><td><code>FloatField</code></td><td>存储浮点数</td></tr><tr><td><code>ImageField</code></td><td>其他同 <code>FileFiled</code> ，要验证上传的是不是有效图像</td></tr><tr><td><code>IntegerField</code></td><td>存储 32 位有符号整数。</td></tr><tr><td><code>GenericIPAddressField</code></td><td>存储 IPv4 或 IPv6 地址</td></tr><tr><td><code>NullBooleanField</code></td><td>存储 <code>True</code> 、 <code>False</code>  或 <code>null</code>  值</td></tr><tr><td><code>PositiveIntegerField</code></td><td>存储无符号整数（只能存储正数）</td></tr><tr><td><code>SlugField</code></td><td>存储 slug（简短标注）</td></tr><tr><td><code>SmallIntegerField</code></td><td>存储 16 位有符号整数</td></tr><tr><td><code>TextField</code></td><td>存储数据量较大的文本</td></tr><tr><td><code>TimeField</code></td><td>存储时间</td></tr><tr><td><code>URLField</code></td><td>存储 URL 的 <code>CharField</code></td></tr><tr><td><code>UUIDField</code></td><td>存储全局唯一标识符</td></tr></tbody></table><h5 id="字段属性"><a class="anchor" href="#字段属性">#</a> 字段属性</h5><p>通用字段属性</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>null</code></td><td>数据库中对应的字段是否允许为 <code>NULL</code> ，默认为 <code>False</code></td></tr><tr><td><code>blank</code></td><td>后台模型管理验证数据时，是否允许为 <code>NULL</code> ，默认为 <code>False</code></td></tr><tr><td><code>choices</code></td><td>设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值</td></tr><tr><td><code>db_column</code></td><td>字段对应到数据库表中的列名，未指定时直接使用字段的名称</td></tr><tr><td><code>db_index</code></td><td>设置为 <code>True</code>  时将在该字段创建索引</td></tr><tr><td><code>db_tablespace</code></td><td>为有索引的字段设置使用的表空间，默认为 <code>DEFAULT_INDEX_TABLESPACE</code></td></tr><tr><td><code>default</code></td><td>字段的默认值</td></tr><tr><td><code>editable</code></td><td>字段在后台模型管理或 <code>ModelForm</code>  中是否显示，默认为 <code>True</code></td></tr><tr><td><code>error_messages</code></td><td>设定字段抛出异常时的默认消息的字典，其中的键包括 <code>null</code> 、 <code>blank</code> 、 <code>invalid</code> 、 <code>invalid_choice</code> 、 <code>unique</code>  和 <code>unique_for_date</code></td></tr><tr><td><code>help_text</code></td><td>表单小组件旁边显示的额外的帮助文本。</td></tr><tr><td><code>primary_key</code></td><td>将字段指定为模型的主键，未指定时会自动添加 <code>AutoField</code>  用于主键，只读。</td></tr><tr><td><code>unique</code></td><td>设置为 <code>True</code>  时，表中字段的值必须是唯一的</td></tr><tr><td><code>verbose_name</code></td><td>字段在后台模型管理显示的名称，未指定时使用字段的名称</td></tr></tbody></table><p><code>ForeignKey</code>  属性</p><ol><li><code>limit_choices_to</code> ：值是一个 Q 对象或返回一个 Q 对象，用于限制后台显示哪些对象。</li><li><code>related_name</code> ：用于获取关联对象的关联管理器对象（反向查询），如果不允许反向，该属性应该被设置为 <code>'+'</code> ，或者以 <code>'+'</code>  结尾。</li><li><code>to_field</code> ：指定关联的字段，默认关联对象的主键字段。</li><li><code>db_constraint</code> ：是否为外键创建约束，默认值为 <code>True</code> 。</li><li><code>on_delete</code> ：外键关联的对象被删除时对应的动作，可取的值包括 <code>django.db.models</code>  中定义的：<ul><li><code>CASCADE</code> ：级联删除。</li><li><code>PROTECT</code> ：抛出 <code>ProtectedError</code>  异常，阻止删除引用的对象。</li><li><code>SET_NULL</code> ：把外键设置为 <code>null</code> ，当 <code>null</code>  属性被设置为 <code>True</code>  时才能这么做。</li><li><code>SET_DEFAULT</code> ：把外键设置为默认值，提供了默认值才能这么做。</li></ul></li></ol><p><code>ManyToManyField</code>  属性</p><ol><li><code>symmetrical</code> ：是否建立对称的多对多关系。</li><li><code>through</code> ：指定维持多对多关系的中间表的 Django 模型。</li><li><code>throughfields</code> ：定义了中间模型时可以指定建立多对多关系的字段。</li><li><code>db_table</code> ：指定维持多对多关系的中间表的表名。</li></ol><h5 id="模型元数据选项"><a class="anchor" href="#模型元数据选项">#</a> 模型元数据选项</h5><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>abstract</code></td><td>设置为 True 时模型是抽象父类</td></tr><tr><td><code>app_label</code></td><td>如果定义模型的应用不在 INSTALLED_APPS 中可以用该属性指定</td></tr><tr><td><code>db_table</code></td><td>模型使用的数据表名称</td></tr><tr><td><code>db_tablespace</code></td><td>模型使用的数据表空间</td></tr><tr><td><code>default_related_name</code></td><td>关联对象回指这个模型时默认使用的名称，默认为 &lt;model_name&gt;_set</td></tr><tr><td><code>get_latest_by</code></td><td>模型中可排序字段的名称。</td></tr><tr><td><code>managed</code></td><td>设置为 True 时，Django 在迁移中创建数据表并在执行 flush 管理命令时把表移除</td></tr><tr><td><code>order_with_respect_to</code></td><td>标记对象为可排序的</td></tr><tr><td><code>ordering</code></td><td>对象的默认排序</td></tr><tr><td><code>permissions</code></td><td>创建对象时写入权限表的额外权限</td></tr><tr><td><code>default_permissions</code></td><td>默认为 <code>('add', 'change', 'delete')</code></td></tr><tr><td><code>unique_together</code></td><td>设定组合在一起时必须独一无二的字段名</td></tr><tr><td><code>index_together</code></td><td>设定一起建立索引的多个字段名</td></tr><tr><td><code>verbose_name</code></td><td>为对象设定人类可读的名称</td></tr><tr><td><code>verbose_name_plural</code></td><td>设定对象的复数名称</td></tr></tbody></table><h4 id="查询参考"><a class="anchor" href="#查询参考">#</a> 查询参考</h4><h5 id="按字段查找可以用的条件"><a class="anchor" href="#按字段查找可以用的条件">#</a> 按字段查找可以用的条件</h5><ol><li><code>exact</code>  /  <code>iexact</code> ：精确匹配 / 忽略大小写的精确匹配查询</li><li><code>contains</code>  /  <code>icontains</code>  /  <code>startswith</code>  /  <code>istartswith</code>  /  <code>endswith</code>  /  <code>iendswith</code> ：基于 <code>like</code>  的模糊查询</li><li><code>in</code>  ：集合运算</li><li><code>gt</code>  /  <code>gte</code>  /  <code>lt</code>  /  <code>lte</code> ：大于 / 大于等于 / 小于 / 小于等于关系运算</li><li><code>range</code> ：指定范围查询（SQL 中的 <code>between…and…</code> ）</li><li><code>year</code>  /  <code>month</code>  /  <code>day</code>  /  <code>week_day</code>  /  <code>hour</code>  /  <code>minute</code>  /  <code>second</code> ：查询时间日期</li><li><code>isnull</code> ：查询空值（True）或非空值（False）</li><li><code>search</code> ：基于全文索引的全文检索（一般很少使用）</li><li><code>regex</code>  /  <code>iregex</code> ：基于正则表达式的模糊匹配查询</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django快速上手</title>
      <link href="/computer-science/python/basic/41.Django%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/computer-science/python/basic/41.Django%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="django快速上手"><a class="anchor" href="#django快速上手">#</a> Django 快速上手</h2><p>Web 开发的早期阶段，开发者需要手动编写每个页面，例如一个新闻门户网站，每天都要修改它的 HTML 页面，随着网站规模和体量的增大，这种做法一定是非常糟糕的。为了解决这个问题，开发人员想到了用程序来为 Web 服务器生成动态内容，也就是说网页中的动态内容不再通过手动编写而是通过程序自动生成。最早的时候，这项技术被称为 CGI（公共网关接口），当然随着时间的推移，CGI 暴露出的问题也越来越多，例如大量重复的样板代码，总体性能较为低下等。在时代呼唤新英雄的背景下，PHP、ASP、JSP 这类 Web 应用开发技术在上世纪 90 年代中后期如雨后春笋般涌现。通常我们说的 Web 应用是指通过浏览器来访问网络资源的应用程序，因为浏览器的普及性以及易用性，Web 应用使用起来方便简单，免除了安装和更新应用程序带来的麻烦；站在开发者的角度，也不用关心用户使用什么样的操作系统，甚至不用区分是 PC 端还是移动端。</p><h3 id="web应用机制和术语"><a class="anchor" href="#web应用机制和术语">#</a> Web 应用机制和术语</h3><p>下图向我们展示了 Web 应用的工作流程，其中涉及到的术语如下表所示。</p><p><img data-src="./res/web-application.png" alt="" /></p><blockquote><p>说明：相信有经验的读者会发现，这张图中其实还少了很多东西，例如反向代理服务器、数据库服务器、防火墙等，而且图中的每个节点在实际项目部署时可能是一组节点组成的集群。当然，如果你对这些没有什么概念也不要紧，继续下去就行了，后面会给大家一一讲解的。</p></blockquote><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>URL/URI</strong></td><td>统一资源定位符 / 统一资源标识符，网络资源的唯一标识</td></tr><tr><td><strong>域名</strong></td><td>与 Web 服务器地址对应的一个易于记忆的字符串名字</td></tr><tr><td><strong>DNS</strong></td><td>域名解析服务，可以将域名转换成对应的 IP 地址</td></tr><tr><td><strong>IP 地址</strong></td><td>网络上的主机的身份标识，通过 IP 地址可以区分不同的主机</td></tr><tr><td><strong>HTTP</strong></td><td>超文本传输协议，构建在 TCP 之上的应用级协议，万维网数据通信的基础</td></tr><tr><td><strong>反向代理</strong></td><td>代理客户端向服务器发出请求，然后将服务器返回的资源返回给客户端</td></tr><tr><td><strong>Web 服务器</strong></td><td>接受 HTTP 请求，然后返回 HTML 文件、纯文本文件、图像等资源给请求者</td></tr><tr><td><strong>Nginx</strong></td><td>高性能的 Web 服务器，也可以用作<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJThEJUU1JTkwJTkxJUU0JUJCJUEzJUU3JTkwJTg2">反向代理</span>，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI0JTlGJUU4JUJEJUJEJUU1JTlEJTg3JUU4JUExJUEx">负载均衡</span> 和 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFRUUCVFNyVCQyU5MyVFNSVBRCU5OA==">HTTP 缓存</span></td></tr></tbody></table><h4 id="http协议"><a class="anchor" href="#http协议">#</a> HTTP 协议</h4><p>这里我们先费一些笔墨来说说 HTTP 这个协议。HTTP（超文本传输协议）是构建于 TCP（传输控制协议）之上应用级协议，它利用了 TCP 提供的可靠的传输服务实现了 Web 应用中的数据交换。按照维基百科上的介绍，设计 HTTP 最初的目的是为了提供一种发布和接收<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFRNTA=="> HTML</span> 页面的方法，也就是说这个协议是浏览器和 Web 服务器之间传输的数据的载体。关于这个协议的详细信息以及目前的发展状况，大家可以阅读<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDgvaHR0cC5odG1s">《HTTP 协议入门》</span>、<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDUvaW50ZXJuZXRfcHJvdG9jb2xfc3VpdGVfcGFydF9pLmh0bWw=">《互联网协议入门》</span>系列以及<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMDkvaWxsdXN0cmF0aW9uLXNzbC5odG1s">《图解 HTTPS 协议》</span>这几篇文章进行了解。下图是我在四川省网络通信技术重点实验室学习和工作期间使用开源协议分析工具 Ethereal（抓包工具 WireShark 的前身）截取的访问百度首页时的 HTTP 请求和响应的报文（协议数据），由于 Ethereal 截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。</p><p>HTTP 请求（请求行 + 请求头 + 空行 +[消息体]）：</p><p><img data-src="./res/http-request.png" alt="" /></p><p>HTTP 响应（响应行 + 响应头 + 空行 + 消息体）：</p><p><img data-src="./res/http-response.png" alt="" /></p><blockquote><p><strong>说明</strong>：这两张图是在 2009 年 9 月 10 日凌晨获得的，但愿这两张如同泛黄的照片般的截图能帮助你了解 HTTP 到底是什么样子的。当然，如果没有专业的抓包工具，也可以通过浏览器提供的 “开发者工具” 来查看 HTTP 请求和响应的数据格式。</p></blockquote><h3 id="django概述"><a class="anchor" href="#django概述">#</a> Django 概述</h3><p>Python 的 Web 框架有上百个，比它的关键字还要多。所谓 Web 框架，就是用于开发 Web 服务器端应用的基础设施，说得通俗一点就是一系列封装好的模块和工具。事实上，即便没有 Web 框架，我们仍然可以通过 socket 或<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgwJTlBJUU3JTk0JUE4JUU3JUJEJTkxJUU1JTg1JUIzJUU2JThFJUE1JUU1JThGJUEz"> CGI</span> 来开发 Web 服务器端应用，但是这样做的成本和代价在商业项目中通常是不能接受的。通过 Web 框架，我们可以化繁为简，降低创建、更新、扩展应用程序的工作量。刚才我们说到 Python 有上百个 Web 框架，这些框架包括 Django、Flask、Tornado、Sanic、Pyramid、Bottle、Web2py、web.py 等。</p><p>在上述 Python 的 Web 框架中，Django 无疑是最有代表性的重量级选手，开发者可以基于 Django 快速的开发可靠的 Web 应用程序，因为它减少了 Web 开发中不必要的开销，对常用的设计和开发模式进行了封装，并对 MVC 架构提供了支持（Django 中称之为 MTV 架构）。MVC 是软件系统开发领域中一种放之四海而皆准的架构，它将系统中的组件分为模型（Model）、视图（View）和控制器（Controller）三个部分并借此实现模型（数据）和视图（显示）的解耦合。由于模型和视图进行了分离，所以需要一个中间人将解耦合的模型和视图联系起来，扮演这个角色的就是控制器。稍具规模的软件系统都会使用 MVC 架构（或者是从 MVC 演进出的其他架构），Django 项目中我们称之为 MTV，MTV 中的 M 跟 MVC 中的 M 没有区别，就是代表数据的模型，T 代表了网页模板（显示数据的视图），而 V 代表了视图函数，在 Django 框架中，视图函数和 Django 框架本身一起扮演了 MVC 中 C 的角色。</p><p><img data-src="./res/mvc.png" alt="" /></p><p>Django 框架诞生于 2003 年，它是一个在真正的应用中成长起来的项目，由劳伦斯出版集团旗下在线新闻网站的内容管理系统（CMS）研发团队（主要是 Adrian Holovaty 和 Simon Willison）开发，以比利时的吉普赛爵士吉他手 Django Reinhardt 来命名。Django 框架在 2005 年夏天作为开源框架发布，使用 Django 框架能用很短的时间构建出功能完备的网站，因为它代替程序员完成了那些重复乏味的劳动，剩下真正有意义的核心业务给程序员来开发，这一点就是对 DRY（Don't Repeat Yourself）理念的最好践行。许多成功的网站和应用都是基于 Python 语言进行开发的，国内比较有代表性的网站包括：知乎、豆瓣网、果壳网、搜狐闪电邮箱、101 围棋网、海报时尚网、背书吧、堆糖、手机搜狐网、咕咚、爱福窝、果库等，其中不乏使用了 Django 框架的产品。</p><h3 id="快速上手"><a class="anchor" href="#快速上手">#</a> 快速上手</h3><h4 id="第一个django项目"><a class="anchor" href="#第一个django项目">#</a> 第一个 Django 项目</h4><ol><li><p>检查 Python 环境：Django 1.11 需要 Python 2.7 或 Python 3.4 以上的版本；Django 2.0 需要 Python 3.4 以上的版本；Django 2.1 和 2.2 需要 Python 3.5 以上的版本；Django 3.0 需要 Python 3.6 以上版本。</p><blockquote><p><strong>说明</strong>：Django 框架不同版本所需的 Python 解释器环境，可以在 Django 官方文档的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRqYW5nb3Byb2plY3QuY29tL3poLWhhbnMvMy4wL2ZhcS9pbnN0YWxsLyNmYXEtcHl0aG9uLXZlcnNpb24tc3VwcG9ydA=="> FAQ</span> 中找到。</p></blockquote><p>可以在 macOS 的终端中输入下面的命令检查 Python 解释器版本，Windows 系统可以在命令行提示符中输入 <code>python --version</code> 。</p><pre><code class="language-Bash">python3 --version</code></pre><p>也可以在 Python 的交互式环境中执行下面的代码来查看 Python 解释器的版本。</p><pre><code class="language-Shell">import syssys.versionsys.version_info</code></pre></li><li><p>更新包管理工具并安装 Django 环境（用于创建 Django 项目）。</p><blockquote><p><strong>说明</strong>：在更新这个文档时，Django 最新的正式版本是 3.0.7，Django 3.0 提供了对 ASGI 的支持，可以实现全双工的异步通信，但是目前的使用体验一般，所以暂时不推荐大家使用 Django 3.0，下面我们安装的是 Django 2.2.13 版本。使用 <code>pip</code>  安装三方库和工具时，可以通过 <code>==</code>  来指定安装的版本。</p></blockquote><pre><code class="language-Bash">pip3 install -U pippip3 install django==2.2.13</code></pre></li><li><p>检查 Django 环境并使用 <code>django-admin</code>  命令创建 Django 项目（项目名称为 hellodjango）。</p><pre><code class="language-Shell">django-admin --versiondjango-admin startproject hellodjango</code></pre></li><li><p>用 PyCharm 打开创建好的 Djang 项目，并为其添加虚拟环境。</p><p><img data-src="res/pycharm-django-project.png" alt="" /></p><p>如上图所示，PyCharm 的项目浏览器中，最顶层的文件夹 <code>hellodjango</code>  是 Python 项目文件夹，这个文件夹的名字并不重要，Django 项目也不关心这个文件夹叫什么名字。该文件夹下有一个同名的文件夹，它是 Django 项目文件夹，其中包含了 <code>__init__.py</code> 、 <code>settings.py</code> 、 <code>urls.py</code> 、 <code>wsgi.py</code>  四个文件，与名为 <code>hellodjango</code>  的 Django 项目文件夹同级的还有一个名为 <code>manage.py</code>  的文件，这些文件的作用如下所示：</p><ul><li><code>hellodjango/__init__.py</code> ：空文件，告诉 Python 解释器这个目录应该被视为一个 Python 的包。</li><li><code>hellodjango/settings.py</code> ：Django 项目的配置文件。</li><li><code>hellodjango/urls.py</code> ：Django 项目的 URL 映射声明，就像是网站的 “目录”。</li><li><code>hellodjango/wsgi.py</code> ：项目运行在 WSGI 兼容 Web 服务器上的入口文件。</li><li><code>manage.py</code> ： 管理 Django 项目的脚本程序。</li></ul><blockquote><p>说明：WSGI 全称是 Web 服务器网关接口，维基百科上给出的解释是 “为 Python 语言定义的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI2JUIyJUU5JUEwJTgxJUU0JUJDJUJBJUU2JTlDJThEJUU1JTk5JUE4"> Web 服务器</span>和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJEJTkxJUU3JUJCJTlDJUU1JUJBJTk0JUU3JTk0JUE4JUU3JUE4JThCJUU1JUJBJThG"> Web 应用程序</span>或框架之间的一种简单而通用的接口”。</p></blockquote><p>创建虚拟环境的界面如下图所示。</p><p><img data-src="res/pycharm-django-virtual-environment.png" alt="pycharm-django-virtual-environment" /></p></li><li><p>安装项目依赖项。</p><p>方法一：打开 PyCharm 的终端，在终端中通过 <code>pip</code>  命令安装 Django 项目的依赖项。</p><blockquote><p><strong>说明</strong>：由于已经基于 Python 3 解释器环境为项目创建了虚拟环境，所以虚拟环境中的 <code>python</code>  命令对应的是 Python 3 的解释器，而 <code>pip</code>  命令对应的是 Python 3 的包管理工具。</p></blockquote><pre><code class="language-Shell">pip install django==2.2.13</code></pre><p>方法二：在 PyCharm 的偏好设置中，可以找到项目的解释器环境和已经安装的三方库，可以通过点击添加按钮来安装新的依赖项，需要提醒大家的是在安装 Django 依赖项时，需要指定版本号，否则将默认安装更新本文时最新的 3.0.7 版本。</p><p><img data-src="res/pycharm-install-django.png" alt="" /></p><p>下图展示了 Django 版本和 Python 版本的对应关系，请大家自行对号入座。</p><table><thead><tr><th>Django 版本</th><th>Python 版本</th></tr></thead><tbody><tr><td>1.8</td><td>2.7、3.2、3.3、3.4、3.5</td></tr><tr><td>1.9、1.10</td><td>2.7、3.4、3.5</td></tr><tr><td>1.11</td><td>2.7、3.4、3.5、3.6、3.7（Django 1.11.17）</td></tr><tr><td>2.0</td><td>3.4、3.5、3.6、3.7</td></tr><tr><td>2.1</td><td>3.5、3.6、3.7</td></tr><tr><td>2.2</td><td>3.5、3.6、3.7、3.8（Django 2.2.8）</td></tr><tr><td>3.0</td><td>3.6、3.7、3.8</td></tr></tbody></table></li><li><p>启动 Django 自带的服务器运行项目。</p><p>方法一：在 “Run” 菜单选择 “Edit Configuration”，配置 “Django server” 运行项目（适用于专业版 PyCharm）。</p><p><img data-src="res/pycharm-django-server.png" alt="" /></p><p>方法二：在 “Run” 菜单选择 “Edit Configuration”，配置运行 “Python” 程序运行项目（适用于专业版和社区版 PyCharm）。</p><p><img data-src="res/pycharm-python-manage.png" alt="" /></p><p>方法三：在 PyCharm 的终端（Terminal）中通过命令运行项目（适用于专业版和社区版 PyCharm）。</p><pre><code class="language-Shell">python manage.py runserver</code></pre></li><li><p>查看运行效果。</p></li></ol><p>在浏览器中输入 <code>http://127.0.0.1:8000</code>  访问我们的服务器，效果如下图所示。</p><p><img data-src="./res/django-index-1.png" alt="" /></p><blockquote><p><strong>说明</strong>：</p><ol><li>刚刚启动的 Django 自带的服务器只能用于开发和测试环境，因为这个服务器是纯 Python 编写的轻量级 Web 服务器，不适合在生产环境中使用。</li><li>如果修改了代码，不需要为了让修改的代码生效而重新启动 Django 自带的服务器。但是，在添加新的项目文件时，该服务器不会自动重新加载，这个时候就得手动重启服务器。</li><li>可以在终端中通过 <code>python manage.py help</code>  命令查看 Django 管理脚本程序可用的命令参数。</li><li>使用 <code>python manage.py runserver</code>  启动服务器时，可以在后面添加参数来指定 IP 地址和端口号，默认情况下启动的服务器将运行在本机的 <code>8000</code>  端口。</li><li>在终端中运行的服务器，可以通过 Ctrl+C 来停止它 。通过 PyCharm 的 “运行配置” 运行的服务器直接点击窗口上的关闭按钮就可以终止服务器的运行。</li><li>不能在同一个端口上启动多个服务器，因为会导致地址的冲突（端口是对 IP 地址的扩展，也是计算机网络地址的一部分）。</li></ol></blockquote><ol start="8"><li><p>修改项目的配置文件 <code>settings.py</code> 。</p><p>Django 是一个支持国际化和本地化的框架，因此刚才我们看到的 Django 项目的默认首页也是支持国际化的，我们可以通过修改配置文件将默认语言修改为中文，时区设置为东八区。</p><p>找到修改前的配置（在 <code>settings.py</code>  文件第 100 行以后）。</p><pre><code class="language-Python">LANGUAGE_CODE = 'en-us'TIME_ZONE = 'UTC'</code></pre><p>修改为以下内容。</p><pre><code class="language-Python">LANGUAGE_CODE = 'zh-hans'TIME_ZONE = 'Asia/Chongqing'</code></pre><p>刷新刚才的页面，可以看到修改语言代码和时区之后的结果。</p><p><img data-src="./res/django-index-2.png" alt="" /></p></li></ol><h4 id="创建自己的应用"><a class="anchor" href="#创建自己的应用">#</a> 创建自己的应用</h4><p>如果要开发自己的 Web 应用，需要先在 Django 项目中创建 “应用”，一个 Django 项目可以包含一个或多个应用。</p><ol><li><p>在 PyCharm 的终端中执行下面的命令，创建名为 <code>first</code>  的应用。</p><pre><code class="language-Shell">python manage.py startapp first</code></pre><p>执行上面的命令会在当前路径下创建 <code>first</code>  目录，其目录结构如下所示：</p><ul><li><code>__init__.py</code> ：一个空文件，告诉 Python 解释器这个目录应该被视为一个 Python 的包。</li><li><code>admin.py</code> ：可以用来注册模型，用于在 Django 框架自带的管理后台中管理模型。</li><li><code>apps.py</code> ：当前应用的配置文件。</li><li><code>migrations</code> ：存放与模型有关的数据库迁移信息。<ul><li><code>__init__.py</code> ：一个空文件，告诉 Python 解释器这个目录应该被视为一个 Python 的包。</li></ul></li><li><code>models.py</code> ：存放应用的数据模型（MTV 中的 M）。</li><li><code>tests.py</code> ：包含测试应用各项功能的测试类和测试函数。</li><li><code>views.py</code> ：处理用户 HTTP 请求并返回 HTTP 响应的函数或类（MTV 中的 V）。</li></ul></li><li><p>修改应用目录下的视图文件 <code>views.py</code> 。</p><pre><code class="language-Python">from django.http import HttpResponsedef show_index(request):    return HttpResponse('&lt;h1&gt;Hello, Django!&lt;/h1&gt;')</code></pre></li><li><p>修改 Django 项目目录下的 <code>urls.py</code>  文件，将视图函数和用户在浏览器中请求的路径对应。</p><pre><code class="language-Python">from django.contrib import adminfrom django.urls import path, includefrom first.views import show_indexurlpatterns = [    path('admin/', admin.site.urls),    path('hello/', show_index),]</code></pre></li><li><p>重新运行项目，并打开浏览器中访问 <code>http://127.0.0.1:8000/hello/</code> 。</p></li><li><p>上面我们通过代码为浏览器生成了内容，但仍然是静态内容，如果要生成动态内容，可以修改 <code>views.py</code>  文件并添加如下所示的代码。</p><pre><code class="language-Python">from random import samplefrom django.http import HttpResponsedef show_index(request):    fruits = [        'Apple', 'Orange', 'Pitaya', 'Durian', 'Waxberry', 'Blueberry',        'Grape', 'Peach', 'Pear', 'Banana', 'Watermelon', 'Mango'    ]    selected_fruits = sample(fruits, 3)    content = '&lt;h3&gt;今天推荐的水果是：&lt;/h3&gt;'    content += '&lt;hr&gt;'    content += '&lt;ul&gt;'    for fruit in selected_fruits:        content += f'&lt;li&gt;&#123;fruit&#125;&lt;/li&gt;'    content += '&lt;/ul&gt;'    return HttpResponse(content)</code></pre></li><li><p>刷新页面查看程序的运行结果，看看每次刷新的网页的时候，是不是可以看到不一样的内容。</p></li></ol><h4 id="使用模板"><a class="anchor" href="#使用模板">#</a> 使用模板</h4><p>上面通过拼接 HTML 代码的方式为浏览器生成动态内容的做法在实际开发中是无能接受的，因为实际项目中的前端页面可能非常复杂，无法用这种拼接动态内容的方式来完成，这一点大家一定能够想到。为了解决这个问题，我们可以提前准备一个模板页（MTV 中的 T），所谓模板页就是一个带占位符和模板指令的 HTML 页面。</p><p>Django 框架中有一个名为 <code>render</code>  的便捷函数可以来完成渲染模板的操作。所谓的渲染就是用数据替换掉模板页中的模板指令和占位符，当然这里的渲染称为后端渲染，即在服务器端完成页面的渲染再输出到浏览器中。后端渲染的做法在 Web 应用的访问量较大时，会让服务器承受较大的负担，所以越来越多的 Web 应用会选择前端渲染的方式，即服务器只提供页面所需的数据（通常是 JSON 格式），在浏览器中通过 JavaScript 代码获取这些数据并渲染页面上。关于前端渲染的内容，我们会在后续的课程中为大家讲解，目前我们使用的是通过模板页进行后端渲染的做法，具体步骤如下所示。</p><p>使用模板页的步骤如下所示。</p><ol><li><p>在项目目录下创建名为 templates 文件夹。</p><p><img data-src="res/pycharm-django-template.png" alt="" /></p></li><li><p>添加模板页 <code>index.html</code> 。</p><blockquote><p><strong>说明</strong>：实际项目开发中，静态页由前端开发者提供，后端开发者需要将静态页修改为模板页，以便通过 Python 程序对其进行渲染，这种做法就是上面提到的后端渲染。</p></blockquote><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;首页&lt;/title&gt;        &lt;style&gt;            #fruits &#123;                font-size: 1.25em;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;今天推荐的水果是：&lt;/h1&gt;        &lt;hr&gt;        &lt;ul id=&quot;fruits&quot;&gt;            &#123;% for fruit in fruits %&#125;               <li>&#123;&#123; fruit &#125;&#125;</li>               &#123;% endfor %&#125;        &lt;/ul&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>在上面的模板页中我们使用了 <code>&#123;&#123; fruit &#125;&#125;</code>  这样的模板占位符语法，也使用了 <code>&#123;% for %&#125;</code>  这样的模板指令，这些都是 Django 模板语言（DTL）的一部分。关于模板语法和指令，大家可以看看官方文档，相信这些内容还是很容易理解的，并不需要过多的赘述，大家也可以参考<a href="">官方文档</a>了解模板指令和语法。</p></li><li><p>修改 <code>views.py</code>  文件，调用 <code>render</code>  函数渲染模板页。</p><pre><code class="language-Python">from random import samplefrom django.shortcuts import renderdef show_index(request):    fruits = [        'Apple', 'Orange', 'Pitaya', 'Durian', 'Waxberry', 'Blueberry',        'Grape', 'Peach', 'Pear', 'Banana', 'Watermelon', 'Mango'    ]    selected_fruits = sample(fruits, 3)    return render(request, 'index.html', &#123;'fruits': selected_fruits&#125;)</code></pre><p><code>render</code>  函数的第一个参数是请求对象 request，第二个参数是我们要渲染的模板页的名字，第三个参数是要渲染到页面上的数据，我们通过一个字典将数据交给模板页，字典中的键就是模板页中使用的模板指令或占位符中的变量名。</p></li><li><p>到此为止，视图函数中的 <code>render</code>  还无法找到模板文件 <code>index.html</code> ，需要修改 <code>settings.py</code>  文件，配置模板文件所在的路径。修改 <code>settings.py</code>  文件，找到 <code>TEMPLATES</code>  配置，修改其中的 <code>DIRS</code>  配置。</p><pre><code class="language-Python">TEMPLATES = [    &#123;        'BACKEND': 'django.template.backends.django.DjangoTemplates',        'DIRS': [os.path.join(BASE_DIR, 'templates'), ],        'APP_DIRS': True,        'OPTIONS': &#123;            'context_processors': [                'django.template.context_processors.debug',                'django.template.context_processors.request',                'django.contrib.auth.context_processors.auth',                'django.contrib.messages.context_processors.messages',            ],        &#125;,    &#125;,]</code></pre></li><li><p>重新运行项目或直接刷新页面查看结果。</p></li></ol><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>至此，我们已经利用 Django 框架完成了一个非常小的 Web 应用，虽然它并没有任何的实际价值，但是可以通过这个项目对 Django 框架有一个感性的认识。学习 Django 最好的资料肯定是它的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRqYW5nb3Byb2plY3QuY29tL3poLWhhbnMvMi4wLw==">官方文档</span>，官方文档提供了对多国语言的支持，而且有新手教程引导初学者学习使用 Django 框架，建议大家通过阅读 Django 的官方文档来学习和使用这个框架。当然图灵社区出版的<span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9ib29rLzI2MzA=">《Django 基础教程》</span>也是非常适合初学者的入门级读物，有兴趣的读者可以点击链接进行购买。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive简介</title>
      <link href="/computer-science/python/basic/40.%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E5%92%8CHiveSQL/"/>
      <url>/computer-science/python/basic/40.%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E5%92%8CHiveSQL/</url>
      
        <content type="html"><![CDATA[<h2 id="hive简介"><a class="anchor" href="#hive简介">#</a> Hive 简介</h2><p>Hive 是 Facebook 开源的一款基于 Hadoop 的数据仓库工具，是目前应用最广泛的大数据处理解决方案，它能将 SQL 查询转变为 MapReduce（Google 提出的一个软件架构，用于大规模数据集的并行运算）任务，对 SQL 提供了完美的支持，能够非常方便的实现大数据统计。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMjAyMTAwODA2MDgucG5n">https://gitee.com/jackfrued/mypic/raw/master/20220210080608.png</span>&quot;&gt;</p><blockquote><p><strong>说明</strong>：可以通过<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWR1cmVrYS5jby9ibG9nL2hhZG9vcC1lY29zeXN0ZW0="> https://www.edureka.co/blog/hadoop-ecosystem</span> 来了解 Hadoop 生态圈。</p></blockquote><p>如果要简单的介绍 Hive，那么以下两点是其核心：</p><ol><li>把 HDFS 中结构化的数据映射成表。</li><li>通过把 Hive-SQL 进行解析和转换，最终生成一系列基于 Hadoop 的 MapReduce 任务 / Spark 任务，通过执行这些任务完成对数据的处理。也就是说，即便不学习 Java、Scala 这样的编程语言，一样可以实现对数据的处理。</li></ol><p>Hive 和传统关系型数据库的对比如下表所示。</p><table><thead><tr><th></th><th>Hive</th><th>RDBMS</th></tr></thead><tbody><tr><td>查询语言</td><td>HQL</td><td>SQL</td></tr><tr><td>存储数据</td><td>HDFS</td><td>本地文件系统</td></tr><tr><td>执行方式</td><td>MapReduce / Spark</td><td>Executor</td></tr><tr><td>执行延迟</td><td>高</td><td>低</td></tr><tr><td>数据规模</td><td>大</td><td>小</td></tr></tbody></table><h3 id="准备工作"><a class="anchor" href="#准备工作">#</a> 准备工作</h3><ol><li><p>搭建如下图所示的大数据平台。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20220210080638.png" alt="bigdata-basic-env" /></p></li><li><p>通过 Client 节点访问大数据平台。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20220210080655.png" alt="bigdata-vpc" /></p></li><li><p>创建文件 Hadoop 的文件系统。</p><pre><code class="language-Shell">hadoop fs -mkdir /datahadoop fs -chmod g+w /data</code></pre></li><li><p>将准备好的数据文件拷贝到 Hadoop 文件系统中。</p><pre><code class="language-Shell">hadoop fs -put /home/ubuntu/data/* /data</code></pre></li></ol><h3 id="创建删除数据库"><a class="anchor" href="#创建删除数据库">#</a> 创建 / 删除数据库</h3><p>创建。</p><pre><code class="language-SQL">create database if not exists demo;</code></pre><p>或</p><pre><code class="language-Shell">hive -e &quot;create database demo;&quot;</code></pre><p>删除。</p><pre><code class="language-SQL">drop database if exists demo;</code></pre><p>切换。</p><pre><code class="language-SQL">use demo;</code></pre><h3 id="数据类型"><a class="anchor" href="#数据类型">#</a> 数据类型</h3><p>Hive 的数据类型如下所示。</p><p>基本数据类型。</p><table><thead><tr><th>数据类型</th><th>占用空间</th><th>支持版本</th></tr></thead><tbody><tr><td>tinyint</td><td>1-Byte</td><td></td></tr><tr><td>smallint</td><td>2-Byte</td><td></td></tr><tr><td>int</td><td>4-Byte</td><td></td></tr><tr><td>bigint</td><td>8-Byte</td><td></td></tr><tr><td>boolean</td><td></td><td></td></tr><tr><td>float</td><td>4-Byte</td><td></td></tr><tr><td>double</td><td>8-Byte</td><td></td></tr><tr><td>string</td><td></td><td></td></tr><tr><td>binary</td><td></td><td>0.8 版本</td></tr><tr><td>timestamp</td><td></td><td>0.8 版本</td></tr><tr><td>decimal</td><td></td><td>0.11 版本</td></tr><tr><td>char</td><td></td><td>0.13 版本</td></tr><tr><td>varchar</td><td></td><td>0.12 版本</td></tr><tr><td>date</td><td></td><td>0.12 版本</td></tr></tbody></table><p>复杂数据类型。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>struct</td><td>和 C 语言中的结构体类似</td><td><code>struct&lt;first_name:string, last_name:string&gt;</code></td></tr><tr><td>map</td><td>由键值对构成的元素的集合</td><td><code>map&lt;string,int&gt;</code></td></tr><tr><td>array</td><td>具有相同类型的变量的容器</td><td><code>array&lt;string&gt;</code></td></tr></tbody></table><h3 id="创建和使用表"><a class="anchor" href="#创建和使用表">#</a> 创建和使用表</h3><ol><li><p>创建内部表。</p><pre><code class="language-SQL">create table if not exists user_info (user_id string,user_name string, sex string,age int,city string,firstactivetime string,level int,extra1 string,extra2 map&lt;string,string&gt;)row format delimited fields terminated by '\t'collection items terminated by ','map keys terminated by ':'lines terminated by '\n'stored as textfile;</code></pre></li><li><p>加载数据。</p><pre><code class="language-SQL">load data local inpath '/home/ubuntu/data/user_info/user_info.txt' overwrite into table user_info;</code></pre><p>或</p><pre><code class="language-SQL">load data inpath '/data/user_info/user_info.txt' overwrite into table user_info;</code></pre></li><li><p>创建分区表。</p><pre><code class="language-SQL">create table if not exists user_trade (user_name string,piece int,price double,pay_amount double,goods_category string,pay_time bigint)  partitioned by (dt string)row format delimited fields terminated by '\t';</code></pre></li><li><p>设置动态分区。</p><pre><code class="language-SQL">set hive.exec.dynamic.partition=true;set hive.exec.dynamic.partition.mode=nonstrict;set hive.exec.max.dynamic.partitions=10000;set hive.exec.max.dynamic.partitions.pernode=10000;</code></pre></li><li><p>拷贝数据（Shell 命令）。</p><pre><code class="language-Shell">hdfs dfs -put /home/ubuntu/data/user_trade/* /user/hive/warehouse/demo.db/user_trade</code></pre></li><li><p>修复分区表。</p><pre><code class="language-SQL">msck repair table user_trade;</code></pre></li></ol><h3 id="查询"><a class="anchor" href="#查询">#</a> 查询</h3><h4 id="基本语法"><a class="anchor" href="#基本语法">#</a> 基本语法</h4><pre><code class="language-SQL">select user_name from user_info where city='beijing' and sex='female' limit 10;select user_name, piece, pay_amount from user_trade where dt='2019-03-24' and goods_category='food';</code></pre><h4 id="group-by"><a class="anchor" href="#group-by">#</a> group by</h4><pre><code class="language-SQL">-- 查询2019年1月到4月，每个品类有多少人购买，累计金额是多少select goods_category, count(distinct user_name) as user_num, sum(pay_amount) as total from user_trade where dt between '2019-01-01' and '2019-04-30' group by goods_category;</code></pre><pre><code class="language-SQL">-- 查询2019年4月支付金额超过5万元的用户select user_name, sum(pay_amount) as total from user_trade where dt between '2019-04-01' and '2019-04-30' group by user_name having sum(pay_amount) &gt; 50000;</code></pre><h4 id="order-by"><a class="anchor" href="#order-by">#</a> order by</h4><pre><code class="language-SQL">-- 查询2019年4月支付金额最多的用户前5名select user_name, sum(pay_amount) as total from user_trade where dt between '2019-04-01' and '2019-04-30' group by user_name order by total desc limit 5;</code></pre><h4 id="常用函数"><a class="anchor" href="#常用函数">#</a> 常用函数</h4><ol><li><code>from_unixtime</code> ：将时间戳转换成日期</li><li><code>unix_timestamp</code> ：将日期转换成时间戳</li><li><code>datediff</code> ：计算两个日期的时间差</li><li><code>if</code> ：根据条件返回不同的值</li><li><code>substr</code> ：字符串取子串</li><li><code>get_json_object</code> ：从 JSON 字符串中取出指定的 <code>key</code>  对应的 <code>value</code> ，如： <code>get_json_object(info, '$.first_name')</code> 。</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python程序接入MySQL数据库</title>
      <link href="/computer-science/python/basic/39.Python%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/computer-science/python/basic/39.Python%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="python程序接入mysql数据库"><a class="anchor" href="#python程序接入mysql数据库">#</a> Python 程序接入 MySQL 数据库</h2><p>在 Python3 中，我们可以使用 <code>mysqlclient</code>  或者 <code>pymysql</code>  三方库来接入 MySQL 数据库并实现数据持久化操作。二者的用法完全相同，只是导入的模块名不一样。我们推荐大家使用纯 Python 的三方库 <code>pymysql</code> ，因为它更容易安装成功。下面我们仍然以之前创建的名为 <code>hrs</code>  的数据库为例，为大家演示如何通过 Python 程序操作 MySQL 数据库实现数据持久化操作。</p><h3 id="建库建表"><a class="anchor" href="#建库建表">#</a> 建库建表</h3><pre><code class="language-SQL">-- 创建名为hrs的数据库并指定默认的字符集create database `hrs` default character set utf8mb4;-- 切换到hrs数据库use `hrs`;-- 创建部门表create table `tb_dept`(`dno` int not null comment '编号',`dname` varchar(10) not null comment '名称',`dloc` varchar(20) not null comment '所在地',primary key (`dno`));-- 插入4个部门insert into `tb_dept` values     (10, '会计部', '北京'),    (20, '研发部', '成都'),    (30, '销售部', '重庆'),    (40, '运维部', '深圳');-- 创建员工表create table `tb_emp`(`eno` int not null comment '员工编号',`ename` varchar(20) not null comment '员工姓名',`job` varchar(20) not null comment '员工职位',`mgr` int comment '主管编号',`sal` int not null comment '员工月薪',`comm` int comment '每月补贴',`dno` int not null comment '所在部门编号',primary key (`eno`),constraint `fk_emp_mgr` foreign key (`mgr`) references tb_emp (`eno`),constraint `fk_emp_dno` foreign key (`dno`) references tb_dept (`dno`));-- 插入14个员工insert into `tb_emp` values     (7800, '张三丰', '总裁', null, 9000, 1200, 20),    (2056, '乔峰', '分析师', 7800, 5000, 1500, 20),    (3088, '李莫愁', '设计师', 2056, 3500, 800, 20),    (3211, '张无忌', '程序员', 2056, 3200, null, 20),    (3233, '丘处机', '程序员', 2056, 3400, null, 20),    (3251, '张翠山', '程序员', 2056, 4000, null, 20),    (5566, '宋远桥', '会计师', 7800, 4000, 1000, 10),    (5234, '郭靖', '出纳', 5566, 2000, null, 10),    (3344, '黄蓉', '销售主管', 7800, 3000, 800, 30),    (1359, '胡一刀', '销售员', 3344, 1800, 200, 30),    (4466, '苗人凤', '销售员', 3344, 2500, null, 30),    (3244, '欧阳锋', '程序员', 3088, 3200, null, 20),    (3577, '杨过', '会计', 5566, 2200, null, 10),    (3588, '朱九真', '会计', 5566, 2500, null, 10);</code></pre><h3 id="接入mysql"><a class="anchor" href="#接入mysql">#</a> 接入 MySQL</h3><p>首先，我们可以在命令行或者 PyCharm 的终端中通过下面的命令安装 <code>pymysql</code> ，如果需要接入 MySQL 8，还需要安装一个名为 <code>cryptography</code>  的三方库来支持 MySQL 8 的密码认证方式。</p><pre><code class="language-Shell">pip install pymysql cryptography</code></pre><p>使用 <code>pymysql</code>  操作 MySQL 的步骤如下所示：</p><ol><li>创建连接。MySQL 服务器启动后，提供了基于 TCP （传输控制协议）的网络服务。我们可以通过 <code>pymysql</code>  模块的 <code>connect</code>  函数连接 MySQL 服务器。在调用 <code>connect</code>  函数时，需要指定主机（ <code>host</code> ）、端口（ <code>port</code> ）、用户名（ <code>user</code> ）、口令（ <code>password</code> ）、数据库（ <code>database</code> ）、字符集（ <code>charset</code> ）等参数，该函数会返回一个 <code>Connection</code>  对象。</li><li>获取游标。连接 MySQL 服务器成功后，接下来要做的就是向数据库服务器发送 SQL 语句，MySQL 会执行接收到的 SQL 并将执行结果通过网络返回。要实现这项操作，需要先通过连接对象的 <code>cursor</code>  方法获取游标（ <code>Cursor</code> ）对象。</li><li>发出 SQL。通过游标对象的 <code>execute</code>  方法，我们可以向数据库发出 SQL 语句。</li><li>如果执行 <code>insert</code> 、 <code>delete</code>  或 <code>update</code>  操作，需要根据实际情况提交或回滚事务。因为创建连接时，默认开启了事务环境，在操作完成后，需要使用连接对象的 <code>commit</code>  或 <code>rollback</code>  方法，实现事务的提交或回滚， <code>rollback</code>  方法通常会放在异常捕获代码块 <code>except</code>  中。如果执行 <code>select</code>  操作，需要通过游标对象抓取查询的结果，对应的方法有三个，分别是： <code>fetchone</code> 、 <code>fetchmany</code>  和 <code>fetchall</code> 。其中 <code>fetchone</code>  方法会抓取到一条记录，并以元组或字典的方式返回； <code>fetchmany</code>  和 <code>fetchall</code>  方法会抓取到多条记录，以嵌套元组或列表装字典的方式返回。</li><li>关闭连接。在完成持久化操作后，请不要忘记关闭连接，释放外部资源。我们通常会在 <code>finally</code>  代码块中使用连接对象的 <code>close</code>  方法来关闭连接。</li></ol><h3 id="代码实操"><a class="anchor" href="#代码实操">#</a> 代码实操</h3><p>下面，我们通过代码实操的方式为大家演示上面说的五个步骤。</p><h4 id="插入数据"><a class="anchor" href="#插入数据">#</a> 插入数据</h4><pre><code class="language-Python">import pymysqlno = int(input('部门编号: '))name = input('部门名称: ')location = input('部门所在地: ')# 1. 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4')try:    # 2. 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        affected_rows = cursor.execute(            'insert into `tb_dept` values (%s, %s, %s)',            (no, name, location)        )        if affected_rows == 1:            print('新增部门成功!!!')    # 4. 提交事务（transaction）    conn.commit()except pymysql.MySQLError as err:    # 4. 回滚事务    conn.rollback()    print(type(err), err)finally:    # 5. 关闭连接释放资源    conn.close()</code></pre><blockquote><p><strong>说明</strong>：上面的 <code>127.0.0.1</code>  称为回环地址，它代表的是本机。下面的 <code>guest</code>  是我提前创建好的用户，该用户拥有对 <code>hrs</code>  数据库的 <code>insert</code> 、 <code>delete</code> 、 <code>update</code>  和 <code>select</code>  权限。我们不建议大家在项目中直接使用 <code>root</code>  超级管理员账号访问数据库，这样做实在是太危险了。我们可以使用下面的命令创建名为 <code>guest</code>  的用户并为其授权。</p><pre><code class="language-SQL">create user 'guest'@'%' identified by 'Guest.618';grant insert, delete, update, select on `hrs`.* to 'guest'@'%';</code></pre></blockquote><p>如果要插入大量数据，建议使用游标对象的 <code>executemany</code>  方法做批处理（一个 <code>insert</code>  操作后面跟上多组数据），大家可以尝试向一张表插入 10000 条记录，然后看看不使用批处理一条条的插入和使用批处理有什么差别。游标对象的 <code>executemany</code>  方法第一个参数仍然是 SQL 语句，第二个参数可以是包含多组数据的列表或元组。</p><h4 id="删除数据"><a class="anchor" href="#删除数据">#</a> 删除数据</h4><pre><code class="language-Python">import pymysqlno = int(input('部门编号: '))# 1. 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4',                       autocommit=True)try:    # 2. 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        affected_rows = cursor.execute(            'delete from `tb_dept` where `dno`=%s',            (no, )        )        if affected_rows == 1:            print('删除部门成功!!!')finally:    # 5. 关闭连接释放资源    conn.close()</code></pre><blockquote><p><strong>说明</strong>：如果不希望每次 SQL 操作之后手动提交或回滚事务，可以 <code>connect</code>  函数中加一个名为 <code>autocommit</code>  的参数并将它的值设置为 <code>True</code> ，表示每次执行 SQL 成功后自动提交。但是我们建议大家手动提交或回滚，这样可以根据实际业务需要来构造事务环境。如果不愿意捕获异常并进行处理，可以在 <code>try</code>  代码块后直接跟 <code>finally</code>  块，省略 <code>except</code>  意味着发生异常时，代码会直接崩溃并将异常栈显示在终端中。</p></blockquote><h4 id="更新数据"><a class="anchor" href="#更新数据">#</a> 更新数据</h4><pre><code class="language-Python">import pymysqlno = int(input('部门编号: '))name = input('部门名称: ')location = input('部门所在地: ')# 1. 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4')try:    # 2. 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        affected_rows = cursor.execute(            'update `tb_dept` set `dname`=%s, `dloc`=%s where `dno`=%s',            (name, location, no)        )        if affected_rows == 1:            print('更新部门信息成功!!!')    # 4. 提交事务    conn.commit()except pymysql.MySQLError as err:    # 4. 回滚事务    conn.rollback()    print(type(err), err)finally:    # 5. 关闭连接释放资源    conn.close()</code></pre><h4 id="查询数据"><a class="anchor" href="#查询数据">#</a> 查询数据</h4><ol><li>查询部门表的数据。</li></ol><pre><code class="language-Python">import pymysql# 1. 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4')try:    # 2. 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        cursor.execute('select `dno`, `dname`, `dloc` from `tb_dept`')        # 4. 通过游标对象抓取数据        row = cursor.fetchone()        while row:            print(row)            row = cursor.fetchone()except pymysql.MySQLError as err:    print(type(err), err)finally:    # 5. 关闭连接释放资源    conn.close()</code></pre><blockquote><p><strong>说明</strong>：上面的代码中，我们通过构造一个 <code>while</code>  循环实现了逐行抓取查询结果的操作。这种方式特别适合查询结果有非常多行的场景。因为如果使用 <code>fetchall</code>  一次性将所有记录抓取到一个嵌套元组中，会造成非常大的内存开销，这在很多场景下并不是一个好主意。如果不愿意使用 <code>while</code>  循环，还可以考虑使用 <code>iter</code>  函数构造一个迭代器来逐行抓取数据，有兴趣的读者可以自行研究。</p></blockquote><ol start="2"><li>分页查询员工表的数据。</li></ol><pre><code class="language-Python">import pymysqlpage = int(input('页码: '))size = int(input('大小: '))# 1. 创建连接（Connection）con = pymysql.connect(host='127.0.0.1', port=3306,                      user='guest', password='Guest.618',                      database='hrs', charset='utf8')try:    # 2. 获取游标对象（Cursor）    with con.cursor(pymysql.cursors.DictCursor) as cursor:        # 3. 通过游标对象向数据库服务器发出SQL语句        cursor.execute(            'select `eno`, `ename`, `job`, `sal` from `tb_emp` order by `sal` desc limit %s,%s',            ((page - 1) * size, size)        )        # 4. 通过游标对象抓取数据        for emp_dict in cursor.fetchall():            print(emp_dict)finally:    # 5. 关闭连接释放资源    con.close()</code></pre><h3 id="案例讲解"><a class="anchor" href="#案例讲解">#</a> 案例讲解</h3><p>下面我们为大家讲解一个将数据库表数据导出到 Excel 文件的例子，我们需要先安装 <code>openpyxl</code>  三方库，命令如下所示。</p><pre><code class="language-Bash">pip install openpyxl</code></pre><p>接下来，我们通过下面的代码实现了将数据库 <code>hrs</code>  中所有员工的编号、姓名、职位、月薪、补贴和部门名称导出到一个 Excel 文件中。</p><pre><code class="language-Python">import openpyxlimport pymysql# 创建工作簿对象workbook = openpyxl.Workbook()# 获得默认的工作表sheet = workbook.active# 修改工作表的标题sheet.title = '员工基本信息'# 给工作表添加表头sheet.append(('工号', '姓名', '职位', '月薪', '补贴', '部门'))# 创建连接（Connection）conn = pymysql.connect(host='127.0.0.1', port=3306,                       user='guest', password='Guest.618',                       database='hrs', charset='utf8mb4')try:    # 获取游标对象（Cursor）    with conn.cursor() as cursor:        # 通过游标对象执行SQL语句        cursor.execute(            'select `eno`, `ename`, `job`, `sal`, coalesce(`comm`, 0), `dname` '            'from `tb_emp` natural join `tb_dept`'        )        # 通过游标抓取数据        row = cursor.fetchone()        while row:            # 将数据逐行写入工作表中            sheet.append(row)            row = cursor.fetchone()    # 保存工作簿    workbook.save('hrs.xlsx')except pymysql.MySQLError as err:    print(err)finally:    # 关闭连接释放资源    conn.close()</code></pre><p>大家可以参考上面的例子，试一试把 Excel 文件的数据导入到指定数据库的指定表中，看看是否可以成功。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入MySQL</title>
      <link href="/computer-science/python/basic/38.%E6%B7%B1%E5%85%A5MySQL/"/>
      <url>/computer-science/python/basic/38.%E6%B7%B1%E5%85%A5MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="深入mysql"><a class="anchor" href="#深入mysql">#</a> 深入 MySQL</h2><h3 id="索引"><a class="anchor" href="#索引">#</a> 索引</h3><p>索引是关系型数据库中用来提升查询性能最为重要的手段。关系型数据库中的索引就像一本书的目录，我们可以想象一下，如果要从一本书中找出某个知识点，但是这本书没有目录，这将是意见多么可怕的事情！我们估计得一篇一篇的翻下去，才能确定这个知识点到底在什么位置。创建索引虽然会带来存储空间上的开销，就像一本书的目录会占用一部分篇幅一样，但是在牺牲空间后换来的查询时间的减少也是非常显著的。</p><p>MySQL 数据库中所有数据类型的列都可以被索引。对于 MySQL 8.0 版本的 InnoDB 存储引擎来说，它支持三种类型的索引，分别是 B+ 树索引、全文索引和 R 树索引。这里，我们只介绍使用得最为广泛的 B+ 树索引。使用 B+ 树的原因非常简单，因为它是目前在基于磁盘进行海量数据存储和排序上最有效率的数据结构。B+ 树是一棵<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFNSVCOSVCMyVFOCVBMSVBMSVFNiVBMCU5MQ==">平衡树</span>，树的高度通常为 3 或 4，但是却可以保存从百万级到十亿级的数据，而从这些数据里面查询一条数据，只需要 3 次或 4 次 I/O 操作。</p><p>B+ 树由根节点、中间节点和叶子节点构成，其中叶子节点用来保存排序后的数据。由于记录在索引上是排序过的，因此在一个叶子节点内查找数据时可以使用二分查找，这种查找方式效率非常的高。当数据很少的时候，B+ 树只有一个根节点，数据也就保存在根节点上。随着记录越来越多，B+ 树会发生分裂，根节点不再保存数据，而是提供了访问下一层节点的指针，帮助快速确定数据在哪个叶子节点上。</p><p>在创建二维表时，我们通常都会为表指定主键列，主键列上默认会创建索引，而对于 MySQL InnoDB 存储引擎来说，因为它使用的是索引组织表这种数据存储结构，所以主键上的索引就是整张表的数据，而这种索引我们也将其称之为<strong>聚集索引</strong>（clustered index）。很显然，一张表只能有一个聚集索引，否则表的数据岂不是要保存多次。我们自己创建的索引都是二级索引（secondary index），更常见的叫法是<strong>非聚集索引</strong>（non-clustered index）。通过我们自定义的非聚集索引只能定位记录的主键，在获取数据时可能需要再通过主键上的聚集索引进行查询，这种现象称为 “回表”，因此通过非聚集索引检索数据通常比使用聚集索引检索数据要慢。</p><p>接下来我们通过一个简单的例子来说明索引的意义，比如我们要根据学生的姓名来查找学生，这个场景在实际开发中应该经常遇到，就跟通过商品名称查找商品是一个道理。我们可以使用 MySQL 的 <code>explain</code>  关键字来查看 SQL 的执行计划（数据库执行 SQL 语句的具体步骤）。</p><pre><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 11     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p>在上面的 SQL 执行计划中，有几项值得我们关注：</p><ol><li><code>select_type</code> ：查询的类型。<ul><li><code>SIMPLE</code> ：简单 SELECT，不需要使用 UNION 操作或子查询。</li><li><code>PRIMARY</code> ：如果查询包含子查询，最外层的 SELECT 被标记为 PRIMARY。</li><li><code>UNION</code> ：UNION 操作中第二个或后面的 SELECT 语句。</li><li><code>SUBQUERY</code> ：子查询中的第一个 SELECT。</li><li><code>DERIVED</code> ：派生表的 SELECT 子查询。</li></ul></li><li><code>table</code> ：查询对应的表。</li><li><code>type</code> ：MySQL 在表中找到满足条件的行的方式，也称为访问类型，包括： <code>ALL</code> （全表扫描）、 <code>index</code> （索引全扫描，只遍历索引树）、 <code>range</code> （索引范围扫描）、 <code>ref</code> （非唯一索引扫描）、 <code>eq_ref</code> （唯一索引扫描）、 <code>const</code>  /  <code>system</code> （常量级查询）、 <code>NULL</code> （不需要访问表或索引）。在所有的访问类型中，很显然 ALL 是性能最差的，它代表的全表扫描是指要扫描表中的每一行才能找到匹配的行。</li><li><code>possible_keys</code> ：MySQL 可以选择的索引，但是<strong>有可能不会使用</strong>。</li><li><code>key</code> ：MySQL 真正使用的索引，如果为 <code>NULL</code>  就表示没有使用索引。</li><li><code>key_len</code> ：使用的索引的长度，在不影响查询的情况下肯定是长度越短越好。</li><li><code>rows</code> ：执行查询需要扫描的行数，这是一个<strong>预估值</strong>。</li><li><code>extra</code> ：关于查询额外的信息。<ul><li><code>Using filesort</code> ：MySQL 无法利用索引完成排序操作。</li><li><code>Using index</code> ：只使用索引的信息而不需要进一步查表来获取更多的信息。</li><li><code>Using temporary</code> ：MySQL 需要使用临时表来存储结果集，常用于分组和排序。</li><li><code>Impossible where</code> ： <code>where</code>  子句会导致没有符合条件的行。</li><li><code>Distinct</code> ：MySQL 发现第一个匹配行后，停止为当前的行组合搜索更多的行。</li><li><code>Using where</code> ：查询的列未被索引覆盖，筛选条件并不是索引的前导列。</li></ul></li></ol><p>从上面的执行计划可以看出，当我们通过学生名字查询学生时实际上是进行了全表扫描，不言而喻这个查询性能肯定是非常糟糕的，尤其是在表中的行很多的时候。如果我们需要经常通过学生姓名来查询学生，那么就应该在学生姓名对应的列上创建索引，通过索引来加速查询。</p><pre><code class="language-SQL">create index idx_student_name on tb_student(stuname);</code></pre><p>再次查看刚才的 SQL 对应的执行计划。</p><pre><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 62          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>可以注意到，在对学生姓名创建索引后，刚才的查询已经不是全表扫描而是基于索引的查询，而且扫描的行只有唯一的一行，这显然大大的提升了查询的性能。MySQL 中还允许创建前缀索引，即对索引字段的前 N 个字符创建索引，这样的话可以减少索引占用的空间（但节省了空间很有可能会浪费时间，<strong>时间和空间是不可调和的矛盾</strong>），如下所示。</p><pre><code class="language-SQL">create index idx_student_name_1 on tb_student(stuname(1));</code></pre><p>上面的索引相当于是根据学生姓名的第一个字来创建的索引，我们再看看 SQL 执行计划。</p><pre><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 5          ref: const         rows: 2     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p>不知道大家是否注意到，这一次扫描的行变成了 2 行，因为学生表中有两个姓 “林” 的学生，我们只用姓名的第一个字作为索引的话，在查询时通过索引就会找到这两行。</p><p>如果要删除索引，可以使用下面的 SQL。</p><pre><code class="language-SQL">alter table tb_student drop index idx_student_name;</code></pre><p>或者</p><pre><code class="language-SQL">drop index idx_student_name on tb_student;</code></pre><p>在创建索引时，我们还可以使用复合索引、函数索引（MySQL 5.7 开始支持），用好复合索引实现<strong>索引覆盖</strong>可以减少不必要的排序和回表操作，这样就会让查询的性能成倍的提升，有兴趣的读者可以自行研究。</p><p>我们简单的为大家总结一下索引的设计原则：</p><ol><li><strong>最适合</strong>索引的列是出现在<strong> WHERE 子句</strong>和连接子句中的列。</li><li>索引列的基数越大（取值多、重复值少），索引的效果就越好。</li><li>使用<strong>前缀索引</strong>可以减少索引占用的空间，内存中可以缓存更多的索引。</li><li><strong>索引不是越多越好</strong>，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。</li><li>使用 InnoDB 存储引擎时，表的普通索引都会保存主键的值，所以<strong>主键要尽可能选择较短的数据类型</strong>，这样可以有效的减少索引占用的空间，提升索引的缓存效果。</li></ol><p>最后，还有一点需要说明，InnoDB 使用的 B-tree 索引，数值类型的列除了等值判断时索引会生效之外，使用 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>BETWEEN...AND... </code> 、 <code>&lt;&gt;</code>  时，索引仍然生效；对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他的情况会导致索引失效，这就意味着很有可能会做全表查询。</p><h3 id="视图"><a class="anchor" href="#视图">#</a> 视图</h3><p>视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的 SQL 语句。</p><p>使用视图可以获得以下好处：</p><ol><li>可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。</li><li>在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。</li><li>重用 SQL 语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。</li><li>视图可以返回与实体数据表不同格式的数据，在创建视图的时候可以对数据进行格式化处理。</li></ol><p>创建视图。</p><pre><code class="language-SQL">-- 创建视图create view `vw_avg_score` as     select `stu_id`, round(avg(`score`), 1) as `avg_score`     from `tb_record` group by `stu_id`;-- 基于已有的视图创建视图create view `vw_student_score` as     select `stu_name`, `avg_score`     from `tb_student` natural join `vw_avg_score`;</code></pre><blockquote><p><strong>提示</strong>：因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害。因此，在使用复杂的视图前，应该进行测试以确保其性能能够满足应用的需求。</p></blockquote><p>使用视图。</p><pre><code class="language-SQL">select * from `vw_student_score` order by `avg_score` desc;</code></pre><pre><code>+--------------+----------+| stuname      | avgscore |+--------------+----------+| 杨过         |     95.6 || 任我行       |     53.5 || 王语嫣       |     84.3 || 纪嫣然       |     73.8 || 岳不群       |     78.0 || 东方不败     |     88.0 || 项少龙       |     92.0 |+--------------+----------+</code></pre><p>既然视图是一张虚拟的表，那么视图的中的数据可以更新吗？视图的可更新性要视具体情况而定，以下类型的视图是不能更新的：</p><ol><li>使用了聚合函数（ <code>SUM</code> 、 <code>MIN</code> 、 <code>MAX</code> 、 <code>AVG</code> 、 <code>COUNT</code>  等）、 <code>DISTINCT</code> 、 <code>GROUP BY</code> 、 <code>HAVING</code> 、 <code>UNION</code>  或者 <code>UNION ALL</code>  的视图。</li><li><code>SELECT</code>  中包含了子查询的视图。</li><li><code>FROM</code>  子句中包含了一个不能更新的视图的视图。</li><li><code>WHERE</code>  子句的子查询引用了 <code>FROM</code>  子句中的表的视图。</li></ol><p>删除视图。</p><pre><code class="language-SQL">drop view vw_student_score;</code></pre><blockquote><p><strong>说明</strong>：如果希望更新视图，可以先用上面的命令删除视图，也可以通过 <code>create or replace view</code>  来更新视图。</p></blockquote><p>视图的规则和限制。</p><ol><li>视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。</li><li>创建视图时可以使用 <code>order by</code>  子句，但如果从视图中检索数据时也使用了 <code>order by</code> ，那么该视图中原先的 <code>order by</code>  会被覆盖。</li><li>视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。</li></ol><h3 id="函数"><a class="anchor" href="#函数">#</a> 函数</h3><p>MySQL 中的函数跟 Python 中的函数太多的差异，因为函数都是用来封装功能上相对独立且会被重复使用的代码的。如果非要找出一些差别来，那么 MySQL 中的函数是可以执行 SQL 语句的。下面的例子，我们通过自定义函数实现了截断超长字符串的功能。</p><pre><code class="language-SQL">delimiter $$create function truncate_string(    content varchar(10000),    max_length int unsigned) returns varchar(10000) no sqlbegin    declare result varchar(10000) default content;    if char_length(content) &gt; max_length then        set result = left(content, max_length);        set result = concat(result, '……');    end if;    return result;end $$delimiter ;</code></pre><blockquote><p><strong>说明 1</strong>：函数声明后面的 <code>no sql</code>  是声明函数体并没有使用 SQL 语句；如果函数体中需要通过 SQL 读取数据，需要声明为 <code>reads sql data</code> 。</p><p><strong>说明 2</strong>：定义函数前后的 <code>delimiter</code>  命令是为了修改定界符，因为函数体中的语句都是用 <code>;</code>  表示结束，如果不重新定义定界符，那么遇到的 <code>;</code>  的时候代码就会被截断执行，显然这不是我们想要的效果。</p></blockquote><p>在查询中调用自定义函数。</p><pre><code class="language-SQL">select truncate_string('和我在成都的街头走一走，直到所有的灯都熄灭了也不停留', 10) as short_string;</code></pre><pre><code>+--------------------------------------+| short_string                         |+--------------------------------------+| 和我在成都的街头走一……                 |+--------------------------------------+</code></pre><h3 id="过程"><a class="anchor" href="#过程">#</a> 过程</h3><p>过程（又称存储过程）是事先编译好存储在数据库中的一组 SQL 的集合，调用过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。其实迄今为止，我们使用的 SQL 语句都是针对一个或多个表的单条语句，但在实际开发中经常会遇到某个操作需要多条 SQL 语句才能完成的情况。例如，电商网站在受理用户订单时，需要做以下一系列的处理。</p><ol><li>通过查询来核对库存中是否有对应的物品以及库存是否充足。</li><li>如果库存有物品，需要锁定库存以确保这些物品不再卖给别人， 并且要减少可用的物品数量以反映正确的库存量。</li><li>如果库存不足，可能需要进一步与供应商进行交互或者至少产生一条系统提示消息。</li><li>不管受理订单是否成功，都需要产生流水记录，而且需要给对应的用户产生一条通知信息。</li></ol><p>我们可以通过过程将复杂的操作封装起来，这样不仅有助于保证数据的一致性，而且将来如果业务发生了变动，只需要调整和修改过程即可。对于调用过程的用户来说，过程并没有暴露数据表的细节，而且执行过程比一条条的执行一组 SQL 要快得多。</p><p>下面的过程实现了查询某门课程的最高分、最低分和平均分。</p><pre><code class="language-SQL">drop procedure if exists sp_score_stat;delimiter $$create procedure sp_score_stat(courseId int, out maxScore decimal(4,1), out minScore decimal(4,1),out avgScore decimal(4,1))beginselect max(score) into maxScore from tb_record where cou_id=courseId;select min(score) into minScore from tb_record where cou_id=courseId;select avg(score) into avgScore from tb_record where cou_id=courseId;end $$delimiter ;</code></pre><blockquote><p><strong>说明</strong>：在定义过程时，因为可能需要书写多条 SQL，而分隔这些 SQL 需要使用分号作为分隔符，如果这个时候，仍然用分号表示整段代码结束，那么定义过程的 SQL 就会出现错误，所以上面我们用 <code>delimiter $$</code>  将整段代码结束的标记定义为 <code>$$</code> ，那么代码中的分号将不再表示整段代码的结束，整段代码只会在遇到 <code>end $$</code>  时才会执行。在定义完过程后，通过 <code>delimiter ;</code>  将结束符重新改回成分号（恢复现场）。</p></blockquote><p>上面定义的过程有四个参数，其中第一个参数是输入参数，代表课程的编号，后面的参数都是输出参数，因为过程不能定义返回值，只能通过输出参数将执行结果带出，定义输出参数的关键字是 <code>out</code> ，默认情况下参数都是输入参数。</p><p>调用过程。</p><pre><code class="language-SQL">call sp_score_stat(1111, @a, @b, @c);</code></pre><p>获取输出参数的值。</p><pre><code class="language-SQL">select @a as 最高分, @b as 最低分, @c as 平均分;</code></pre><p>删除过程。</p><pre><code class="language-SQL">drop procedure sp_score_stat;</code></pre><p>在过程中，我们可以定义变量、条件，可以使用分支和循环语句，可以通过游标操作查询结果，还可以使用事件调度器，这些内容我们暂时不在此处进行介绍。虽然我们说了很多过程的好处，但是在实际开发中，如果频繁的使用过程并将大量复杂的运算放到过程中，会给据库服务器造成巨大的压力，而数据库往往都是性能瓶颈所在，使用过程无疑是雪上加霜的操作。所以，对于互联网产品开发，我们一般建议让数据库只做好存储，复杂的运算和处理交给应用服务器上的程序去完成，如果应用服务器变得不堪重负了，我们可以比较容易的部署多台应用服务器来分摊这些压力。</p><p>如果大家对上面讲到的视图、函数、过程包括我们没有讲到的触发器这些知识有兴趣，建议大家阅读 MySQL 的入门读物<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMjgxODk4Mi5odG1s">《MySQL 必知必会》</span>进行一般性了解即可，因为这些知识点在大家将来的工作中未必用得上，学了也可能仅仅是为了应付面试而已。</p><h3 id="mysql-新特性"><a class="anchor" href="#mysql-新特性">#</a> MySQL 新特性</h3><h4 id="json类型"><a class="anchor" href="#json类型">#</a> JSON 类型</h4><p>很多开发者在使用关系型数据库做数据持久化的时候，常常感到结构化的存储缺乏灵活性，因为必须事先设计好所有的列以及对应的数据类型。在业务发展和变化的过程中，如果需要修改表结构，这绝对是比较麻烦和难受的事情。从 MySQL 5.7 版本开始，MySQL 引入了对 JSON 数据类型的支持（MySQL 8.0 解决了 JSON 的日志性能瓶颈问题），用好 JSON 类型，其实就是打破了关系型数据库和非关系型数据库之间的界限，为数据持久化操作带来了更多的便捷。</p><p>JSON 类型主要分为 JSON 对象和 JSON 数组两种，如下所示。</p><ol><li>JSON 对象</li></ol><pre><code class="language-JSON">&#123;&quot;name&quot;: &quot;骆昊&quot;, &quot;tel&quot;: &quot;13122335566&quot;, &quot;QQ&quot;: &quot;957658&quot;&#125;</code></pre><ol start="2"><li>JSON 数组</li></ol><pre><code class="language-JSON">[1, 2, 3]</code></pre><pre><code class="language-JSON">[&#123;&quot;name&quot;: &quot;骆昊&quot;, &quot;tel&quot;: &quot;13122335566&quot;&#125;, &#123;&quot;name&quot;: &quot;王大锤&quot;, &quot;QQ&quot;: &quot;123456&quot;&#125;]</code></pre><p>哪些地方需要用到 JSON 类型呢？举一个简单的例子，现在很多产品的用户登录都支持多种方式，例如手机号、微信、QQ、新浪微博等，但是一般情况下我们又不会要求用户提供所有的这些信息，那么用传统的设计方式，就需要设计多个列来对应多种登录方式，可能还需要允许这些列存在空值，这显然不是很好的选择；另一方面，如果产品又增加了一种登录方式，那么就必然要修改之前的表结构，这就更让人痛苦了。但是，有了 JSON 类型，刚才的问题就迎刃而解了，我们可以做出如下所示的设计。</p><pre><code class="language-SQL">create table `tb_test`(`user_id` bigint unsigned,`login_info` json,primary key (`user_id`)) engine=innodb;insert into `tb_test` values     (1, '&#123;&quot;tel&quot;: &quot;13122335566&quot;, &quot;QQ&quot;: &quot;654321&quot;, &quot;wechat&quot;: &quot;jackfrued&quot;&#125;'),    (2, '&#123;&quot;tel&quot;: &quot;13599876543&quot;, &quot;weibo&quot;: &quot;wangdachui123&quot;&#125;');</code></pre><p>如果要查询用户的手机和微信号，可以用如下所示的 SQL 语句。</p><pre><code class="language-SQL">select     `user_id`,    json_unquote(json_extract(`login_info`, '$.tel')) as 手机号,    json_unquote(json_extract(`login_info`, '$.wechat')) as 微信 from `tb_test`;</code></pre><pre><code>+---------+-------------+-----------+| user_id | 手机号      | 微信       |+---------+-------------+-----------+|       1 | 13122335566 | jackfrued ||       2 | 13599876543 | NULL      |+---------+-------------+-----------+</code></pre><p>因为支持 JSON 类型，MySQL 也提供了配套的处理 JSON 数据的函数，就像上面用到的 <code>json_extract</code>  和 <code>json_unquote</code> 。当然，上面的 SQL 还有更为便捷的写法，如下所示。</p><pre><code class="language-SQL">select `user_id`,    `login_info` -&gt;&gt; '$.tel' as 手机号,    `login_info` -&gt;&gt; '$.wechat' as 微信from `tb_test`;</code></pre><p>再举个例子，如果我们的产品要实现用户画像功能（给用户打标签），然后基于用户画像给用户推荐平台的服务或消费品之类的东西，我们也可以使用 JSON 类型来保存用户画像数据，示意代码如下所示。</p><p>创建画像标签表。</p><pre><code class="language-SQL">create table `tb_tags`(`tag_id` int unsigned not null comment '标签ID',`tag_name` varchar(20) not null comment '标签名',primary key (`tag_id`)) engine=innodb;insert into `tb_tags` (`tag_id`, `tag_name`) values    (1, '70后'),    (2, '80后'),    (3, '90后'),    (4, '00后'),    (5, '爱运动'),    (6, '高学历'),    (7, '小资'),    (8, '有房'),    (9, '有车'),    (10, '爱看电影'),    (11, '爱网购'),    (12, '常点外卖');</code></pre><p>为用户打标签。</p><pre><code class="language-SQL">create table `tb_users_tags`(`user_id` bigint unsigned not null comment '用户ID',`user_tags` json not null comment '用户标签') engine=innodb;insert into `tb_users_tags` values     (1, '[2, 6, 8, 10]'),    (2, '[3, 10, 12]'),    (3, '[3, 8, 9, 11]');</code></pre><p>接下来，我们通过一组查询来了解 JSON 类型的巧妙之处。</p><ol><li><p>查询爱看电影（有 <code>10</code>  这个标签）的用户 ID。</p><pre><code class="language-SQL">select * from `tb_users` where 10 member of (user_tags-&gt;'$');</code></pre></li><li><p>查询爱看电影（有 <code>10</code>  这个标签）的 80 后（有 <code>2</code>  这个标签）用户 ID。</p><pre><code>select * from `tb_users` where json_contains(user_tags-&gt;'$', '[2, 10]');</code></pre></li><li><p>查询爱看电影或 80 后或 90 后的用户 ID。</p><pre><code class="language-SQL">select `user_id` from `tb_users_tags` where json_overlaps(user_tags-&gt;'$', '[2, 3, 10]');</code></pre></li></ol><blockquote><p><strong>说明</strong>：上面的查询用到了 <code>member of</code>  谓词和两个 JSON 函数， <code>json_contains</code>  可以检查 JSON 数组是否包含了指定的元素，而 <code>json_overlaps</code>  可以检查 JSON 数组是否与指定的数组有重叠部分。</p></blockquote><h4 id="窗口函数"><a class="anchor" href="#窗口函数">#</a> 窗口函数</h4><p>MySQL 从 8.0 开始支持窗口函数，大多数商业数据库和一些开源数据库早已提供了对窗口函数的支持，有的也将其称之为 OLAP（联机分析和处理）函数，听名字就知道跟统计和分析相关。为了帮助大家理解窗口函数，我们先说说窗口的概念。</p><p>窗口可以理解为记录的集合，窗口函数也就是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数。窗口函数和我们上面讲到的聚合函数比较容易混淆，二者的区别主要在于聚合函数是将多条记录聚合为一条记录，窗口函数是每条记录都会执行，执行后记录条数不会变。窗口函数不仅仅是几个函数，它是一套完整的语法，函数只是该语法的一部分，基本语法如下所示：</p><pre><code class="language-SQL">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用户排序的列名&gt;)</code></pre><p>上面语法中，窗口函数的位置可以放以下两种函数：</p><ol><li>专用窗口函数，包括： <code>lead</code> 、 <code>lag</code> 、 <code>first_value</code> 、 <code>last_value</code> 、 <code>rank</code> 、 <code>dense_rank</code>  和 <code>row_number</code>  等。</li><li>聚合函数，包括： <code>sum</code> 、 <code>avg</code> 、 <code>max</code> 、 <code>min</code>  和 <code>count</code>  等。</li></ol><p>下面为大家举几个使用窗口函数的简单例子，我们先用如下所示的 SQL 建库建表。</p><pre><code class="language-SQL">-- 创建名为hrs的数据库并指定默认的字符集create database `hrs` default charset utf8mb4;-- 切换到hrs数据库use `hrs`;-- 创建部门表create table `tb_dept`(`dno` int not null comment '编号',`dname` varchar(10) not null comment '名称',`dloc` varchar(20) not null comment '所在地',primary key (`dno`));-- 插入4个部门insert into `tb_dept` values     (10, '会计部', '北京'),    (20, '研发部', '成都'),    (30, '销售部', '重庆'),    (40, '运维部', '深圳');-- 创建员工表create table `tb_emp`(`eno` int not null comment '员工编号',`ename` varchar(20) not null comment '员工姓名',`job` varchar(20) not null comment '员工职位',`mgr` int comment '主管编号',`sal` int not null comment '员工月薪',`comm` int comment '每月补贴',`dno` int not null comment '所在部门编号',primary key (`eno`),constraint `fk_emp_mgr` foreign key (`mgr`) references tb_emp (`eno`),constraint `fk_emp_dno` foreign key (`dno`) references tb_dept (`dno`));-- 插入14个员工insert into `tb_emp` values     (7800, '张三丰', '总裁', null, 9000, 1200, 20),    (2056, '乔峰', '分析师', 7800, 5000, 1500, 20),    (3088, '李莫愁', '设计师', 2056, 3500, 800, 20),    (3211, '张无忌', '程序员', 2056, 3200, null, 20),    (3233, '丘处机', '程序员', 2056, 3400, null, 20),    (3251, '张翠山', '程序员', 2056, 4000, null, 20),    (5566, '宋远桥', '会计师', 7800, 4000, 1000, 10),    (5234, '郭靖', '出纳', 5566, 2000, null, 10),    (3344, '黄蓉', '销售主管', 7800, 3000, 800, 30),    (1359, '胡一刀', '销售员', 3344, 1800, 200, 30),    (4466, '苗人凤', '销售员', 3344, 2500, null, 30),    (3244, '欧阳锋', '程序员', 3088, 3200, null, 20),    (3577, '杨过', '会计', 5566, 2200, null, 10),    (3588, '朱九真', '会计', 5566, 2500, null, 10);</code></pre><p>例子 1：查询按月薪从高到低排在第 4 到第 6 名的员工的姓名和月薪。</p><pre><code class="language-SQL">select * from (select `ename`, `sal`,row_number() over (order by `sal` desc) as `rank`from `tb_emp`) `temp` where `rank` between 4 and 6;</code></pre><blockquote><p><strong>说明</strong>：上面使用的函数 <code>row_number()</code>  可以为每条记录生成一个行号，在实际工作中可以根据需要将其替换为 <code>rank()</code>  或 <code>dense_rank()</code>  函数，三者的区别可以参考官方文档或阅读<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85MjY1NDU3NA==">《通俗易懂的学会：SQL 窗口函数》</span>进行了解。在 MySQL 8 以前的版本，我们可以通过下面的方式来完成类似的操作。</p><pre><code class="language-SQL">select `rank`, `ename`, `sal` from (    select @a:=@a+1 as `rank`, `ename`, `sal`     from `tb_emp`, (select @a:=0) as t1 order by `sal` desc) t2 where `rank` between 4 and 6;</code></pre></blockquote><p>例子 2：查询每个部门月薪最高的两名的员工的姓名和部门名称。</p><pre><code class="language-SQL">select `ename`, `sal`, `dname` from (    select         `ename`, `sal`, `dno`,        rank() over (partition by `dno` order by `sal` desc) as `rank`    from `tb_emp`) as `temp` natural join `tb_dept` where `rank`&lt;=2;</code></pre><blockquote><p>说明：在 MySQL 8 以前的版本，我们可以通过下面的方式来完成类似的操作。</p><pre><code class="language-SQL">select `ename`, `sal`, `dname` from `tb_emp` as `t1` </code></pre></blockquote><p>natural join  <code>tb_dept</code> <br />where (<br />select count(*) from  <code>tb_emp</code>  as  <code>t2</code> <br />where  <code>t1</code> . <code>dno</code> = <code>t2</code> . <code>dno</code>  and  <code>t2</code> . <code>sal</code> &gt; <code>t1</code> . <code>sal</code> <br />)&lt;2 order by  <code>dno</code>  asc,  <code>sal</code>  desc;</p><blockquote><pre><code></code></pre></blockquote><h3 id="其他内容"><a class="anchor" href="#其他内容">#</a> 其他内容</h3><h4 id="范式理论"><a class="anchor" href="#范式理论">#</a> 范式理论</h4><p>范式理论是设计关系型数据库中二维表的指导思想。</p><ol><li>第一范式：数据表的每个列的值域都是由原子值组成的，不能够再分割。</li><li>第二范式：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系。</li><li>第三范式：所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。</li></ol><blockquote><p><strong>说明</strong>：实际工作中，出于效率的考虑，我们在设计表时很有可能做出反范式设计，即故意降低方式级别，增加冗余数据来获得更好的操作性能。</p></blockquote><h4 id="数据完整性"><a class="anchor" href="#数据完整性">#</a> 数据完整性</h4><ol><li><p>实体完整性 - 每个实体都是独一无二的</p><ul><li>主键（ <code>primary key</code> ） / 唯一约束（ <code>unique</code> ）</li></ul></li><li><p>引用完整性（参照完整性）- 关系中不允许引用不存在的实体</p><ul><li>外键（ <code>foreign key</code> ）</li></ul></li><li><p>域（domain）完整性 - 数据是有效的</p><ul><li><p>数据类型及长度</p></li><li><p>非空约束（ <code>not null</code> ）</p></li><li><p>默认值约束（ <code>default</code> ）</p></li><li><p>检查约束（ <code>check</code> ）</p><blockquote><p><strong>说明</strong>：在 MySQL 8.x 以前，检查约束并不起作用。</p></blockquote></li></ul></li></ol><h4 id="数据一致性"><a class="anchor" href="#数据一致性">#</a> 数据一致性</h4><ol><li><p>事务：一系列对数据库进行读 / 写的操作，这些操作要么全都成功，要么全都失败。</p></li><li><p>事务的 ACID 特性</p><ul><li>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li><li>一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态</li><li>隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li><li>持久性：已被提交的事务对数据库的修改应该永久保存在数据库中</li></ul></li><li><p>MySQL 中的事务操作</p><ul><li><p>开启事务环境</p><pre><code class="language-SQL">start transaction</code></pre></li><li><p>提交事务</p><pre><code class="language-SQL">commit</code></pre></li><li><p>回滚事务</p><pre><code class="language-SQL">rollback</code></pre></li></ul></li><li><p>查看事务隔离级别</p><pre><code class="language-SQL">show variables like 'transaction_isolation';</code></pre><pre><code>+-----------------------+-----------------+| Variable_name         | Value           |+-----------------------+-----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+-----------------+</code></pre><p>可以看出，MySQL 默认的事务隔离级别是 <code>REPEATABLE-READ</code> 。</p></li><li><p>修改（当前会话）事务隔离级别</p><pre><code class="language-SQL">set session transaction isolation level read committed;</code></pre><p>重新查看事务隔离级别，结果如下所示。</p><pre><code>+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+</code></pre></li></ol><p>关系型数据库的事务是一个很大的话题，因为当存在多个并发事务访问数据时，就有可能出现三类读数据的问题（脏读、不可重复读、幻读）和两类更新数据的问题（第一类丢失更新、第二类丢失更新）。想了解这五类问题的，可以阅读我发布在 CSDN 网站上的<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tmcnVlZC9hcnRpY2xlL2RldGFpbHMvNDQ5MjE5NDE=">《Java 面试题全集（上）》</span>一文的第 80 题。为了避免这些问题，关系型数据库底层是有对应的锁机制的，按锁定对象不同可以分为表级锁和行级锁，按并发事务锁定关系可以分为共享锁和独占锁。然而直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定适当的事务隔离级别，数据库就会通过分析 SQL 语句，然后为事务访问的资源加上合适的锁。此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的。想了解 MySQL 事务和锁的细节知识，推荐大家阅读进阶读物<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMTIyMDM5My5odG1s">《高性能 MySQL》</span>，这也是数据库方面的经典书籍。</p><p>ANSI/ISO SQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示。需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定到底使用哪种事务隔离级别，这个地方没有万能的原则。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMjEyMjUzMjcucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211121225327.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>关于 SQL 和 MySQL 的知识肯定远远不止上面列出的这些，比如 SQL 本身的优化、MySQL 性能调优、MySQL 运维相关工具、MySQL 数据的备份和恢复、监控 MySQL 服务、部署高可用架构等，这一系列的问题在这里都没有办法逐一展开来讨论，那就留到有需要的时候再进行讲解吧，各位读者也可以自行探索。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 和 MySQL 详解</title>
      <link href="/computer-science/python/basic/37.SQL%E8%AF%A6%E8%A7%A3/"/>
      <url>/computer-science/python/basic/37.SQL%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="sql-和-mysql-详解"><a class="anchor" href="#sql-和-mysql-详解">#</a> SQL 和 MySQL 详解</h2><h3 id="sql-详解"><a class="anchor" href="#sql-详解">#</a> SQL 详解</h3><p>我们通常可以将 SQL 分为四类，分别是 DDL（数据定义语言）、DML（数据操作语言）、DQL（数据查询语言）和 DCL（数据控制语言）。DDL 主要用于创建、删除、修改数据库中的对象，比如创建、删除和修改二维表，核心的关键字包括 <code>create</code> 、 <code>drop</code>  和 <code>alter</code> ；DML 主要负责数据的插入、删除和更新，关键词包括 <code>insert</code> 、 <code>delete</code>  和 <code>update</code> ；DQL 负责数据查询，最重要的一个关键词是 <code>select</code> ；DCL 通常用于授予和召回权限，核心关键词是 <code>grant</code>  和 <code>revoke</code> 。</p><blockquote><p><strong>说明</strong>：SQL 是不区分大小写的语言，为了书写和识别方便，下面的 SQL 都使用了小写字母来书写。</p></blockquote><h4 id="ddl数据定义语言"><a class="anchor" href="#ddl数据定义语言">#</a> DDL（数据定义语言）</h4><p>下面我们来实现一个选课系统的数据库，如下所示的 SQL 创建了名为 <code>school</code>  的数据库和五张表，分别是学院表（ <code>tb_college</code> ）、学生表（ <code>tb_student</code> ）、教师表（ <code>tb_teacher</code> ）、课程表（ <code>tb_course</code> ）和选课记录表（ <code>tb_record</code> ），其中学生和教师跟学院之间是多对一关系，课程跟老师之间也是多对一关系，学生和课程是多对多关系，选课记录表就是维持学生跟课程多对多关系的中间表。</p><pre><code class="language-SQL">-- 如果存在名为school的数据库就删除它drop database if exists `school`;-- 创建名为school的数据库并设置默认的字符集和排序方式create database `school` default character set utf8mb4 collate utf8mb4_general_ci;-- 切换到school数据库上下文环境use `school`;-- 创建学院表create table `tb_college`(`col_id` int unsigned auto_increment comment '编号',`col_name` varchar(50) not null comment '名称',`col_intro` varchar(500) default '' comment '介绍',primary key (`col_id`)) engine=innodb auto_increment=1 comment '学院表';-- 创建学生表create table `tb_student`(`stu_id` int unsigned not null comment '学号',`stu_name` varchar(20) not null comment '姓名',`stu_sex` boolean default 1 not null comment '性别',`stu_birth` date not null comment '出生日期',`stu_addr` varchar(255) default '' comment '籍贯',`col_id` int unsigned not null comment '所属学院',primary key (`stu_id`),constraint `fk_student_col_id` foreign key (`col_id`) references `tb_college` (`col_id`)) engine=innodb comment '学生表';-- 创建教师表create table `tb_teacher`(`tea_id` int unsigned not null comment '工号',`tea_name` varchar(20) not null comment '姓名',`tea_title` varchar(10) default '助教' comment '职称',`col_id` int unsigned not null comment '所属学院',primary key (`tea_id`),constraint `fk_teacher_col_id` foreign key (`col_id`) references `tb_college` (`col_id`)) engine=innodb comment '老师表';-- 创建课程表create table `tb_course`(`cou_id` int unsigned not null comment '编号',`cou_name` varchar(50) not null comment '名称',`cou_credit` int not null comment '学分',`tea_id` int unsigned not null comment '授课老师',primary key (`cou_id`),constraint `fk_course_tea_id` foreign key (`tea_id`) references `tb_teacher` (`tea_id`)) engine=innodb comment '课程表';-- 创建选课记录表create table `tb_record`(`rec_id` bigint unsigned auto_increment comment '选课记录号',`stu_id` int unsigned not null comment '学号',`cou_id` int unsigned not null comment '课程编号',`sel_date` date not null comment '选课日期',`score` decimal(4,1) comment '考试成绩',primary key (`rec_id`),constraint `fk_record_stu_id` foreign key (`stu_id`) references `tb_student` (`stu_id`),constraint `fk_record_cou_id` foreign key (`cou_id`) references `tb_course` (`cou_id`),constraint `uk_record_stu_cou` unique (`stu_id`, `cou_id`)) engine=innodb comment '选课记录表';</code></pre><p>上面的 DDL 有几个地方需要强调一下：</p><ul><li><p>创建数据库时，我们通过 <code>default character set utf8mb4</code>  指定了数据库默认使用的字符集为 <code>utf8mb4</code> （最大 <code>4</code>  字节的 <code>utf-8</code>  编码），我们推荐使用该字符集，它也是 MySQL 8.x 默认使用的字符集，因为它能够支持国际化编码，还可以存储 Emoji 字符。可以通过下面的命令查看 MySQL 支持的字符集以及默认的排序规则。</p><pre><code class="language-SQL">show character set;</code></pre><pre><code>+----------+---------------------------------+---------------------+--------+| Charset  | Description                     | Default collation   | Maxlen |+----------+---------------------------------+---------------------+--------+| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 || dec8     | DEC West European               | dec8_swedish_ci     |      1 || cp850    | DOS West European               | cp850_general_ci    |      1 || hp8      | HP West European                | hp8_english_ci      |      1 || koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 || latin1   | cp1252 West European            | latin1_swedish_ci   |      1 || latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 || swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 || ascii    | US ASCII                        | ascii_general_ci    |      1 || ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 || sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 || hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 || tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 || euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 || koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 || gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 || greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 || cp1250   | Windows Central European        | cp1250_general_ci   |      1 || gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 || latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 || armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 || utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 || ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 || cp866    | DOS Russian                     | cp866_general_ci    |      1 || keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 || macce    | Mac Central European            | macce_general_ci    |      1 || macroman | Mac West European               | macroman_general_ci |      1 || cp852    | DOS Central European            | cp852_general_ci    |      1 || latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 || utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 || cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 || utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 || utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 || cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 || cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 || utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 || binary   | Binary pseudo charset           | binary              |      1 || geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 || cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 || eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 || gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |+----------+---------------------------------+---------------------+--------+41 rows in set (0.00 sec)</code></pre><p>如果要设置 MySQL 服务启动时默认使用的字符集，可以修改 MySQL 的配置并添加以下内容。</p><pre><code class="language-INI">[mysqld]character-set-server=utf8</code></pre></li><li><p>在创建表的时候，可以自行选择底层的存储引擎。MySQL 支持多种存储引擎，可以通过 <code>show engines</code>  命令进行查看。MySQL 5.5 以后的版本默认使用的存储引擎是 InnoDB，它是我们推荐大家使用的存储引擎（因为更适合当下互联网应用对高并发、性能以及事务支持等方面的需求），为了 SQL 语句的向下兼容性，我们可以在建表语句结束处右圆括号的后面通过 <code>engine=innodb</code>  来指定使用 InnoDB 存储引擎。</p><pre><code class="language-SQL">show engines\G</code></pre><pre><code>*************************** 1. row ***************************      Engine: InnoDB     Support: DEFAULT     Comment: Supports transactions, row-level locking, and foreign keysTransactions: YES          XA: YES  Savepoints: YES*************************** 2. row ***************************      Engine: MRG_MYISAM     Support: YES     Comment: Collection of identical MyISAM tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 3. row ***************************      Engine: MEMORY     Support: YES     Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 4. row ***************************      Engine: BLACKHOLE     Support: YES     Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO          XA: NO  Savepoints: NO*************************** 5. row ***************************      Engine: MyISAM     Support: YES     Comment: MyISAM storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 6. row ***************************      Engine: CSV     Support: YES     Comment: CSV storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 7. row ***************************      Engine: ARCHIVE     Support: YES     Comment: Archive storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 8. row ***************************      Engine: PERFORMANCE_SCHEMA     Support: YES     Comment: Performance SchemaTransactions: NO          XA: NO  Savepoints: NO*************************** 9. row ***************************      Engine: FEDERATED     Support: NO     Comment: Federated MySQL storage engineTransactions: NULL          XA: NULL  Savepoints: NULL9 rows in set (0.00 sec)</code></pre><p>下面的表格对 MySQL 几种常用的数据引擎进行了简单的对比。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MRG_MYISAM</th><th>MEMORY</th><th>MyISAM</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>没有</td><td>有</td><td>有</td></tr><tr><td>事务</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B 树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td></tr><tr><td>全文检索</td><td>支持（5.6+）</td><td></td><td></td><td>支持</td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>数据缓存</td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中</td><td>低</td></tr><tr><td>存储空间使用</td><td>高</td><td>低</td><td></td><td>低</td></tr><tr><td>批量插入性能</td><td>低</td><td>高</td><td>高</td><td>高</td></tr><tr><td>是否支持外键</td><td>支持</td><td></td><td></td><td></td></tr></tbody></table><p>通过上面的比较我们可以了解到，InnoDB 是唯一能够支持外键、事务以及行锁的存储引擎，所以我们之前说它更适合互联网应用，而且在较新版本的 MySQL 中，它也是默认使用的存储引擎。</p></li><li><p>在定义表结构为每个字段选择数据类型时，如果不清楚哪个数据类型更合适，可以通过 MySQL 的帮助系统来了解每种数据类型的特性、数据的长度和精度等相关信息。</p><pre><code class="language-SQL">? data types</code></pre><pre><code>You asked for help about help category: &quot;Data Types&quot;For more information, type 'help &lt;item&gt;', where &lt;item&gt; is one of the followingtopics:   AUTO_INCREMENT   BIGINT   BINARY   BIT   BLOB   BLOB DATA TYPE   BOOLEAN   CHAR   CHAR BYTE   DATE   DATETIME   DEC   DECIMAL   DOUBLE   DOUBLE PRECISION   ENUM   FLOAT   INT   INTEGER   LONGBLOB   LONGTEXT   MEDIUMBLOB   MEDIUMINT   MEDIUMTEXT   SET DATA TYPE   SMALLINT   TEXT   TIME   TIMESTAMP   TINYBLOB   TINYINT   TINYTEXT   VARBINARY   VARCHAR   YEAR DATA TYPE</code></pre><pre><code class="language-SQL">? varchar</code></pre><pre><code>Name: 'VARCHAR'Description:[NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATEcollation_name]A variable-length string. M represents the maximum column length incharacters. The range of M is 0 to 65,535. The effective maximum lengthof a VARCHAR is subject to the maximum row size (65,535 bytes, which isshared among all columns) and the character set used. For example, utf8characters can require up to three bytes per character, so a VARCHARcolumn that uses the utf8 character set can be declared to be a maximumof 21,844 characters. Seehttp://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html.MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plusdata. The length prefix indicates the number of bytes in the value. AVARCHAR column uses one length byte if values require no more than 255bytes, two length bytes if values may require more than 255 bytes.*Note*:MySQL follows the standard SQL specification, and does not removetrailing spaces from VARCHAR values.VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is thestandard SQL way to define that a VARCHAR column should use somepredefined character set. MySQL uses utf8 as this predefined characterset. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html.NVARCHAR is shorthand for NATIONAL VARCHAR.URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html</code></pre><p>在数据类型的选择上，保存字符串数据通常都使用 <code>VARCHAR</code>  和 <code>CHAR</code>  两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于 InnoDB 存储引擎，行存储格式没有区分固定长度和可变长度列，因此 <code>VARCHAR</code>  类型和 <code>CHAR</code>  类型没有本质区别，后者不一定比前者性能更好。如果要保存的很大字符串，可以使用 <code>TEXT</code>  类型；如果要保存很大的字节串，可以使用 <code>BLOB</code> （二进制大对象）类型。在 MySQL 中， <code>TEXT</code>  和 <code>BLOB</code>  又分别包括 <code>TEXT</code> 、 <code>MEDIUMTEXT</code> 、 <code>LONGTEXT</code>  和 <code>BLOB</code> 、 <code>MEDIUMBLOB</code> 、 <code>LONGBLOB</code>  三种不同的类型，它们主要的区别在于存储数据的最大大小不同。保存浮点数可以用 <code>FLOAT</code>  或 <code>DOUBLE</code>  类型， <code>FLOAT</code>  已经不推荐使用了，而且在 MySQL 后续的版本中可能会被移除掉。而保存定点数应该使用 <code>DECIMAL</code>  类型。如果要保存时间日期， <code>DATETIME</code>  类型优于 <code>TIMESTAMP</code>  类型，因为前者能表示的时间日期范围更大。</p></li></ul><h4 id="dml数据操作语言"><a class="anchor" href="#dml数据操作语言">#</a> DML（数据操作语言）</h4><p>我们通过如下所示的 SQL 给上面创建的表添加数据。</p><pre><code class="language-SQL">use school;-- 插入学院数据insert into `tb_college`     (`col_name`, `col_intro`) values     ('计算机学院', '计算机学院1958年设立计算机专业，1981年建立计算机科学系，1998年设立计算机学院，2005年5月，为了进一步整合教学和科研资源，学校决定，计算机学院和软件学院行政班子合并统一运作、实行教学和学生管理独立运行的模式。 学院下设三个系：计算机科学与技术系、物联网工程系、计算金融系；两个研究所：图象图形研究所、网络空间安全研究院（2015年成立）；三个教学实验中心：计算机基础教学实验中心、IBM技术中心和计算机专业实验中心。'),    ('外国语学院', '外国语学院设有7个教学单位，6个文理兼收的本科专业；拥有1个一级学科博士授予点，3个二级学科博士授予点，5个一级学科硕士学位授权点，5个二级学科硕士学位授权点，5个硕士专业授权领域，同时还有2个硕士专业学位（MTI）专业；有教职员工210余人，其中教授、副教授80余人，教师中获得中国国内外名校博士学位和正在职攻读博士学位的教师比例占专任教师的60%以上。'),    ('经济管理学院', '经济学院前身是创办于1905年的经济科；已故经济学家彭迪先、张与九、蒋学模、胡寄窗、陶大镛、胡代光，以及当代学者刘诗白等曾先后在此任教或学习。');-- 插入学生数据insert into `tb_student`     (`stu_id`, `stu_name`, `stu_sex`, `stu_birth`, `stu_addr`, `col_id`) values    (1001, '杨过', 1, '1990-3-4', '湖南长沙', 1),    (1002, '任我行', 1, '1992-2-2', '湖南长沙', 1),    (1033, '王语嫣', 0, '1989-12-3', '四川成都', 1),    (1572, '岳不群', 1, '1993-7-19', '陕西咸阳', 1),    (1378, '纪嫣然', 0, '1995-8-12', '四川绵阳', 1),    (1954, '林平之', 1, '1994-9-20', '福建莆田', 1),    (2035, '东方不败', 1, '1988-6-30', null, 2),    (3011, '林震南', 1, '1985-12-12', '福建莆田', 3),    (3755, '项少龙', 1, '1993-1-25', '四川成都', 3),    (3923, '杨不悔', 0, '1985-4-17', '四川成都', 3);-- 插入老师数据insert into `tb_teacher`     (`tea_id`, `tea_name`, `tea_title`, `col_id`) values     (1122, '张三丰', '教授', 1),    (1133, '宋远桥', '副教授', 1),    (1144, '杨逍', '副教授', 1),    (2255, '范遥', '副教授', 2),    (3366, '韦一笑', default, 3);-- 插入课程数据insert into `tb_course`     (`cou_id`, `cou_name`, `cou_credit`, `tea_id`) values     (1111, 'Python程序设计', 3, 1122),    (2222, 'Web前端开发', 2, 1122),    (3333, '操作系统', 4, 1122),    (4444, '计算机网络', 2, 1133),    (5555, '编译原理', 4, 1144),    (6666, '算法和数据结构', 3, 1144),    (7777, '经贸法语', 3, 2255),    (8888, '成本会计', 2, 3366),    (9999, '审计学', 3, 3366);-- 插入选课数据insert into `tb_record`     (`stu_id`, `cou_id`, `sel_date`, `score`) values     (1001, 1111, '2017-09-01', 95),    (1001, 2222, '2017-09-01', 87.5),    (1001, 3333, '2017-09-01', 100),    (1001, 4444, '2018-09-03', null),    (1001, 6666, '2017-09-02', 100),    (1002, 1111, '2017-09-03', 65),    (1002, 5555, '2017-09-01', 42),    (1033, 1111, '2017-09-03', 92.5),    (1033, 4444, '2017-09-01', 78),    (1033, 5555, '2017-09-01', 82.5),    (1572, 1111, '2017-09-02', 78),    (1378, 1111, '2017-09-05', 82),    (1378, 7777, '2017-09-02', 65.5),    (2035, 7777, '2018-09-03', 88),    (2035, 9999, '2019-09-02', null),    (3755, 1111, '2019-09-02', null),    (3755, 8888, '2019-09-02', null),    (3755, 9999, '2017-09-01', 92);</code></pre><blockquote><p><strong>注意</strong>：上面的 <code>insert</code>  语句使用了批处理的方式来插入数据，这种做法插入数据的效率比较高。</p></blockquote><h4 id="dql数据查询语言"><a class="anchor" href="#dql数据查询语言">#</a> DQL（数据查询语言）</h4><p>接下来，我们完成如下所示的查询。</p><pre><code class="language-SQL">-- 查询所有学生的所有信息select * from `tb_student`;-- 查询学生的学号、姓名和籍贯(投影)select `stu_id`, `stu_name`, `stu_addr` from `tb_student`;-- 查询所有课程的名称及学分(投影和别名)select `cou_name` as 课程名称, `cou_credit` as 学分 from `tb_course`;-- 查询所有女学生的姓名和出生日期(筛选)select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0;-- 查询籍贯为“四川成都”的女学生的姓名和出生日期(筛选)select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0 and `stu_addr`='四川成都';-- 查询籍贯为“四川成都”或者性别为“女生”的学生select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0 or `stu_addr`='四川成都';-- 查询所有80后学生的姓名、性别和出生日期(筛选)select `stu_name`, `stu_sex`, `stu_birth` from `tb_student` where `stu_birth`&gt;='1980-1-1' and `stu_birth`&lt;='1989-12-31';select `stu_name`, `stu_sex`, `stu_birth` from `tb_student` where `stu_birth` between '1980-1-1' and '1989-12-31';-- 补充：将表示性别的 1 和 0 处理成 “男” 和 “女”select     `stu_name` as 姓名,     if(`stu_sex`, '男', '女') as 性别,     `stu_birth` as 出生日期from `tb_student` where `stu_birth` between '1980-1-1' and '1989-12-31';select     `stu_name` as 姓名,     case `stu_sex` when 1 then '男' else '女' end as 性别,     `stu_birth` as 出生日期from `tb_student` where `stu_birth` between '1980-1-1' and '1989-12-31';-- 查询学分大于2的课程的名称和学分(筛选)select `cou_name`, `cou_credit` from `tb_course` where `cou_credit`&gt;2;-- 查询学分是奇数的课程的名称和学分(筛选)select `cou_name`, `cou_credit` from `tb_course` where `cou_credit`%2&lt;&gt;0;select `cou_name`, `cou_credit` from `tb_course` where `cou_credit` mod 2&lt;&gt;0;-- 查询选择选了1111的课程考试成绩在90分以上的学生学号(筛选)select `stu_id` from `tb_record` where `cou_id`=1111 and `score`&gt;90;-- 查询名字叫“杨过”的学生的姓名和性别select `stu_name`, `stu_sex` from `tb_student` where `stu_name`='杨过';    -- 查询姓“杨”的学生姓名和性别(模糊)-- % - 通配符（wildcard），它可以匹配0个或任意多个字符select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like '杨%';-- 查询姓“杨”名字两个字的学生姓名和性别(模糊)-- _ - 通配符（wildcard），它可以精确匹配一个字符select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like '杨_';-- 查询姓“杨”名字三个字的学生姓名和性别(模糊)select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like '杨__';-- 查询名字中有“不”字或“嫣”字的学生的姓名(模糊)select `stu_name` from `tb_student` where `stu_name` like '%不%' or `stu_name` like '%嫣%';-- 将“岳不群”改名为“岳不嫣”，比较下面两个查询的区别update `tb_student` set `stu_name`='岳不嫣' where `stu_id`=1572;select `stu_name` from `tb_student` where `stu_name` like '%不%'union select `stu_name` from `tb_student` where `stu_name` like '%嫣%';select `stu_name` from `tb_student` where `stu_name` like '%不%'union all select `stu_name` from `tb_student` where `stu_name` like '%嫣%';-- 查询姓“杨”或姓“林”名字三个字的学生的姓名(正则表达式模糊查询)select `stu_name` from `tb_student` where `stu_name` regexp '[杨林].&#123;2&#125;';-- 查询没有录入籍贯的学生姓名(空值处理)select `stu_name` from `tb_student` where `stu_addr` is null;select `stu_name` from `tb_student` where `stu_addr` &lt;=&gt; null;-- 查询录入了籍贯的学生姓名(空值处理)select `stu_name` from `tb_student` where `stu_addr` is not null;-- 下面的查询什么也查不到，三值逻辑 --&gt; true / false / unknownselect `stu_name` from `tb_student` where `stu_addr`=null or `stu_addr`&lt;&gt;null;-- 查询学生选课的所有日期(去重)select distinct `sel_date` from `tb_record`;-- 查询学生的籍贯(去重)select distinct `stu_addr` from `tb_student` where `stu_addr` is not null;-- 查询男学生的姓名和生日按年龄从大到小排列(排序)-- 升序：从小到大 - asc，降序：从大到小 - descselect `stu_id`, `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=1 order by `stu_birth` asc, `stu_id` desc;-- 补充：将上面的生日换算成年龄(日期函数、数值函数)select     `stu_id` as 学号,    `stu_name` as 姓名,     floor(datediff(curdate(), `stu_birth`)/365) as 年龄from `tb_student` where `stu_sex`=1 order by 年龄 desc, `stu_id` desc;-- 查询年龄最大的学生的出生日期(聚合函数)select min(`stu_birth`) from `tb_student`;-- 查询年龄最小的学生的出生日期(聚合函数)select max(`stu_birth`) from `tb_student`;-- 查询编号为1111的课程考试成绩的最高分(聚合函数)select max(`score`) from `tb_record` where `cou_id`=1111;-- 查询学号为1001的学生考试成绩的最低分(聚合函数)select min(`score`) from `tb_record` where `stu_id`=1001;-- 查询学号为1001的学生考试成绩的平均分(聚合函数)select avg(`score`) from `tb_record` where `stu_id`=1001;select sum(`score`) / count(`score`) from `tb_record` where `stu_id`=1001;-- 查询学号为1001的学生考试成绩的平均分，如果有null值，null值算0分(聚合函数)select sum(`score`) / count(*) from `tb_record` where `stu_id`=1001;select avg(ifnull(`score`, 0)) from `tb_record` where `stu_id`=1001;-- 查询学号为1001的学生考试成绩的标准差(聚合函数)select std(`score`), variance(`score`) from `tb_record` where `stu_id`=1001;-- 查询男女学生的人数(分组和聚合函数)select     case `stu_sex` when 1 then '男' else '女' end as 性别,    count(*) as 人数from `tb_student` group by `stu_sex`;-- 查询每个学院学生人数(分组和聚合函数)select     `col_id` as 学院,    count(*) as 人数from `tb_student` group by `col_id` with rollup;-- 查询每个学院男女学生人数(分组和聚合函数)select     `col_id` as 学院,    if(`stu_sex`, '男', '女') as 性别,    count(*) as 人数from `tb_student` group by `col_id`, `stu_sex`;-- 查询每个学生的学号和平均成绩(分组和聚合函数)select     `stu_id`,     round(avg(`score`), 1) as avg_scorefrom `tb_record` group by `stu_id`;-- 查询平均成绩大于等于90分的学生的学号和平均成绩-- 分组以前的筛选使用where子句，分组以后的筛选使用having子句select     `stu_id`,     round(avg(`score`), 1) as avg_scorefrom `tb_record`group by `stu_id` having avg_score&gt;=90;-- 查询1111、2222、3333三门课程平均成绩大于等于90分的学生的学号和平均成绩select     `stu_id`,     round(avg(`score`), 1) as avg_scorefrom `tb_record` where `cou_id` in (1111, 2222, 3333)group by `stu_id` having avg_score&gt;=90;-- 查询年龄最大的学生的姓名(子查询/嵌套查询)-- 嵌套查询：把一个select的结果作为另一个select的一部分来使用select `stu_name` from `tb_student` where `stu_birth`=(    select min(`stu_birth`) from `tb_student`);-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)select `stu_name` from `tb_student` where `stu_id` in (    select `stu_id` from `tb_record`     group by `stu_id` having count(*)&gt;2);-- 查询学生的姓名、生日和所在学院名称select `stu_name`, `stu_birth`, `col_name` from `tb_student`, `tb_college` where `tb_student`.`col_id`=`tb_college`.`col_id`;select `stu_name`, `stu_birth`, `col_name` from `tb_student` inner join `tb_college` on `tb_student`.`col_id`=`tb_college`.`col_id`;select `stu_name`, `stu_birth`, `col_name` from `tb_student` natural join `tb_college`;-- 查询学生姓名、课程名称以及成绩(连接查询/联结查询)select `stu_name`, `cou_name`, `score` from `tb_student`, `tb_course`, `tb_record` where `tb_student`.`stu_id`=`tb_record`.`stu_id` and `tb_course`.`cou_id`=`tb_record`.`cou_id` and `score` is not null;select `stu_name`, `cou_name`, `score` from `tb_student` inner join `tb_record` on `tb_student`.`stu_id`=`tb_record`.`stu_id` inner join `tb_course` on `tb_course`.`cou_id`=`tb_record`.`cou_id` where `score` is not null;select `stu_name`, `cou_name`, `score` from `tb_student` natural join `tb_record` natural join `tb_course`where `score` is not null;-- 补充：上面的查询结果取前5条数据(分页查询)select `stu_name`, `cou_name`, `score` from `tb_student`, `tb_course`, `tb_record` where `tb_student`.`stu_id`=`tb_record`.`stu_id` and `tb_course`.`cou_id`=`tb_record`.`cou_id` and `score` is not null order by `score` desc limit 0,5;-- 补充：上面的查询结果取第6-10条数据(分页查询)select `stu_name`, `cou_name`, `score` from `tb_student`, `tb_course`, `tb_record` where `tb_student`.`stu_id`=`tb_record`.`stu_id` and `tb_course`.`cou_id`=`tb_record`.`cou_id` and `score` is not null order by `score` desc limit 5 offset 5;-- 补充：上面的查询结果取第11-15条数据(分页查询)select `stu_name`, `cou_name`, `score` from `tb_student`, `tb_course`, `tb_record` where `tb_student`.`stu_id`=`tb_record`.`stu_id` and `tb_course`.`cou_id`=`tb_record`.`cou_id` and `score` is not null order by `score` desc limit 5 offset 10;-- 查询选课学生的姓名和平均成绩(子查询和连接查询)select `stu_name`, `avg_score` from `tb_student` inner join (    select `stu_id` as `sid`, round(avg(`score`), 1) as avg_score     from `tb_record` group by `stu_id`) as `t2` on `stu_id`=`sid`;-- 查询学生的姓名和选课的数量select `stu_name`, `total` from `tb_student` as `t1`inner join (    select `stu_id`, count(*) as `total`    from `tb_record` group by `stu_id`) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;-- 查询每个学生的姓名和选课数量(左外连接和子查询)-- 左外连接：左表（写在join左边的表）的每条记录都可以查出来，不满足连表条件的地方填充null。select `stu_name`, coalesce(`total`, 0) as `total`from `tb_student` as `t1`left outer join (    select `stu_id`, count(*) as `total`    from `tb_record` group by `stu_id`) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;-- 修改选课记录表，去掉 stu_id 列的外键约束alter table `tb_record` drop foreign key `fk_record_stu_id`;-- 插入两条新纪录（注意：没有学号为 5566 的学生）insert into `tb_record` values    (default, 5566, 1111, '2019-09-02', 80),    (default, 5566, 2222, '2019-09-02', 70);-- 右外连接：右表（写在join右边的表）的每条记录都可以查出来，不满足连表条件的地方填充null。select `stu_name`, `total` from `tb_student` as `t1`right outer join (    select `stu_id`, count(*) as `total`    from `tb_record` group by `stu_id`) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;-- 全外连接：左表和右表的每条记录都可以查出来，不满足连表条件的地方填充null。-- 说明：MySQL不支持全外连接，所以用左外连接和右外连接的并集来表示。select `stu_name`, `total`from `tb_student` as `t1`left outer join (    select `stu_id`, count(*) as `total`    from `tb_record` group by `stu_id`) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`union select `stu_name`, `total` from `tb_student` as `t1`right outer join (    select `stu_id`, count(*) as `total`    from `tb_record` group by `stu_id`) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;</code></pre><p>上面的 DML 有几个地方需要加以说明：</p><ol><li><p>MySQL 目前的版本不支持全外连接，上面我们通过 <code>union</code>  操作，将左外连接和右外连接的结果求并集实现全外连接的效果。大家可以通过下面的图来加深对连表操作的认识。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMjExMzUxMTcucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211121135117.png</span>&quot; style=&quot;zoom:50%&quot;&gt;</p></li><li><p>MySQL 中支持多种类型的运算符，包括：算术运算符（ <code>+</code> 、 <code>-</code> 、 <code>*</code> 、 <code>/</code> 、 <code>%</code> ）、比较运算符（ <code>=</code> 、 <code>&lt;&gt;</code> 、 <code>&lt;=&gt;</code> 、 <code>&lt;</code> 、 <code>&lt;=</code> 、 <code>&gt;</code> 、 <code>&gt;=</code> 、 <code>BETWEEN...AND..</code> .、 <code>IN</code> 、 <code>IS NULL</code> 、 <code>IS NOT NULL</code> 、 <code>LIKE</code> 、 <code>RLIKE</code> 、 <code>REGEXP</code> ）、逻辑运算符（ <code>NOT</code> 、 <code>AND</code> 、 <code>OR</code> 、 <code>XOR</code> ）和位运算符（ <code>&amp;</code> 、 <code>|</code> 、 <code>^</code> 、 <code>~</code> 、 <code>&gt;&gt;</code> 、 <code>&lt;&lt;</code> ），我们可以在 DML 中使用这些运算符处理数据。</p></li><li><p>在查询数据时，可以在 <code>SELECT</code>  语句及其子句（如 <code>WHERE</code>  子句、 <code>ORDER BY</code>  子句、 <code>HAVING</code>  子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。</p><p>常用字符串函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>CONCAT</code></td><td>将多个字符串连接成一个字符串</td></tr><tr><td><code>FORMAT</code></td><td>将数值格式化成字符串并指定保留几位小数</td></tr><tr><td><code>FROM_BASE64</code>  /  <code>TO_BASE64</code></td><td>BASE64 解码 / 编码</td></tr><tr><td><code>BIN</code>  /  <code>OCT</code>  /  <code>HEX</code></td><td>将数值转换成二进制 / 八进制 / 十六进制字符串</td></tr><tr><td><code>LOCATE</code></td><td>在字符串中查找一个子串的位置</td></tr><tr><td><code>LEFT</code>  /  <code>RIGHT</code></td><td>返回一个字符串左边 / 右边指定长度的字符</td></tr><tr><td><code>LENGTH</code>  /  <code>CHAR_LENGTH</code></td><td>返回字符串的长度以字节 / 字符为单位</td></tr><tr><td><code>LOWER</code>  /  <code>UPPER</code></td><td>返回字符串的小写 / 大写形式</td></tr><tr><td><code>LPAD</code>  /  <code>RPAD</code></td><td>如果字符串的长度不足，在字符串左边 / 右边填充指定的字符</td></tr><tr><td><code>LTRIM</code>  /  <code>RTRIM</code></td><td>去掉字符串前面 / 后面的空格</td></tr><tr><td><code>ORD</code>  /  <code>CHAR</code></td><td>返回字符对应的编码 / 返回编码对应的字符</td></tr><tr><td><code>STRCMP</code></td><td>比较字符串，返回 - 1、0、1 分别表示小于、等于、大于</td></tr><tr><td><code>SUBSTRING</code></td><td>返回字符串指定范围的子串</td></tr></tbody></table><p>常用数值函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>ABS</code></td><td>返回一个数的绝度值</td></tr><tr><td><code>CEILING</code>  /  <code>FLOOR</code></td><td>返回一个数上取整 / 下取整的结果</td></tr><tr><td><code>CONV</code></td><td>将一个数从一种进制转换成另一种进制</td></tr><tr><td><code>CRC32</code></td><td>计算循环冗余校验码</td></tr><tr><td><code>EXP</code>  /  <code>LOG</code>  /  <code>LOG2</code>  /  <code>LOG10</code></td><td>计算指数 / 对数</td></tr><tr><td><code>POW</code></td><td>求幂</td></tr><tr><td><code>RAND</code></td><td>返回 [0,1) 范围的随机数</td></tr><tr><td><code>ROUND</code></td><td>返回一个数四舍五入后的结果</td></tr><tr><td><code>SQRT</code></td><td>返回一个数的平方根</td></tr><tr><td><code>TRUNCATE</code></td><td>截断一个数到指定的精度</td></tr><tr><td><code>SIN</code>  /  <code>COS</code>  /  <code>TAN</code>  /  <code>COT</code>  /  <code>ASIN</code>  /  <code>ACOS</code>  /  <code>ATAN</code></td><td>三角函数</td></tr></tbody></table><p>常用时间日期函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>CURDATE</code>  /  <code>CURTIME</code>  /  <code>NOW</code></td><td>获取当前日期 / 时间 / 日期和时间</td></tr><tr><td><code>ADDDATE</code>  /  <code>SUBDATE</code></td><td>将两个日期表达式相加 / 相减并返回结果</td></tr><tr><td><code>DATE</code>  /  <code>TIME</code></td><td>从字符串中获取日期 / 时间</td></tr><tr><td><code>YEAR</code>  /  <code>MONTH</code>  /  <code>DAY</code></td><td>从日期中获取年 / 月 / 日</td></tr><tr><td><code>HOUR</code>  /  <code>MINUTE</code>  /  <code>SECOND</code></td><td>从时间中获取时 / 分 / 秒</td></tr><tr><td><code>DATEDIFF</code>  /  <code>TIMEDIFF</code></td><td>返回两个时间日期表达式相差多少天 / 小时</td></tr><tr><td><code>MAKEDATE</code>  /  <code>MAKETIME</code></td><td>制造一个日期 / 时间</td></tr></tbody></table><p>常用流程函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>IF</code></td><td>根据条件是否成立返回不同的值</td></tr><tr><td><code>IFNULL</code></td><td>如果为 NULL 则返回指定的值否则就返回本身</td></tr><tr><td><code>NULLIF</code></td><td>两个表达式相等就返回 NULL 否则返回第一个表达式的值</td></tr></tbody></table><p>其他常用函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>MD5</code>  /  <code>SHA1</code>  /  <code>SHA2</code></td><td>返回字符串对应的哈希摘要</td></tr><tr><td><code>CHARSET</code>  /  <code>COLLATION</code></td><td>返回字符集 / 校对规则</td></tr><tr><td><code>USER</code>  /  <code>CURRENT_USER</code></td><td>返回当前用户</td></tr><tr><td><code>DATABASE</code></td><td>返回当前数据库名</td></tr><tr><td><code>VERSION</code></td><td>返回当前数据库版本</td></tr><tr><td><code>FOUND_ROWS</code>  /  <code>ROW_COUNT</code></td><td>返回查询到的行数 / 受影响的行数</td></tr><tr><td><code>LAST_INSERT_ID</code></td><td>返回最后一个自增主键的值</td></tr><tr><td><code>UUID</code>  /  <code>UUID_SHORT</code></td><td>返回全局唯一标识符</td></tr></tbody></table></li></ol><h4 id="dcl数据控制语言"><a class="anchor" href="#dcl数据控制语言">#</a> DCL（数据控制语言）</h4><p>数据控制语言用于给指定的用户授权或者从召回指定用户的指定权限，这组操作对数据库管理员来说比较重要，将一个用户的权限最小化（刚好够用）是非常重要的，对数据库的安全至关重要。</p><pre><code class="language-SQL">-- 创建名为 wangdachui 的账号并为其指定口令，允许该账号从任意主机访问create user 'wangdachui'@'%' identified by '123456';-- 授权 wangdachui 可以对名为school的数据库执行 select 和 insert 操作grant select, insert on `school`.* to 'wangdachui'@'%';-- 召回 wangdachui 对school数据库的 insert 权限revoke insert on `school`.* from 'wangdachui'@'%';</code></pre><blockquote><p><strong>说明</strong>：创建一个可以允许任意主机登录并且具有超级管理员权限的用户在现实中并不是一个明智的决定，因为一旦该账号的口令泄露或者被破解，数据库将会面临灾难级的风险。</p></blockquote><h3 id="mysql-详解"><a class="anchor" href="#mysql-详解">#</a> MySQL 详解</h3><h4 id="索引"><a class="anchor" href="#索引">#</a> 索引</h4><p>索引是关系型数据库中用来提升查询性能最为重要的手段。关系型数据库中的索引就像一本书的目录，我们可以想象一下，如果要从一本书中找出某个知识点，但是这本书没有目录，这将是意见多么可怕的事情！我们估计得一篇一篇的翻下去，才能确定这个知识点到底在什么位置。创建索引虽然会带来存储空间上的开销，就像一本书的目录会占用一部分篇幅一样，但是在牺牲空间后换来的查询时间的减少也是非常显著的。</p><p>MySQL 数据库中所有数据类型的列都可以被索引。对于 MySQL 8.0 版本的 InnoDB 存储引擎来说，它支持三种类型的索引，分别是 B+ 树索引、全文索引和 R 树索引。这里，我们只介绍使用得最为广泛的 B+ 树索引。使用 B+ 树的原因非常简单，因为它是目前在基于磁盘进行海量数据存储和排序上最有效率的数据结构。B+ 树是一棵<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFNSVCOSVCMyVFOCVBMSVBMSVFNiVBMCU5MQ==">平衡树</span>，树的高度通常为 3 或 4，但是却可以保存从百万级到十亿级的数据，而从这些数据里面查询一条数据，只需要 3 次或 4 次 I/O 操作。</p><p>B+ 树由根节点、中间节点和叶子节点构成，其中叶子节点用来保存排序后的数据。由于记录在索引上是排序过的，因此在一个叶子节点内查找数据时可以使用二分查找，这种查找方式效率非常的高。当数据很少的时候，B+ 树只有一个根节点，数据也就保存在根节点上。随着记录越来越多，B+ 树会发生分裂，根节点不再保存数据，而是提供了访问下一层节点的指针，帮助快速确定数据在哪个叶子节点上。</p><p>在创建二维表时，我们通常都会为表指定主键列，主键列上默认会创建索引，而对于 MySQL InnoDB 存储引擎来说，因为它使用的是索引组织表这种数据存储结构，所以主键上的索引就是整张表的数据，而这种索引我们也将其称之为<strong>聚集索引</strong>（clustered index）。很显然，一张表只能有一个聚集索引，否则表的数据岂不是要保存多次。我们自己创建的索引都是二级索引（secondary index），更常见的叫法是<strong>非聚集索引</strong>（non-clustered index）。通过我们自定义的非聚集索引只能定位记录的主键，在获取数据时可能需要再通过主键上的聚集索引进行查询，这种现象称为 “回表”，因此通过非聚集索引检索数据通常比使用聚集索引检索数据要慢。</p><p>接下来我们通过一个简单的例子来说明索引的意义，比如我们要根据学生的姓名来查找学生，这个场景在实际开发中应该经常遇到，就跟通过商品名称查找商品是一个道理。我们可以使用 MySQL 的 <code>explain</code>  关键字来查看 SQL 的执行计划（数据库执行 SQL 语句的具体步骤）。</p><pre><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 11     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p>在上面的 SQL 执行计划中，有几项值得我们关注：</p><ol><li><code>select_type</code> ：查询的类型。<ul><li><code>SIMPLE</code> ：简单 SELECT，不需要使用 UNION 操作或子查询。</li><li><code>PRIMARY</code> ：如果查询包含子查询，最外层的 SELECT 被标记为 PRIMARY。</li><li><code>UNION</code> ：UNION 操作中第二个或后面的 SELECT 语句。</li><li><code>SUBQUERY</code> ：子查询中的第一个 SELECT。</li><li><code>DERIVED</code> ：派生表的 SELECT 子查询。</li></ul></li><li><code>table</code> ：查询对应的表。</li><li><code>type</code> ：MySQL 在表中找到满足条件的行的方式，也称为访问类型，包括： <code>ALL</code> （全表扫描）、 <code>index</code> （索引全扫描，只遍历索引树）、 <code>range</code> （索引范围扫描）、 <code>ref</code> （非唯一索引扫描）、 <code>eq_ref</code> （唯一索引扫描）、 <code>const</code>  /  <code>system</code> （常量级查询）、 <code>NULL</code> （不需要访问表或索引）。在所有的访问类型中，很显然 ALL 是性能最差的，它代表的全表扫描是指要扫描表中的每一行才能找到匹配的行。</li><li><code>possible_keys</code> ：MySQL 可以选择的索引，但是<strong>有可能不会使用</strong>。</li><li><code>key</code> ：MySQL 真正使用的索引，如果为 <code>NULL</code>  就表示没有使用索引。</li><li><code>key_len</code> ：使用的索引的长度，在不影响查询的情况下肯定是长度越短越好。</li><li><code>rows</code> ：执行查询需要扫描的行数，这是一个<strong>预估值</strong>。</li><li><code>extra</code> ：关于查询额外的信息。<ul><li><code>Using filesort</code> ：MySQL 无法利用索引完成排序操作。</li><li><code>Using index</code> ：只使用索引的信息而不需要进一步查表来获取更多的信息。</li><li><code>Using temporary</code> ：MySQL 需要使用临时表来存储结果集，常用于分组和排序。</li><li><code>Impossible where</code> ： <code>where</code>  子句会导致没有符合条件的行。</li><li><code>Distinct</code> ：MySQL 发现第一个匹配行后，停止为当前的行组合搜索更多的行。</li><li><code>Using where</code> ：查询的列未被索引覆盖，筛选条件并不是索引的前导列。</li></ul></li></ol><p>从上面的执行计划可以看出，当我们通过学生名字查询学生时实际上是进行了全表扫描，不言而喻这个查询性能肯定是非常糟糕的，尤其是在表中的行很多的时候。如果我们需要经常通过学生姓名来查询学生，那么就应该在学生姓名对应的列上创建索引，通过索引来加速查询。</p><pre><code class="language-SQL">create index idx_student_name on tb_student(stuname);</code></pre><p>再次查看刚才的 SQL 对应的执行计划。</p><pre><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 62          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>可以注意到，在对学生姓名创建索引后，刚才的查询已经不是全表扫描而是基于索引的查询，而且扫描的行只有唯一的一行，这显然大大的提升了查询的性能。MySQL 中还允许创建前缀索引，即对索引字段的前 N 个字符创建索引，这样的话可以减少索引占用的空间（但节省了空间很有可能会浪费时间，<strong>时间和空间是不可调和的矛盾</strong>），如下所示。</p><pre><code class="language-SQL">create index idx_student_name_1 on tb_student(stuname(1));</code></pre><p>上面的索引相当于是根据学生姓名的第一个字来创建的索引，我们再看看 SQL 执行计划。</p><pre><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 5          ref: const         rows: 2     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p>不知道大家是否注意到，这一次扫描的行变成了 2 行，因为学生表中有两个姓 “林” 的学生，我们只用姓名的第一个字作为索引的话，在查询时通过索引就会找到这两行。</p><p>如果要删除索引，可以使用下面的 SQL。</p><pre><code class="language-SQL">alter table tb_student drop index idx_student_name;</code></pre><p>或者</p><pre><code class="language-SQL">drop index idx_student_name on tb_student;</code></pre><p>在创建索引时，我们还可以使用复合索引、函数索引（MySQL 5.7 开始支持），用好复合索引实现<strong>索引覆盖</strong>可以减少不必要的排序和回表操作，这样就会让查询的性能成倍的提升，有兴趣的读者可以自行研究。</p><p>我们简单的为大家总结一下索引的设计原则：</p><ol><li><strong>最适合</strong>索引的列是出现在<strong> WHERE 子句</strong>和连接子句中的列。</li><li>索引列的基数越大（取值多、重复值少），索引的效果就越好。</li><li>使用<strong>前缀索引</strong>可以减少索引占用的空间，内存中可以缓存更多的索引。</li><li><strong>索引不是越多越好</strong>，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。</li><li>使用 InnoDB 存储引擎时，表的普通索引都会保存主键的值，所以<strong>主键要尽可能选择较短的数据类型</strong>，这样可以有效的减少索引占用的空间，提升索引的缓存效果。</li></ol><p>最后，还有一点需要说明，InnoDB 使用的 B-tree 索引，数值类型的列除了等值判断时索引会生效之外，使用 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>BETWEEN...AND... </code> 、 <code>&lt;&gt;</code>  时，索引仍然生效；对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他的情况会导致索引失效，这就意味着很有可能会做全表查询。</p><h4 id="视图"><a class="anchor" href="#视图">#</a> 视图</h4><p>视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的 SQL 语句。</p><p>使用视图可以获得以下好处：</p><ol><li>可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。</li><li>在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。</li><li>重用 SQL 语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。</li><li>视图可以返回与实体数据表不同格式的数据，在创建视图的时候可以对数据进行格式化处理。</li></ol><p>创建视图。</p><pre><code class="language-SQL">-- 创建视图create view `vw_avg_score` as     select `stu_id`, round(avg(`score`), 1) as `avg_score`     from `tb_record` group by `stu_id`;-- 基于已有的视图创建视图create view `vw_student_score` as     select `stu_name`, `avg_score`     from `tb_student` natural join `vw_avg_score`;</code></pre><blockquote><p><strong>提示</strong>：因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害。因此，在使用复杂的视图前，应该进行测试以确保其性能能够满足应用的需求。</p></blockquote><p>使用视图。</p><pre><code class="language-SQL">select * from `vw_student_score` order by `avg_score` desc;</code></pre><pre><code>+--------------+----------+| stuname      | avgscore |+--------------+----------+| 杨过         |     95.6 || 任我行       |     53.5 || 王语嫣       |     84.3 || 纪嫣然       |     73.8 || 岳不群       |     78.0 || 东方不败     |     88.0 || 项少龙       |     92.0 |+--------------+----------+</code></pre><p>既然视图是一张虚拟的表，那么视图的中的数据可以更新吗？视图的可更新性要视具体情况而定，以下类型的视图是不能更新的：</p><ol><li>使用了聚合函数（ <code>SUM</code> 、 <code>MIN</code> 、 <code>MAX</code> 、 <code>AVG</code> 、 <code>COUNT</code>  等）、 <code>DISTINCT</code> 、 <code>GROUP BY</code> 、 <code>HAVING</code> 、 <code>UNION</code>  或者 <code>UNION ALL</code>  的视图。</li><li><code>SELECT</code>  中包含了子查询的视图。</li><li><code>FROM</code>  子句中包含了一个不能更新的视图的视图。</li><li><code>WHERE</code>  子句的子查询引用了 <code>FROM</code>  子句中的表的视图。</li></ol><p>删除视图。</p><pre><code class="language-SQL">drop view vw_student_score;</code></pre><blockquote><p><strong>说明</strong>：如果希望更新视图，可以先用上面的命令删除视图，也可以通过 <code>create or replace view</code>  来更新视图。</p></blockquote><p>视图的规则和限制。</p><ol><li>视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。</li><li>创建视图时可以使用 <code>order by</code>  子句，但如果从视图中检索数据时也使用了 <code>order by</code> ，那么该视图中原先的 <code>order by</code>  会被覆盖。</li><li>视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。</li></ol><h4 id="函数"><a class="anchor" href="#函数">#</a> 函数</h4><p>MySQL 中的函数跟 Python 中的函数太多的差异，因为函数都是用来封装功能上相对独立且会被重复使用的代码的。如果非要找出一些差别来，那么 MySQL 中的函数是可以执行 SQL 语句的。下面的例子，我们通过自定义函数实现了截断超长字符串的功能。</p><pre><code class="language-SQL">delimiter $$create function truncate_string(    content varchar(10000),    max_length int unsigned) returns varchar(10000) no sqlbegin    declare result varchar(10000) default content;    if char_length(content) &gt; max_length then        set result = left(content, max_length);        set result = concat(result, '……');    end if;    return result;end $$delimiter ;</code></pre><blockquote><p><strong>说明 1</strong>：函数声明后面的 <code>no sql</code>  是声明函数体并没有使用 SQL 语句；如果函数体中需要通过 SQL 读取数据，需要声明为 <code>reads sql data</code> 。</p><p><strong>说明 2</strong>：定义函数前后的 <code>delimiter</code>  命令是为了修改定界符，因为函数体中的语句都是用 <code>;</code>  表示结束，如果不重新定义定界符，那么遇到的 <code>;</code>  的时候代码就会被截断执行，显然这不是我们想要的效果。</p></blockquote><p>在查询中调用自定义函数。</p><pre><code class="language-SQL">select truncate_string('和我在成都的街头走一走，直到所有的灯都熄灭了也不停留', 10) as short_string;</code></pre><pre><code>+--------------------------------------+| short_string                         |+--------------------------------------+| 和我在成都的街头走一……                 |+--------------------------------------+</code></pre><h4 id="过程"><a class="anchor" href="#过程">#</a> 过程</h4><p>过程（又称存储过程）是事先编译好存储在数据库中的一组 SQL 的集合，调用过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。其实迄今为止，我们使用的 SQL 语句都是针对一个或多个表的单条语句，但在实际开发中经常会遇到某个操作需要多条 SQL 语句才能完成的情况。例如，电商网站在受理用户订单时，需要做以下一系列的处理。</p><ol><li>通过查询来核对库存中是否有对应的物品以及库存是否充足。</li><li>如果库存有物品，需要锁定库存以确保这些物品不再卖给别人， 并且要减少可用的物品数量以反映正确的库存量。</li><li>如果库存不足，可能需要进一步与供应商进行交互或者至少产生一条系统提示消息。</li><li>不管受理订单是否成功，都需要产生流水记录，而且需要给对应的用户产生一条通知信息。</li></ol><p>我们可以通过过程将复杂的操作封装起来，这样不仅有助于保证数据的一致性，而且将来如果业务发生了变动，只需要调整和修改过程即可。对于调用过程的用户来说，过程并没有暴露数据表的细节，而且执行过程比一条条的执行一组 SQL 要快得多。</p><p>下面的过程实现了查询某门课程的最高分、最低分和平均分。</p><pre><code class="language-SQL">drop procedure if exists sp_score_stat;delimiter $$create procedure sp_score_stat(courseId int, out maxScore decimal(4,1), out minScore decimal(4,1),out avgScore decimal(4,1))beginselect max(score) into maxScore from tb_record where cou_id=courseId;select min(score) into minScore from tb_record where cou_id=courseId;select avg(score) into avgScore from tb_record where cou_id=courseId;end $$delimiter ;</code></pre><blockquote><p><strong>说明</strong>：在定义过程时，因为可能需要书写多条 SQL，而分隔这些 SQL 需要使用分号作为分隔符，如果这个时候，仍然用分号表示整段代码结束，那么定义过程的 SQL 就会出现错误，所以上面我们用 <code>delimiter $$</code>  将整段代码结束的标记定义为 <code>$$</code> ，那么代码中的分号将不再表示整段代码的结束，整段代码只会在遇到 <code>end $$</code>  时才会执行。在定义完过程后，通过 <code>delimiter ;</code>  将结束符重新改回成分号（恢复现场）。</p></blockquote><p>上面定义的过程有四个参数，其中第一个参数是输入参数，代表课程的编号，后面的参数都是输出参数，因为过程不能定义返回值，只能通过输出参数将执行结果带出，定义输出参数的关键字是 <code>out</code> ，默认情况下参数都是输入参数。</p><p>调用过程。</p><pre><code class="language-SQL">call sp_score_stat(1111, @a, @b, @c);</code></pre><p>获取输出参数的值。</p><pre><code class="language-SQL">select @a as 最高分, @b as 最低分, @c as 平均分;</code></pre><p>删除过程。</p><pre><code class="language-SQL">drop procedure sp_score_stat;</code></pre><p>在过程中，我们可以定义变量、条件，可以使用分支和循环语句，可以通过游标操作查询结果，还可以使用事件调度器，这些内容我们暂时不在此处进行介绍。虽然我们说了很多过程的好处，但是在实际开发中，如果频繁的使用过程并将大量复杂的运算放到过程中，会给据库服务器造成巨大的压力，而数据库往往都是性能瓶颈所在，使用过程无疑是雪上加霜的操作。所以，对于互联网产品开发，我们一般建议让数据库只做好存储，复杂的运算和处理交给应用服务器上的程序去完成，如果应用服务器变得不堪重负了，我们可以比较容易的部署多台应用服务器来分摊这些压力。</p><p>如果大家对上面讲到的视图、函数、过程包括我们没有讲到的触发器这些知识有兴趣，建议大家阅读 MySQL 的入门读物<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMjgxODk4Mi5odG1s">《MySQL 必知必会》</span>进行一般性了解即可，因为这些知识点在大家将来的工作中未必用得上，学了也可能仅仅是为了应付面试而已。</p><h3 id="mysql-新特性"><a class="anchor" href="#mysql-新特性">#</a> MySQL 新特性</h3><h4 id="json类型"><a class="anchor" href="#json类型">#</a> JSON 类型</h4><p>很多开发者在使用关系型数据库做数据持久化的时候，常常感到结构化的存储缺乏灵活性，因为必须事先设计好所有的列以及对应的数据类型。在业务发展和变化的过程中，如果需要修改表结构，这绝对是比较麻烦和难受的事情。从 MySQL 5.7 版本开始，MySQL 引入了对 JSON 数据类型的支持（MySQL 8.0 解决了 JSON 的日志性能瓶颈问题），用好 JSON 类型，其实就是打破了关系型数据库和非关系型数据库之间的界限，为数据持久化操作带来了更多的便捷。</p><p>JSON 类型主要分为 JSON 对象和 JSON 数组两种，如下所示。</p><ol><li>JSON 对象</li></ol><pre><code class="language-JSON">&#123;&quot;name&quot;: &quot;骆昊&quot;, &quot;tel&quot;: &quot;13122335566&quot;, &quot;QQ&quot;: &quot;957658&quot;&#125;</code></pre><ol start="2"><li>JSON 数组</li></ol><pre><code class="language-JSON">[1, 2, 3]</code></pre><pre><code class="language-JSON">[&#123;&quot;name&quot;: &quot;骆昊&quot;, &quot;tel&quot;: &quot;13122335566&quot;&#125;, &#123;&quot;name&quot;: &quot;王大锤&quot;, &quot;QQ&quot;: &quot;123456&quot;&#125;]</code></pre><p>哪些地方需要用到 JSON 类型呢？举一个简单的例子，现在很多产品的用户登录都支持多种方式，例如手机号、微信、QQ、新浪微博等，但是一般情况下我们又不会要求用户提供所有的这些信息，那么用传统的设计方式，就需要设计多个列来对应多种登录方式，可能还需要允许这些列存在空值，这显然不是很好的选择；另一方面，如果产品又增加了一种登录方式，那么就必然要修改之前的表结构，这就更让人痛苦了。但是，有了 JSON 类型，刚才的问题就迎刃而解了，我们可以做出如下所示的设计。</p><pre><code class="language-SQL">create table `tb_test`(`user_id` bigint unsigned,`login_info` json,primary key (`user_id`)) engine=innodb;insert into `tb_test` values     (1, '&#123;&quot;tel&quot;: &quot;13122335566&quot;, &quot;QQ&quot;: &quot;654321&quot;, &quot;wechat&quot;: &quot;jackfrued&quot;&#125;'),    (2, '&#123;&quot;tel&quot;: &quot;13599876543&quot;, &quot;weibo&quot;: &quot;wangdachui123&quot;&#125;');</code></pre><p>如果要查询用户的手机和微信号，可以用如下所示的 SQL 语句。</p><pre><code class="language-SQL">select     `user_id`,    json_unquote(json_extract(`login_info`, '$.tel')) as 手机号,    json_unquote(json_extract(`login_info`, '$.wechat')) as 微信 from `tb_test`;</code></pre><pre><code>+---------+-------------+-----------+| user_id | 手机号      | 微信       |+---------+-------------+-----------+|       1 | 13122335566 | jackfrued ||       2 | 13599876543 | NULL      |+---------+-------------+-----------+</code></pre><p>因为支持 JSON 类型，MySQL 也提供了配套的处理 JSON 数据的函数，就像上面用到的 <code>json_extract</code>  和 <code>json_unquote</code> 。当然，上面的 SQL 还有更为便捷的写法，如下所示。</p><pre><code class="language-SQL">select `user_id`,    `login_info` -&gt;&gt; '$.tel' as 手机号,    `login_info` -&gt;&gt; '$.wechat' as 微信from `tb_test`;</code></pre><p>再举个例子，如果我们的产品要实现用户画像功能（给用户打标签），然后基于用户画像给用户推荐平台的服务或消费品之类的东西，我们也可以使用 JSON 类型来保存用户画像数据，示意代码如下所示。</p><p>创建画像标签表。</p><pre><code class="language-SQL">create table `tb_tags`(`tag_id` int unsigned not null comment '标签ID',`tag_name` varchar(20) not null comment '标签名',primary key (`tag_id`)) engine=innodb;insert into `tb_tags` (`tag_id`, `tag_name`) values    (1, '70后'),    (2, '80后'),    (3, '90后'),    (4, '00后'),    (5, '爱运动'),    (6, '高学历'),    (7, '小资'),    (8, '有房'),    (9, '有车'),    (10, '爱看电影'),    (11, '爱网购'),    (12, '常点外卖');</code></pre><p>为用户打标签。</p><pre><code class="language-SQL">create table `tb_users_tags`(`user_id` bigint unsigned not null comment '用户ID',`user_tags` json not null comment '用户标签') engine=innodb;insert into `tb_users_tags` values     (1, '[2, 6, 8, 10]'),    (2, '[3, 10, 12]'),    (3, '[3, 8, 9, 11]');</code></pre><p>接下来，我们通过一组查询来了解 JSON 类型的巧妙之处。</p><ol><li><p>查询爱看电影（有 <code>10</code>  这个标签）的用户 ID。</p><pre><code class="language-SQL">select * from `tb_users` where 10 member of (user_tags-&gt;'$');</code></pre></li><li><p>查询爱看电影（有 <code>10</code>  这个标签）的 80 后（有 <code>2</code>  这个标签）用户 ID。</p><pre><code>select * from `tb_users` where json_contains(user_tags-&gt;'$', '[2, 10]');</code></pre></li><li><p>查询爱看电影或 80 后或 90 后的用户 ID。</p><pre><code class="language-SQL">select `user_id` from `tb_users_tags` where json_overlaps(user_tags-&gt;'$', '[2, 3, 10]');</code></pre></li></ol><blockquote><p><strong>说明</strong>：上面的查询用到了 <code>member of</code>  谓词和两个 JSON 函数， <code>json_contains</code>  可以检查 JSON 数组是否包含了指定的元素，而 <code>json_overlaps</code>  可以检查 JSON 数组是否与指定的数组有重叠部分。</p></blockquote><h4 id="窗口函数"><a class="anchor" href="#窗口函数">#</a> 窗口函数</h4><p>MySQL 从 8.0 开始支持窗口函数，大多数商业数据库和一些开源数据库早已提供了对窗口函数的支持，有的也将其称之为 OLAP（联机分析和处理）函数，听名字就知道跟统计和分析相关。为了帮助大家理解窗口函数，我们先说说窗口的概念。</p><p>窗口可以理解为记录的集合，窗口函数也就是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数。窗口函数和我们上面讲到的聚合函数比较容易混淆，二者的区别主要在于聚合函数是将多条记录聚合为一条记录，窗口函数是每条记录都会执行，执行后记录条数不会变。窗口函数不仅仅是几个函数，它是一套完整的语法，函数只是该语法的一部分，基本语法如下所示：</p><pre><code class="language-SQL">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用户排序的列名&gt;)</code></pre><p>上面语法中，窗口函数的位置可以放以下两种函数：</p><ol><li>专用窗口函数，包括： <code>lead</code> 、 <code>lag</code> 、 <code>first_value</code> 、 <code>last_value</code> 、 <code>rank</code> 、 <code>dense_rank</code>  和 <code>row_number</code>  等。</li><li>聚合函数，包括： <code>sum</code> 、 <code>avg</code> 、 <code>max</code> 、 <code>min</code>  和 <code>count</code>  等。</li></ol><p>下面为大家举几个使用窗口函数的简单例子，我们先用如下所示的 SQL 建库建表。</p><pre><code class="language-SQL">-- 创建名为hrs的数据库并指定默认的字符集create database `hrs` default charset utf8mb4;-- 切换到hrs数据库use `hrs`;-- 创建部门表create table `tb_dept`(`dno` int not null comment '编号',`dname` varchar(10) not null comment '名称',`dloc` varchar(20) not null comment '所在地',primary key (`dno`));-- 插入4个部门insert into `tb_dept` values     (10, '会计部', '北京'),    (20, '研发部', '成都'),    (30, '销售部', '重庆'),    (40, '运维部', '深圳');-- 创建员工表create table `tb_emp`(`eno` int not null comment '员工编号',`ename` varchar(20) not null comment '员工姓名',`job` varchar(20) not null comment '员工职位',`mgr` int comment '主管编号',`sal` int not null comment '员工月薪',`comm` int comment '每月补贴',`dno` int not null comment '所在部门编号',primary key (`eno`),constraint `fk_emp_mgr` foreign key (`mgr`) references tb_emp (`eno`),constraint `fk_emp_dno` foreign key (`dno`) references tb_dept (`dno`));-- 插入14个员工insert into `tb_emp` values     (7800, '张三丰', '总裁', null, 9000, 1200, 20),    (2056, '乔峰', '分析师', 7800, 5000, 1500, 20),    (3088, '李莫愁', '设计师', 2056, 3500, 800, 20),    (3211, '张无忌', '程序员', 2056, 3200, null, 20),    (3233, '丘处机', '程序员', 2056, 3400, null, 20),    (3251, '张翠山', '程序员', 2056, 4000, null, 20),    (5566, '宋远桥', '会计师', 7800, 4000, 1000, 10),    (5234, '郭靖', '出纳', 5566, 2000, null, 10),    (3344, '黄蓉', '销售主管', 7800, 3000, 800, 30),    (1359, '胡一刀', '销售员', 3344, 1800, 200, 30),    (4466, '苗人凤', '销售员', 3344, 2500, null, 30),    (3244, '欧阳锋', '程序员', 3088, 3200, null, 20),    (3577, '杨过', '会计', 5566, 2200, null, 10),    (3588, '朱九真', '会计', 5566, 2500, null, 10);</code></pre><p>例子 1：查询按月薪从高到低排在第 4 到第 6 名的员工的姓名和月薪。</p><pre><code class="language-SQL">select * from (select `ename`, `sal`,row_number() over (order by `sal` desc) as `rank`from `tb_emp`) `temp` where `rank` between 4 and 6;</code></pre><blockquote><p><strong>说明</strong>：上面使用的函数 <code>row_number()</code>  可以为每条记录生成一个行号，在实际工作中可以根据需要将其替换为 <code>rank()</code>  或 <code>dense_rank()</code>  函数，三者的区别可以参考官方文档或阅读<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85MjY1NDU3NA==">《通俗易懂的学会：SQL 窗口函数》</span>进行了解。在 MySQL 8 以前的版本，我们可以通过下面的方式来完成类似的操作。</p><pre><code class="language-SQL">select `rank`, `ename`, `sal` from (    select @a:=@a+1 as `rank`, `ename`, `sal`     from `tb_emp`, (select @a:=0) as t1 order by `sal` desc) t2 where `rank` between 4 and 6;</code></pre></blockquote><p>例子 2：查询每个部门月薪最高的两名的员工的姓名和部门名称。</p><pre><code class="language-SQL">select `ename`, `sal`, `dname` from (    select         `ename`, `sal`, `dno`,        rank() over (partition by `dno` order by `sal` desc) as `rank`    from `tb_emp`) as `temp` natural join `tb_dept` where `rank`&lt;=2;</code></pre><blockquote><p>说明：在 MySQL 8 以前的版本，我们可以通过下面的方式来完成类似的操作。</p><pre><code class="language-SQL">select `ename`, `sal`, `dname` from `tb_emp` as `t1` </code></pre></blockquote><p>natural join  <code>tb_dept</code> <br />where (<br />select count(*) from  <code>tb_emp</code>  as  <code>t2</code> <br />where  <code>t1</code> . <code>dno</code> = <code>t2</code> . <code>dno</code>  and  <code>t2</code> . <code>sal</code> &gt; <code>t1</code> . <code>sal</code> <br />)&lt;2 order by  <code>dno</code>  asc,  <code>sal</code>  desc;</p><blockquote><pre><code></code></pre></blockquote><h3 id="其他内容"><a class="anchor" href="#其他内容">#</a> 其他内容</h3><h4 id="范式理论"><a class="anchor" href="#范式理论">#</a> 范式理论</h4><p>范式理论是设计关系型数据库中二维表的指导思想。</p><ol><li>第一范式：数据表的每个列的值域都是由原子值组成的，不能够再分割。</li><li>第二范式：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系。</li><li>第三范式：所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。</li></ol><blockquote><p><strong>说明</strong>：实际工作中，出于效率的考虑，我们在设计表时很有可能做出反范式设计，即故意降低方式级别，增加冗余数据来获得更好的操作性能。</p></blockquote><h4 id="数据完整性"><a class="anchor" href="#数据完整性">#</a> 数据完整性</h4><ol><li><p>实体完整性 - 每个实体都是独一无二的</p><ul><li>主键（ <code>primary key</code> ） / 唯一约束（ <code>unique</code> ）</li></ul></li><li><p>引用完整性（参照完整性）- 关系中不允许引用不存在的实体</p><ul><li>外键（ <code>foreign key</code> ）</li></ul></li><li><p>域（domain）完整性 - 数据是有效的</p><ul><li><p>数据类型及长度</p></li><li><p>非空约束（ <code>not null</code> ）</p></li><li><p>默认值约束（ <code>default</code> ）</p></li><li><p>检查约束（ <code>check</code> ）</p><blockquote><p><strong>说明</strong>：在 MySQL 8.x 以前，检查约束并不起作用。</p></blockquote></li></ul></li></ol><h4 id="数据一致性"><a class="anchor" href="#数据一致性">#</a> 数据一致性</h4><ol><li><p>事务：一系列对数据库进行读 / 写的操作，这些操作要么全都成功，要么全都失败。</p></li><li><p>事务的 ACID 特性</p><ul><li>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li><li>一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态</li><li>隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li><li>持久性：已被提交的事务对数据库的修改应该永久保存在数据库中</li></ul></li><li><p>MySQL 中的事务操作</p><ul><li><p>开启事务环境</p><pre><code class="language-SQL">start transaction</code></pre></li><li><p>提交事务</p><pre><code class="language-SQL">commit</code></pre></li><li><p>回滚事务</p><pre><code class="language-SQL">rollback</code></pre></li></ul></li><li><p>查看事务隔离级别</p><pre><code class="language-SQL">show variables like 'transaction_isolation';</code></pre><pre><code>+-----------------------+-----------------+| Variable_name         | Value           |+-----------------------+-----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+-----------------+</code></pre><p>可以看出，MySQL 默认的事务隔离级别是 <code>REPEATABLE-READ</code> 。</p></li><li><p>修改（当前会话）事务隔离级别</p><pre><code class="language-SQL">set session transaction isolation level read committed;</code></pre><p>重新查看事务隔离级别，结果如下所示。</p><pre><code>+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+</code></pre></li></ol><p>关系型数据库的事务是一个很大的话题，因为当存在多个并发事务访问数据时，就有可能出现三类读数据的问题（脏读、不可重复读、幻读）和两类更新数据的问题（第一类丢失更新、第二类丢失更新）。想了解这五类问题的，可以阅读我发布在 CSDN 网站上的<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tmcnVlZC9hcnRpY2xlL2RldGFpbHMvNDQ5MjE5NDE=">《Java 面试题全集（上）》</span>一文的第 80 题。为了避免这些问题，关系型数据库底层是有对应的锁机制的，按锁定对象不同可以分为表级锁和行级锁，按并发事务锁定关系可以分为共享锁和独占锁。然而直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定适当的事务隔离级别，数据库就会通过分析 SQL 语句，然后为事务访问的资源加上合适的锁。此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的。想了解 MySQL 事务和锁的细节知识，推荐大家阅读进阶读物<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMTIyMDM5My5odG1s">《高性能 MySQL》</span>，这也是数据库方面的经典书籍。</p><p>ANSI/ISO SQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示。需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定到底使用哪种事务隔离级别，这个地方没有万能的原则。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMjEyMjUzMjcucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211121225327.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>关于 SQL 和 MySQL 的知识肯定远远不止上面列出的这些，比如 SQL 本身的优化、MySQL 性能调优、MySQL 运维相关工具、MySQL 数据的备份和恢复、监控 MySQL 服务、部署高可用架构等，这一系列的问题在这里都没有办法逐一展开来讨论，那就留到有需要的时候再进行讲解吧，各位读者也可以自行探索。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系型数据库和MySQL概述</title>
      <link href="/computer-science/python/basic/36.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CMySQL%E6%A6%82%E8%BF%B0/"/>
      <url>/computer-science/python/basic/36.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CMySQL%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="关系型数据库和mysql概述"><a class="anchor" href="#关系型数据库和mysql概述">#</a> 关系型数据库和 MySQL 概述</h2><h3 id="关系型数据库概述"><a class="anchor" href="#关系型数据库概述">#</a> 关系型数据库概述</h3><ol><li><p>数据持久化 - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。</p></li><li><p>数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL 数据库、NewSQL 数据库。</p><blockquote><p>1970 年，IBM 的研究员 E.F.Codd 在<em> Communication of the ACM</em> 上发表了名为<em> A Relational Model of Data for Large Shared Data Banks</em> 的论文，提出了<strong>关系模型</strong>的概念，奠定了关系模型的理论基础。后来 Codd 又陆续发表多篇文章，论述了范式理论和衡量关系系统的 12 条标准，用数学理论奠定了关系数据库的基础。</p></blockquote></li><li><p>关系数据库特点。</p><ul><li><p>理论基础：<strong>关系代数</strong>（关系运算、集合论、一阶谓词逻辑）。</p></li><li><p>具体表象：用<strong>二维表</strong>（有行和列）组织数据。</p></li><li><p>编程语言：<strong>结构化查询语言</strong>（SQL）。</p></li></ul></li><li><p>ER 模型（实体关系模型）和概念模型图。</p><p><strong>ER 模型</strong>，全称为<strong>实体关系模型</strong>（Entity-Relationship Model），由美籍华裔计算机科学家陈品山先生提出，是概念数据模型的高层描述方式，如下图所示。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTA4MjYwMDMxMTkucG5n">https://gitee.com/jackfrued/mypic/raw/master/20210826003119.png</span>&quot; width=&quot;75%&quot;&gt;</p><ul><li>实体 - 矩形框</li><li>属性 - 椭圆框</li><li>关系 - 菱形框</li><li>重数 - 1:1（一对一） / 1:N（一对多） / M:N（多对多）</li></ul><p>实际项目开发中，我们可以利用数据库建模工具（如：PowerDesigner）来绘制概念数据模型（其本质就是 ER 模型），然后再设置好目标数据库系统，将概念模型转换成物理模型，最终生成创建二维表的 SQL（很多工具都可以根据我们设计的物理模型图以及设定的目标数据库来导出 SQL 或直接生成数据表）。</p><p><img data-src="https://gitee.com/jackfrued/mypic/raw/master/20210826003212.png" alt="" /></p></li><li><p>关系数据库产品。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9pbmRleC5odG1s">Oracle</span> - 目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库，它实现了分布式处理的功能。在 Oracle 最新的 12c 版本中，还引入了多承租方架构，使用该架构可轻松部署和管理数据库云。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9hbmFseXRpY3MvdXMvZW4vZGIyLw==">DB2</span> - IBM 公司开发的、主要运行于 Unix（包括 IBM 自家的 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQUlY">AIX</span>）、Linux、以及 Windows 服务器版等系统的关系数据库产品。DB2 历史悠久且被认为是最早使用 SQL 的数据库产品，它拥有较为强大的商业智能功能。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9lbi11cy9zcWwtc2VydmVyLw==">SQL Server</span> - 由 Microsoft 开发和推广的关系型数据库产品，最初适用于中小企业的数据管理，但是近年来它的应用范围有所扩展，部分大企业甚至是跨国公司也开始基于它来构建自己的数据管理系统。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubXlzcWwuY29tLw==">MySQL</span> - MySQL 是开放源代码的，任何人都可以在 GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL 因为其速度、可靠性和适应性而备受关注。</li><li><a href="">PostgreSQL</a> - 在 BSD 许可证下发行的开放源代码的关系数据库产品。</li></ul></li></ol><h3 id="mysql-简介"><a class="anchor" href="#mysql-简介">#</a> MySQL 简介</h3><p>MySQL 最早是由瑞典的 MySQL AB 公司开发的一个开放源码的关系数据库管理系统，该公司于 2008 年被昇阳微系统公司（Sun Microsystems）收购。在 2009 年，甲骨文公司（Oracle）收购昇阳微系统公司，因此 MySQL 目前也是 Oracle 旗下产品。</p><p>MySQL 在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用于中小型网站开发。随着 MySQL 的不断成熟，它也逐渐被应用于更多大规模网站和应用，比如维基百科、谷歌（Google）、脸书（Facebook）、淘宝网等网站都使用了 MySQL 来提供数据持久化服务。</p><p>甲骨文公司收购后昇阳微系统公司，大幅调涨 MySQL 商业版的售价，且甲骨文公司不再支持另一个自由软件项目 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvT3BlblNvbGFyaXM=">OpenSolaris </span> 的发展，因此导致自由软件社区对于 Oracle 是否还会持续支持 MySQL 社区版（MySQL 的各个发行版本中唯一免费的版本）有所担忧，MySQL 的创始人麦克尔・维德纽斯以 MySQL 为基础，创建了 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTWFyaWFEQg==">MariaDB</span>（以他女儿的名字命名的数据库）分支。有许多原来使用 MySQL 数据库的公司（例如：维基百科）已经陆续完成了从 MySQL 数据库到 MariaDB 数据库的迁移。</p><h3 id="安装-mysql"><a class="anchor" href="#安装-mysql">#</a> 安装 MySQL</h3><h4 id="windows-环境"><a class="anchor" href="#windows-环境">#</a> Windows 环境</h4><ol><li><p>通过<span class="exturl" data-url="aHR0cHM6Ly93d3cubXlzcWwuY29tLw==">官方网站</span>提供的<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy93aW5kb3dzL2luc3RhbGxlci84LjAuaHRtbA==">下载链接</span>下载 “MySQL 社区版服务器” 安装程序，如下图所示，建议大家下载离线安装版的 MySQL Installer。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzA5MDUucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211105230905.png</span>&quot; style=&quot;zoom:50%&quot;&gt;</p></li><li><p>运行 Installer，按照下面的步骤进行安装。</p><ul><li>选择自定义安装。</li></ul><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzExNTIuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105231152.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p><ul><li>选择需要安装的组件。</li></ul><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzEyNTUuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105231255.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p><ul><li>如果缺少依赖项，需要先安装依赖项。</li></ul><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzE2MjAucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211105231620.png</span>&quot; style=&quot;zoom:35%&quot;&gt;</p><ul><li>准备开始安装。</li></ul><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzE3MTkuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105231719.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p><ul><li>安装完成。</li></ul><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzIwMjQuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232024.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p><ul><li>准备执行配置向导。</li></ul><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzE4MTUuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105231815.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p></li><li><p>执行安装后的配置向导。</p><ul><li>配置服务器类型和网络。</li></ul><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzIxMDkuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232109.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p><ul><li><p>配置认证方法（保护密码的方式）。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzI0MDguanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232408.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p></li><li><p>配置用户和角色。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzI1MjEuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232521.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p></li><li><p>配置 Windows 服务名以及是否开机自启。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzI2MDguanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232608.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p></li><li><p>配置日志。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzI2NDEuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232641.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p></li><li><p>配置高级选项。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzI3MjQuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232724.jpg</span>&quot; alt=&quot;ACAC15B8633133B65476286A49BFBD7E&quot; style=&quot;zoom:35%&quot;&gt;</p></li><li><p>应用配置。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzI4MDAuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232800.jpg</span>&quot; style=&quot;zoom:35%&quot;&gt;</p></li></ul></li><li><p>可以在 Windows 系统的 “服务” 窗口中启动或停止 MySQL。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzI5MjYuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105232926.jpg</span>&quot; style=&quot;zoom:50%&quot;&gt;</p></li><li><p>配置 PATH 环境变量，以便在命令行提示符窗口使用 MySQL 客户端工具。</p><ul><li><p>打开 Windows 的 “系统” 窗口并点击 “高级系统设置”。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzMwNTQuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105233054.jpg</span>&quot; style=&quot;zoom:50%&quot;&gt;</p></li><li><p>在 “系统属性” 的 “高级” 窗口，点击 “环境变量” 按钮。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzMzMTIuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105233312.jpg</span>&quot; style=&quot;zoom:50%&quot;&gt;</p></li><li><p>修改 PATH 环境变量，将 MySQL 安装路径下的 <code>bin</code>  文件夹的路径配置到 PATH 环境变量中。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzMzNTkuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105233359.jpg</span>&quot; style=&quot;zoom:50%&quot;&gt;</p></li><li><p>配置完成后，可以尝试在 “命令提示符” 下使用 MySQL 的命令行工具。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDUyMzM2NDMuanBn">https://gitee.com/jackfrued/mypic/raw/master/20211105233643.jpg</span>&quot; style=&quot;zoom:50%&quot;&gt;</p></li></ul></li></ol><h4 id="linux-环境"><a class="anchor" href="#linux-环境">#</a> Linux 环境</h4><p>下面以 CentOS 7.x 环境为例，演示如何安装 MySQL 5.7.x，如果需要在其他 Linux 系统下安装其他版本的 MySQL，请读者自行在网络上查找对应的安装教程。</p><ol><li><p>安装 MySQL。</p><p>可以在 <span class="exturl" data-url="aHR0cHM6Ly93d3cubXlzcWwuY29tLw==">MySQL 官方网站</span>下载安装文件。首先在下载页面中选择平台和版本，然后找到对应的下载链接，直接下载包含所有安装文件的归档文件，解归档之后通过包管理工具进行安装。</p><pre><code class="language-Shell">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</code></pre><p>如果系统上有 MariaDB 相关的文件，需要先移除 MariaDB 相关的文件。</p><pre><code class="language-Shell">yum list installed | grep mariadb | awk '&#123;print $1&#125;' | xargs yum erase -y</code></pre><p>更新和安装可能用到的底层依赖库。</p><pre><code class="language-Bash">yum updateyum install -y libaio libaio-devel</code></pre><p>接下来可以按照如下所示的顺序用 RPM（Redhat Package Manager）工具安装 MySQL。</p><pre><code class="language-Shell">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-compat-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-devel-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm</code></pre><p>可以使用下面的命令查看已经安装的 MySQL 相关的包。</p><pre><code class="language-Shell">rpm -qa | grep mysql</code></pre></li><li><p>配置 MySQL。</p><p>MySQL 的配置文件在 <code>/etc</code>  目录下，名为 <code>my.cnf</code> ，默认的配置文件内容如下所示。</p><pre><code class="language-Shell">cat /etc/my.cnf</code></pre><pre><code class="language-INI"># For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid</code></pre><p>通过配置文件，我们可以修改 MySQL 服务使用的端口、字符集、最大连接数、套接字队列大小、最大数据包大小、日志文件的位置、日志过期时间等配置。当然，我们还可以通过修改配置文件来对 MySQL 服务器进行性能调优和安全管控。</p></li><li><p>启动 MySQL 服务。</p><p>可以使用下面的命令来启动 MySQL。</p><pre><code class="language-Shell">service mysqld start</code></pre><p>在 CentOS 7 中，更推荐使用下面的命令来启动 MySQL。</p><pre><code class="language-Shell">systemctl start mysqld</code></pre><p>启动 MySQL 成功后，可以通过下面的命令来检查网络端口使用情况，MySQL 默认使用 <code>3306</code>  端口。</p><pre><code class="language-Shell">netstat -ntlp | grep mysql</code></pre><p>也可以使用下面的命令查找是否有名为 <code>mysqld</code>  的进程。</p><pre><code class="language-Shell">pgrep mysqld</code></pre></li><li><p>使用 MySQL 客户端工具连接服务器。</p><p>命令行工具：</p><pre><code class="language-Shell">mysql -u root -p</code></pre><blockquote><p>说明：启动客户端时， <code>-u</code>  参数用来指定用户名，MySQL 默认的超级管理账号为 <code>root</code> ； <code>-p</code>  表示要输入密码（用户口令）；如果连接的是其他主机而非本机，可以用 <code>-h</code>  来指定连接主机的主机名或 IP 地址。</p></blockquote><p>如果是首次安装 MySQL，可以使用下面的命令来找到默认的初始密码。</p><pre><code class="language-Shell">cat /var/log/mysqld.log | grep password</code></pre><p>上面的命令会查看 MySQL 的日志带有 <code>password</code>  的行，在显示的结果中 <code>root@localhost:</code>  后面的部分就是默认设置的初始密码。</p><p>进入客户端工具后，可以通过下面的指令来修改超级管理员（root）的访问口令为 <code>123456</code> 。</p><pre><code class="language-SQL">set global validate_password_policy=0;set global validate_password_length=6;alter user 'root'@'localhost' identified by '123456';</code></pre><blockquote><p><strong>说明</strong>：MySQL 较新的版本默认不允许使用弱口令作为用户口令，所以上面的代码修改了验证用户口令的策略和口令的长度。事实上我们不应该使用弱口令，因为存在用户口令被暴力破解的风险。近年来，<strong>攻击数据库窃取数据和劫持数据库勒索比特币</strong>的事件屡见不鲜，要避免这些潜在的风险，最为重要的一点是<strong>不要让数据库服务器暴露在公网上</strong>（最好的做法是将数据库置于内网，至少要做到不向公网开放数据库服务器的访问端口），另外要保管好 <code>root</code>  账号的口令，应用系统需要访问数据库时，通常不使用 <code>root</code>  账号进行访问，而是<strong>创建其他拥有适当权限的账号来访问</strong>。</p></blockquote><p>再次使用客户端工具连接 MySQL 服务器时，就可以使用新设置的口令了。在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接 MySQL 服务器，包括：</p><ul><li><p>MySQL Workbench（官方工具）</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDYwNjM5MzkucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211106063939.png</span>&quot; style=&quot;zoom:50%&quot;&gt;</p></li><li><p>Navicat for MySQL（界面简单友好）</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTA1MjExNTI0NTcucG5n">https://gitee.com/jackfrued/mypic/raw/master/20210521152457.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p></li></ul></li></ol><h4 id="macos环境"><a class="anchor" href="#macos环境">#</a> macOS 环境</h4><p>macOS 系统安装 MySQL 是比较简单的，只需要从刚才说到的官方网站下载 DMG 安装文件并运行就可以了，下载的时候需要根据自己使用的是 Intel 的芯片还是苹果的 M1 芯片选择下载链接，如下图所示。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMjEyMTU5MDEucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211121215901.png</span>&quot; style=&quot;zoom:50%;&quot;&gt;</p><p>安装成功后，可以在 “系统偏好设置” 中找到 “MySQL”，在如下所示的画面中，可以启动和停止 MySQL 服务器，也可以对 MySQL 核心文件的路径进行配置。</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMjEyMTUxNTMucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211121215153.png</span>&quot; style=&quot;zoom:40%;&quot;&gt;</p><h3 id="mysql-基本命令"><a class="anchor" href="#mysql-基本命令">#</a> MySQL 基本命令</h3><h4 id="查看命令"><a class="anchor" href="#查看命令">#</a> 查看命令</h4><ol><li>查看所有数据库</li></ol><pre><code class="language-SQL">show databases;</code></pre><ol start="2"><li>查看所有字符集</li></ol><pre><code class="language-SQL">show character set;</code></pre><ol start="3"><li>查看所有的排序规则</li></ol><pre><code class="language-SQL">show collation;</code></pre><ol start="4"><li>查看所有的引擎</li></ol><pre><code class="language-SQL">show engines;</code></pre><ol start="5"><li>查看所有日志文件</li></ol><pre><code class="language-SQL">show binary logs;</code></pre><ol start="6"><li>查看数据库下所有表</li></ol><pre><code class="language-SQL">show tables;</code></pre><h4 id="获取帮助"><a class="anchor" href="#获取帮助">#</a> 获取帮助</h4><p>在 MySQL 命令行工具中，可以使用 <code>help</code>  命令或 <code>?</code>  来获取帮助，如下所示。</p><ol><li><p>查看 <code>show</code>  命令的帮助。</p><pre><code class="language-MySQL">? show</code></pre></li><li><p>查看有哪些帮助内容。</p><pre><code class="language-MySQL">? contents</code></pre></li><li><p>获取函数的帮助。</p><pre><code class="language-MySQL">? functions</code></pre></li><li><p>获取数据类型的帮助。</p><pre><code class="language-MySQL">? data types</code></pre></li></ol><h4 id="其他命令"><a class="anchor" href="#其他命令">#</a> 其他命令</h4><ol><li><p>新建 / 重建服务器连接 -  <code>connect</code>  /  <code>resetconnection</code> 。</p></li><li><p>清空当前输入 -  <code>\c</code> 。在输入错误时，可以及时使用 <code>\c</code>  清空当前输入并重新开始。</p></li><li><p>修改终止符（定界符）-  <code>delimiter</code> 。默认的终止符是 <code>;</code> ，可以使用该命令修改成其他的字符，例如修改为 <code>$</code>  符号，可以用 <code>delimiter $</code>  命令。</p></li><li><p>打开系统默认编辑器 -  <code>edit</code> 。编辑完成保存关闭之后，命令行会自动执行编辑的内容。</p></li><li><p>查看服务器状态 -  <code>status</code> 。</p></li><li><p>修改默认提示符 -  <code>prompt</code> 。</p></li><li><p>执行系统命令 -  <code>system</code> 。可以将系统命令跟在 <code>system</code>  命令的后面执行， <code>system</code>  命令也可以缩写为 <code>\!</code> 。</p></li><li><p>执行 SQL 文件 -  <code>source</code> 。 <code>source</code>  命令后面跟 SQL 文件路径。</p></li><li><p>重定向输出 -  <code>tee</code>  /  <code>notee</code> 。可以将命令的输出重定向到指定的文件中。</p></li><li><p>切换数据库 -  <code>use</code> 。</p></li><li><p>显示警告信息 -  <code>warnings</code> 。</p></li><li><p>退出命令行 -  <code>quit</code>  或 <code>exit</code> 。</p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转Linux操作系统</title>
      <link href="/computer-science/python/basic/31-35.%E7%8E%A9%E8%BD%ACLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/computer-science/python/basic/31-35.%E7%8E%A9%E8%BD%ACLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>玩转 Linux 操作系统</p><blockquote><p><strong>说明</strong>：本文中对 Linux 命令的讲解都是基于名为 CentOS 的 Linux 发行版本，我自己使用的是阿里云服务器，系统版本为 CentOS Linux release 7.6.1810。不同的 Linux 发行版本在 Shell 命令和工具程序上会有一些差别，但是这些差别是很小的。</p></blockquote><h3 id="操作系统发展史"><a class="anchor" href="#操作系统发展史">#</a> 操作系统发展史</h3><p>只有硬件没有软件的计算机系统被称之为 “裸机”，我们很难用 “裸机” 来完成计算机日常的工作（如存储和运算），所以必须用特定的软件来控制硬件的工作。最靠近计算机硬件的软件是系统软件，其中最为重要的就是 “操作系统”。“操作系统” 是控制和管理整个计算机硬件和软件资源、实现资源分配和任务调配、为系统用户以及其他软件提供接口和环境的程序的集合。</p><h4 id="没有操作系统手工操作"><a class="anchor" href="#没有操作系统手工操作">#</a> 没有操作系统（手工操作）</h4><p>在计算机诞生之初没有操作系统的年代，人们先把程序纸带（或卡片）装上计算机，然后启动输入机把程序送入计算机，接着通过控制台开关启动程序运行。当程序执行完毕，打印机输出计算的结果，用户卸下并取走纸带（或卡片）。第二个用户上机，重复同样的步骤。在整个过程中用户独占机器，CPU 等待手工操作，资源利用率极低。</p><h4 id="批处理系统"><a class="anchor" href="#批处理系统">#</a> 批处理系统</h4><p>首先启动计算机上的一个监督程序，在监督程序的控制下，计算机能够自动的、成批的处理一个或多个用户的作业。完成一批作业后，监督程度又从输入机读取作业存入磁带机。按照上面的步骤重复处理任务。监督程序不停的处理各个作业，实现了作业的自动转接，减少了作业的建立时间和手工操作时间，提高了计算机资源的利用率。 批处理系统又可以分为单道批处理系统、多道批处理系统、联机批处理系统、脱机批处理系统。</p><h4 id="分时系统和实时系统"><a class="anchor" href="#分时系统和实时系统">#</a> 分时系统和实时系统</h4><p>分时系统是把处理器的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。 若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮调度时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在在严格的时间范围内完成事件处理，及时响应随机外部事件的实时系统。</p><h4 id="通用操作系统"><a class="anchor" href="#通用操作系统">#</a> 通用操作系统</h4><ol><li><p>1960s：IBM 的 System/360 系列的机器有了统一的操作系统 OS/360。</p></li><li><p>1965 年：AT&amp;T 的贝尔实验室加入 GE 和 MIT 的合作计划开始开发 MULTICS。</p></li><li><p>1969 年：MULTICS 项目失败，Ken Tompson 赋闲在家，为了玩 “Space Travel” 游戏用汇编语言在当时已经被淘汰的 PDP-7 上开发了 Unics。</p><blockquote><p>注：很难想象，Unix 这么伟大的操作系统，居然是一个赋闲在家的程序员（关键是老婆回娘家还带上了孩子）在一台被淘汰的设备上为了玩游戏开发出来的。</p></blockquote></li><li><p>1970 年～1971 年：Ken Thompson 和 Dennis Ritchie 用 B 语言在 PDP-11 上重写了 Unics，并在 Brian Kernighan 的建议下将其更名为 Unix。</p><p>&lt;img src=&quot;res/ken-and-dennis-pdp-11.png&quot; style=&quot;zoom:62%;&quot; /&gt;</p></li><li><p>1972 年～1973 年：Dennis Ritchie 发明了 C 语言来取代可移植性较差的 B 语言，并开启了用 C 语言重写 Unix 的工作。</p></li><li><p>1974 年：Unix 推出了里程碑意义的第 5 版，几乎完全用 C 语言来实现。</p></li><li><p>1979 年：从 Unix 第 7 版开始，AT&amp;T 发布新的使用条款，将 Unix 私有化。</p></li><li><p>1987 年：Andrew S. Tanenbaum 教授为了能在课堂上为学生讲解操作系统运作的细节，决定在不使用任何 AT&amp;T 的源代码前提下，自行开发与 Unix 兼容的操作系统以避免版权上的争议，该系统被命名为 Minix。</p><p>&lt;img src=&quot;res/andrew.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;</p></li><li><p>1991 年：Linus Torvalds 就读于芬兰赫尔辛基大学期间，尝试在 Minix 上做一些开发工作，但因为 Minix 只是作为教学用途的操作系统，功能并不强大，为了方便在学校的新闻组和邮件系统中读写和下载文件，Linus 编写了磁盘驱动程序和文件系统，这些东西形成了 Linux 系统内核的雏形。</p><p><img data-src="./res/linus.png" alt="" /></p></li></ol><p>下图是 Unix 操作系统家族的图谱。</p><p><img data-src="./res/history-of-unix.png" alt="" /></p><h3 id="linux概述"><a class="anchor" href="#linux概述">#</a> Linux 概述</h3><p>Linux 是一个通用操作系统。一个操作系统要负责任务调度、内存分配、处理外围设备 I/O 等操作。操作系统通常由内核（运行其他程序，管理像磁盘、打印机等硬件设备的核心程序）和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。</p><p>Linux 内核是芬兰人 Linus Torvalds 开发的，于 1991 年 9 月发布。而 Linux 操作系统作为 Internet 时代的产物，它是由全世界许多开发者共同合作开发的，是一个自由的操作系统（注意自由和免费并不是同一个概念，想了解二者的差别可以<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGViaWFuLm9yZy9pbnRyby9mcmVl">点击这里</span>）。</p><h3 id="linux系统优点"><a class="anchor" href="#linux系统优点">#</a> Linux 系统优点</h3><ol><li>通用操作系统，不跟特定的硬件绑定。</li><li>用 C 语言编写，可移植性强，有内核编程接口。</li><li>支持多用户和多任务，支持安全的分层文件系统。</li><li>大量的实用程序，完善的网络功能以及强大的支持文档。</li><li>可靠的安全性和良好的稳定性，对开发者更友好。</li></ol><h3 id="linux系统发行版本"><a class="anchor" href="#linux系统发行版本">#</a> Linux 系统发行版本</h3><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkaGF0LmNvbS9lbg==">Redhat</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudWJ1bnR1LmNvbS8=">Ubuntu</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2VudG9zLm9yZy8=">CentOS</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9nZXRmZWRvcmEub3JnLw==">Fedora</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGViaWFuLm9yZy8=">Debian</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbnN1c2Uub3JnLw==">openSUSE</span></li></ol><h3 id="基础命令"><a class="anchor" href="#基础命令">#</a> 基础命令</h3><p>Linux 系统的命令通常都是如下所示的格式：</p><pre><code class="language-Shell">命令名称 [命名参数] [命令对象]</code></pre><ol><li><p>获取登录信息 - <strong>w</strong> / <strong>who</strong> / <strong>last</strong>/ <strong>lastb</strong>。</p><pre><code class="language-Shell">[root ~]# w 23:31:16 up 12:16,  2 users,  load average: 0.00, 0.01, 0.05USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATroot     pts/0    182.139.66.250   23:03    4.00s  0.02s  0.00s wjackfrue pts/1    182.139.66.250   23:26    3:56   0.00s  0.00s -bash[root ~]# whoroot     pts/0        2018-04-12 23:03 (182.139.66.250)jackfrued pts/1        2018-04-12 23:26 (182.139.66.250)[root ~]# who am iroot     pts/0        2018-04-12 23:03 (182.139.66.250)[root ~]# who mom likesroot     pts/0        2018-04-12 23:03 (182.139.66.250)[root ~]# lastroot     pts/0        117.136.63.184   Sun May 26 18:57   still logged in   reboot   system boot  3.10.0-957.10.1. Mon May 27 02:52 - 19:10  (-7:-42)   root     pts/4        117.136.63.184   Sun May 26 18:51 - crash  (08:01)    root     pts/4        117.136.63.184   Sun May 26 18:49 - 18:49  (00:00)    root     pts/3        117.136.63.183   Sun May 26 18:35 - crash  (08:17)    root     pts/2        117.136.63.183   Sun May 26 18:34 - crash  (08:17)    root     pts/0        117.136.63.183   Sun May 26 18:10 - crash  (08:42)    </code></pre></li><li><p>查看自己使用的 Shell - <strong>ps</strong>。</p><p>Shell 也被称为 “壳” 或 “壳程序”，它是用户与操作系统内核交流的翻译官，简单的说就是人与计算机交互的界面和接口。目前很多 Linux 系统默认的 Shell 都是 bash（&lt;u&gt;B&lt;/u&gt;ourne &lt;u&gt;A&lt;/u&gt;gain &lt;u&gt;SH&lt;/u&gt;ell），因为它可以使用 tab 键进行命令和路径补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作。</p><pre><code class="language-Shell">[root ~]# ps  PID TTY          TIME CMD 3531 pts/0    00:00:00 bash 3553 pts/0    00:00:00 ps</code></pre></li><li><p>查看命令的说明和位置 - <strong>whatis</strong> / <strong>which</strong> / <strong>whereis</strong>。</p><pre><code class="language-Shell">[root ~]# whatis psps (1)        - report a snapshot of the current processes.[root ~]# whatis pythonpython (1)    - an interpreted, interactive, object-oriented programming language[root ~]# whereis psps: /usr/bin/ps /usr/share/man/man1/ps.1.gz[root ~]# whereis pythonpython: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz[root ~]# which ps/usr/bin/ps[root ~]# which python/usr/bin/python</code></pre></li><li><p>清除屏幕上显示的内容 - <strong>clear</strong>。</p></li><li><p>查看帮助文档 - <strong>man</strong> / <strong>info</strong> / <strong>--help</strong> / <strong>apropos</strong>。</p><pre><code class="language-Shell">[root@izwz97tbgo9lkabnat2lo8z ~]# ps --helpUsage: ps [options] Try 'ps --help &lt;simple|list|output|threads|misc|all&gt;'  or 'ps --help &lt;s|l|o|t|m|a&gt;' for additional help text.For more details see ps(1).[root@izwz97tbgo9lkabnat2lo8z ~]# man psPS(1)                                User Commands                                PS(1)NAME       ps - report a snapshot of the current processes.SYNOPSIS       ps [options]DESCRIPTION...</code></pre></li><li><p>查看系统和主机名 - <strong>uname</strong> / <strong>hostname</strong>。</p><pre><code class="language-Shell">[root@izwz97tbgo9lkabnat2lo8z ~]# unameLinux[root@izwz97tbgo9lkabnat2lo8z ~]# hostnameizwz97tbgo9lkabnat2lo8z[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-releaseCentOS Linux release 7.6.1810 (Core)</code></pre><blockquote><p>说明： <code>cat</code>  是连接文件内容并打印到标准输出的命令，后面会讲到该命令； <code>/etc</code>  是 Linux 系统上的一个非常重要的目录，它保存了很多的配置文件； <code>centos-release</code>  是该目录下的一个文件，因为我自己使用的 Linux 发行版本是 CentOS 7.6，因此这里会有一个这样的文件。</p></blockquote></li><li><p>时间和日期 - <strong>date</strong> / <strong>cal</strong>。</p><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# dateWed Jun 20 12:53:19 CST 2018[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal      June 2018Su Mo Tu We Th Fr Sa                1  2 3  4  5  6  7  8  910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 30[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal 5 2017      May 2017Su Mo Tu We Th Fr Sa    1  2  3  4  5  6 7  8  9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31</code></pre></li><li><p>重启和关机 - <strong>reboot</strong> / <strong>shutdown</strong>。</p><pre><code class="language-Shell">[root ~]# shutdown -h +5Shutdown scheduled for Sun 2019-05-26 19:34:27 CST, use 'shutdown -c' to cancel.[root ~]# Broadcast message from root (Sun 2019-05-26 19:29:27 CST):The system is going down for power-off at Sun 2019-05-26 19:34:27 CST![root ~]# shutdown -cBroadcast message from root (Sun 2019-05-26 19:30:22 CST):The system shutdown has been cancelled at Sun 2019-05-26 19:31:22 CST![root ~]# shutdown -r 23:58Shutdown scheduled for Sun 2019-05-26 23:58:00 CST, use 'shutdown -c' to cancel.[root ~]# shutdown -cBroadcast message from root (Sun 2019-05-26 19:31:06 CST):The system shutdown has been cancelled at Sun 2019-05-26 19:32:06 CST!</code></pre><blockquote><p>说明：在执行 <code>shutdown</code>  命令时会向登录系统的用户发出警告，可以在命令后面跟上警告消息来替换默认的警告消息，也可以在 <code>-h</code>  参数后通过 <code>now</code>  来表示立刻关机。</p></blockquote></li><li><p>退出登录 -  <strong>exit</strong> / <strong>logout</strong>。</p></li><li><p>查看历史命令 - <strong>history</strong>。</p></li></ol><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# history...452  ls453  cd Python-3.6.5/454  clear455  history[root@iZwz97tbgo9lkabnat2lo8Z ~]# !454</code></pre><blockquote><p><strong>说明</strong>：查看到历史命令之后，可以用 <code>!历史命令编号</code> 来重新执行该命令；通过 <code>history -c</code>  可以清除历史命令。</p></blockquote><h3 id="实用程序"><a class="anchor" href="#实用程序">#</a> 实用程序</h3><h4 id="文件和文件夹操作"><a class="anchor" href="#文件和文件夹操作">#</a> 文件和文件夹操作</h4><ol><li><p>创建 / 删除空目录 - <strong>mkdir</strong> / <strong>rmdir</strong>。</p><pre><code class="language-Shell">[root ~]# mkdir abc[root ~]# mkdir -p xyz/abc[root ~]# rmdir abc</code></pre></li><li><p>创建 / 删除文件 - <strong>touch</strong> / <strong>rm</strong>。</p><pre><code class="language-Shell">[root ~]# touch readme.txt[root ~]# touch error.txt[root ~]# rm error.txtrm: remove regular empty file ‘error.txt’? y[root ~]# rm -rf xyz</code></pre><ul><li><code>touch</code>  命令用于创建空白文件或修改文件时间。在 Linux 系统中一个文件有三种时间：<ul><li>更改内容的时间 - mtime。</li><li>更改权限的时间 - ctime。</li><li>最后访问时间 - atime。</li></ul></li><li><code>rm</code>  的几个重要参数：<ul><li><code>-i</code> ：交互式删除，每个删除项都会进行询问。</li><li><code>-r</code> ：删除目录并递归的删除目录中的文件和目录。</li><li><code>-f</code> ：强制删除，忽略不存在的文件，没有任何提示。</li></ul></li></ul></li><li><p>切换和查看当前工作目录 - <strong>cd</strong> / <strong>pwd</strong>。</p><blockquote><p>说明： <code>cd</code>  命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以 <code>/</code>  开头）来切换到指定的目录，也可以用 <code>cd ..</code>  来返回上一级目录。请大家想一想，如果要返回到上上一级目录应该给 <code>cd</code>  命令加上什么样的参数呢？</p></blockquote></li><li><p>查看目录内容 - <strong>ls</strong>。</p><ul><li><code>-l</code> ：以长格式查看文件和目录。</li><li><code>-a</code> ：显示以点开头的文件和目录（隐藏文件）。</li><li><code>-R</code> ：遇到目录要进行递归展开（继续列出目录下面的文件和目录）。</li><li><code>-d</code> ：只列出目录，不列出其他内容。</li><li><code>-S</code>  /  <code>-t</code> ：按大小 / 时间排序。</li></ul></li><li><p>查看文件内容 - <strong>cat</strong> / <strong>tac</strong> / <strong>head</strong> / <strong>tail</strong> / <strong>more</strong> / <strong>less</strong> / <strong>rev</strong> / <strong>od</strong>。</p><pre><code class="language-Shell">[root ~]# wget http://www.sohu.com/ -O sohu.html--2018-06-20 18:42:34--  http://www.sohu.com/Resolving www.sohu.com (www.sohu.com)... 14.18.240.6Connecting to www.sohu.com (www.sohu.com)|14.18.240.6|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 212527 (208K) [text/html]Saving to: ‘sohu.html’100%[==================================================&gt;] 212,527     --.-K/s   in 0.03s2018-06-20 18:42:34 (7.48 MB/s) - ‘sohu.html’ saved [212527/212527][root ~]# cat sohu.html...[root ~]# head -10 sohu.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;搜狐&lt;/title&gt;&lt;meta name=&quot;Keywords&quot; content=&quot;搜狐,门户网站,新媒体,网络媒体,新闻,财经,体育,娱乐,时尚,汽车,房产,科技,图片,论坛,微博,博客,视频,电影,电视剧&quot;/&gt;&lt;meta name=&quot;Description&quot; content=&quot;搜狐网为用户提供24小时不间断的最新资讯，及搜索、邮件等网络服务。内容包括全球热点事件、突发新闻、时事评论、热播影视剧、体育赛事、行业动态、生活服务信息，以及论坛、博客、微博、我的搜狐等互动空间。&quot; /&gt;&lt;meta name=&quot;shenma-site-verification&quot; content=&quot;1237e4d02a3d8d73e96cbd97b699e9c3_1504254750&quot;&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;[root ~]# tail -2 sohu.html&lt;/body&gt;&lt;/html&gt;[root ~]# less sohu.html...[root ~]# cat -n sohu.html | more...</code></pre><blockquote><p><strong>说明</strong>：上面用到了一个名为 <code>wget</code>  的命令，它是一个网络下载器程序，可以从指定的 URL 下载资源。</p></blockquote></li><li><p>拷贝 / 移动文件 - <strong>cp</strong> / <strong>mv</strong>。</p><pre><code class="language-Shell">[root ~]# mkdir backup[root ~]# cp sohu.html backup/[root ~]# cd backup[root backup]# lssohu.html[root backup]# mv sohu.html sohu_index.html[root backup]# lssohu_index.html</code></pre></li><li><p>文件重命名 - <strong>rename</strong>。</p></li></ol><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# rename .htm .html *.htm</code></pre><ol start="8"><li><p>查找文件和查找内容 - <strong>find</strong> / <strong>grep</strong>。</p><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find / -name &quot;*.html&quot;/root/sohu.html/root/backup/sohu_index.html[root@izwz97tbgo9lkabnat2lo8z ~]# find . -atime 7 -type f -print[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -size +2k[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -name &quot;*.swp&quot; -delete[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep &quot;&lt;script&gt;&quot; sohu.html -n20:&lt;script&gt;[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep -E \&lt;\/?script.*\&gt; sohu.html -n20:&lt;script&gt;22:&lt;/script&gt;24:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/es5-shim-08e41cfc3e.min.js&quot;&gt;&lt;/script&gt;25:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/es5-sham-1d5fa1124b.min.js&quot;&gt;&lt;/script&gt;26:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/html5shiv-21fc8c2ba6.js&quot;&gt;&lt;/script&gt;29:&lt;script type=&quot;text/javascript&quot;&gt;52:&lt;/script&gt;...</code></pre><blockquote><p><strong>说明</strong>： <code>grep</code>  在搜索字符串时可以使用正则表达式，如果需要使用正则表达式可以用 <code>grep -E</code>  或者直接使用 <code>egrep</code> 。</p></blockquote></li><li><p>创建链接和查看链接 - <strong>ln</strong> / <strong>readlink</strong>。</p><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 1 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 2 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup2[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 3 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln -s /etc/centos-release sysinfo[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sysinfolrwxrwxrwx 1 root root 19 Jun 20 19:21 sysinfo -&gt; /etc/centos-release[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat sysinfoCentOS Linux release 7.4.1708 (Core)[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-releaseCentOS Linux release 7.4.1708 (Core)</code></pre><blockquote><p><strong>说明</strong>：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像 Python 中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加 1，只有当文件的链接数为 0 时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于 “文件粉碎机” 之类的软件在 “粉碎” 文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于 Windows 系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。</p></blockquote></li><li><p>压缩 / 解压缩和归档 / 解归档 - <strong>gzip</strong> / <strong>gunzip</strong> / <strong>xz</strong>。</p></li></ol><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://download.redis.io/releases/redis-4.0.10.tar.gz--2018-06-20 19:29:59--  http://download.redis.io/releases/redis-4.0.10.tar.gzResolving download.redis.io (download.redis.io)... 109.74.203.151Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1738465 (1.7M) [application/x-gzip]Saving to: ‘redis-4.0.10.tar.gz’100%[==================================================&gt;] 1,738,465   70.1KB/s   in 74s2018-06-20 19:31:14 (22.9 KB/s) - ‘redis-4.0.10.tar.gz’ saved [1738465/1738465][root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*redis-4.0.10.tar.gz[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-4.0.10.tar.gz[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*redis-4.0.10.tar</code></pre><ol start="11"><li>归档和解归档 - <strong>tar</strong>。</li></ol><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-4.0.10.tarredis-4.0.10/redis-4.0.10/.gitignoreredis-4.0.10/00-RELEASENOTESredis-4.0.10/BUGSredis-4.0.10/CONTRIBUTINGredis-4.0.10/COPYINGredis-4.0.10/INSTALLredis-4.0.10/MANIFESTOredis-4.0.10/Makefileredis-4.0.10/README.mdredis-4.0.10/deps/redis-4.0.10/deps/Makefileredis-4.0.10/deps/README.md...</code></pre><blockquote><p>说明：归档（也称为创建归档）和解归档都使用 <code>tar</code>  命令，通常创建归档需要 <code>-cvf</code>  三个参数，其中 <code>c</code>  表示创建（create）， <code>v</code>  表示显示创建归档详情（verbose）， <code>f</code>  表示指定归档的文件（file）；解归档需要加上 <code>-xvf</code>  参数，其中 <code>x</code>  表示抽取（extract），其他两个参数跟创建归档相同。</p></blockquote><ol start="12"><li>将标准输入转成命令行参数 - <strong>xargs</strong>。</li></ol><p>下面的命令会将查找当前路径下的 html 文件，然后通过 <code>xargs</code>  将这些文件作为参数传给 <code>rm</code>  命令，实现查找并删除文件的操作。</p><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find . -type f -name &quot;*.html&quot; | xargs rm -f</code></pre><p>下面的命令将 a.txt 文件中的多行内容变成一行输出到 b.txt 文件中，其中 <code>&lt;</code>  表示从 a.txt 中读取输入， <code>&gt;</code>  表示将命令的执行结果输出到 b.txt 中。</p><pre><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# xargs &lt; a.txt &gt; b.txt</code></pre><blockquote><p><strong>说明</strong>：这个命令就像上面演示的那样常在管道（实现进程间通信的一种方式）和重定向（重新指定输入输出的位置）操作中用到，后面的内容中会讲到管道操作和输入输出重定向操作。</p></blockquote><ol start="13"><li><p>显示文件或目录 - <strong>basename</strong> / <strong>dirname</strong>。</p></li><li><p>其他相关工具。</p></li></ol><ul><li><strong>sort</strong> - 对内容排序</li><li><strong>uniq</strong> - 去掉相邻重复内容</li><li><strong>tr</strong> - 替换指定内容为新内容</li><li><strong>cut</strong> / <strong>paste</strong> - 剪切 / 黏贴内容</li><li><strong>split</strong> - 拆分文件</li><li><strong>file</strong> - 判断文件类型</li><li><strong>wc</strong> - 统计文件行数、单词数、字节数</li><li><strong>iconv</strong> - 编码转换</li></ul><pre><code class="language-Shell">[root ~]# cat foo.txtgrapeapplepitaya[root ~]# cat bar.txt100200300400[root ~]# paste foo.txt bar.txtgrape   100apple   200pitaya  300        400[root ~]# paste foo.txt bar.txt &gt; hello.txt[root ~]# cut -b 4-8 hello.txtpe      10le      20aya     30[root ~]# cat hello.txt | tr '\t' ','grape,100apple,200pitaya,300,400[root ~]# split -l 100 sohu.html hello[root ~]# wget https://www.baidu.com/img/bd_logo1.png[root ~]# file bd_logo1.pngbd_logo1.png: PNG image data, 540 x 258, 8-bit colormap, non-interlaced[root ~]# wc sohu.html  2979   6355 212527 sohu.html[root ~]# wc -l sohu.html2979 sohu.html[root ~]# wget http://www.qq.com -O qq.html[root ~]# iconv -f gb2312 -t utf-8 qq.html</code></pre><h4 id="管道和重定向"><a class="anchor" href="#管道和重定向">#</a> 管道和重定向</h4><ol><li><p>管道的使用 - <strong>|</strong>。</p><p>例子：查找当前目录下文件个数。</p><pre><code class="language-Shell">[root ~]# find ./ | wc -l6152</code></pre><p>例子：列出当前路径下的文件和文件夹，给每一项加一个编号。</p><pre><code class="language-Shell">[root ~]# ls | cat -n     1  dump.rdb     2  mongodb-3.6.5     3  Python-3.6.5     4  redis-3.2.11     5  redis.conf</code></pre><p>例子：查找 record.log 中包含 AAA，但不包含 BBB 的记录的总数</p><pre><code class="language-Shell">[root ~]# cat record.log | grep AAA | grep -v BBB | wc -l</code></pre></li><li><p>输出重定向和错误重定向 - <strong>&gt;</strong> / <strong>&gt;&gt;</strong> / <strong>2&gt;</strong>。</p><pre><code class="language-Shell">[root ~]# cat readme.txtbananaapplegrapeapplegrapewatermelonpearpitaya[root ~]# cat readme.txt | sort | uniq &gt; result.txt[root ~]# cat result.txtapplebananagrapepearpitayawatermelon</code></pre></li><li><p>输入重定向 - <strong>&lt;</strong>。</p><pre><code class="language-Shell">[root ~]# echo 'hello, world!' &gt; hello.txt[root ~]# wall &lt; hello.txt[root ~]#Broadcast message from root (Wed Jun 20 19:43:05 2018):hello, world![root ~]# echo 'I will show you some code.' &gt;&gt; hello.txt[root ~]# wall &lt; hello.txt[root ~]#Broadcast message from root (Wed Jun 20 19:43:55 2018):hello, world!I will show you some code.</code></pre></li><li><p>多重定向 - <strong>tee</strong>。</p><p>下面的命令除了在终端显示命令 <code>ls</code>  的结果之外，还会追加输出到 <code>ls.txt</code>  文件中。</p><pre><code class="language-Shell">[root ~]# ls | tee -a ls.txt</code></pre></li></ol><h4 id="别名"><a class="anchor" href="#别名">#</a> 别名</h4><ol><li><p><strong>alias</strong></p><pre><code class="language-Shell">[root ~]# alias ll='ls -l'[root ~]# alias frm='rm -rf'[root ~]# ll...drwxr-xr-x  2 root       root   4096 Jun 20 12:52 abc...[root ~]# frm abc</code></pre></li><li><p><strong>unalias</strong></p><pre><code class="language-Shell">[root ~]# unalias frm[root ~]# frm sohu.html-bash: frm: command not found</code></pre></li></ol><h4 id="文本处理"><a class="anchor" href="#文本处理">#</a> 文本处理</h4><ol><li><p>字符流编辑器 - <strong>sed</strong>。</p><p>sed 是操作、过滤和转换文本内容的工具。假设有一个名为 fruit.txt 的文件，内容如下所示。</p><pre><code class="language-Shell">[root ~]# cat -n fruit.txt      1  banana     2  grape     3  apple     4  watermelon     5  orange</code></pre><p>接下来，我们在第 2 行后面添加一个 pitaya。</p><pre><code class="language-Shell">[root ~]# sed '2a pitaya' fruit.txt bananagrapepitayaapplewatermelonorange</code></pre><blockquote><p>注意：刚才的命令和之前我们讲过的很多命令一样并没有改变 fruit.txt 文件，而是将添加了新行的内容输出到终端中，如果想保存到 fruit.txt 中，可以使用输出重定向操作。</p></blockquote><p>在第 2 行前面插入一个 waxberry。</p><pre><code class="language-Shell">[root ~]# sed '2i waxberry' fruit.txtbananawaxberrygrapeapplewatermelonorange</code></pre><p>删除第 3 行。</p><pre><code class="language-Shell">[root ~]# sed '3d' fruit.txtbananagrapewatermelonorange</code></pre><p>删除第 2 行到第 4 行。</p><pre><code class="language-Shell">[root ~]# sed '2,4d' fruit.txtbananaorange</code></pre><p>将文本中的字符 a 替换为 @。</p><pre><code class="language-Shell">[root ~]# sed 's#a#@#' fruit.txt b@nanagr@pe@pplew@termelonor@nge</code></pre><p>将文本中的字符 a 替换为 @，使用全局模式。</p><pre><code class="language-Shell">[root ~]# sed 's#a#@#g' fruit.txt b@n@n@gr@pe@pplew@termelonor@nge</code></pre></li><li><p>模式匹配和处理语言 - <strong>awk</strong>。</p><p>awk 是一种编程语言，也是 Linux 系统中处理文本最为强大的工具，它的作者之一和现在的维护者就是之前提到过的 Brian Kernighan（ken 和 dmr 最亲密的伙伴）。通过该命令可以从文本中提取出指定的列、用正则表达式从文本中取出我们想要的内容、显示指定的行以及进行统计和运算，总之它非常强大。</p><p>假设有一个名为 fruit2.txt 的文件，内容如下所示。</p><pre><code class="language-Shell">[root ~]# cat fruit2.txt 1       banana      1202       grape       5003       apple       12304       watermelon  805       orange      400</code></pre><p>显示文件的第 3 行。</p><pre><code class="language-Shell">[root ~]# awk 'NR==3' fruit2.txt 3       apple       1230</code></pre><p>显示文件的第 2 列。</p><pre><code class="language-Shell">[root ~]# awk '&#123;print $2&#125;' fruit2.txt bananagrapeapplewatermelonorange</code></pre><p>显示文件的最后一列。</p><pre><code class="language-Shell">[root ~]# awk '&#123;print $NF&#125;' fruit2.txt 120500123080400</code></pre><p>输出末尾数字大于等于 300 的行。</p><pre><code class="language-Shell">[root ~]# awk '&#123;if($3 &gt;= 300) &#123;print $0&#125;&#125;' fruit2.txt 2       grape       5003       apple       12305       orange      400</code></pre><p>上面展示的只是 awk 命令的冰山一角，更多的内容留给读者自己在实践中去探索。</p></li></ol><h3 id="用户管理"><a class="anchor" href="#用户管理">#</a> 用户管理</h3><ol><li><p>创建和删除用户 - <strong>useradd</strong> / <strong>userdel</strong>。</p><pre><code class="language-Shell">[root home]# useradd hellokitty[root home]# userdel hellokitty</code></pre><ul><li><code>-d</code>  - 创建用户时为用户指定用户主目录</li><li><code>-g</code>  - 创建用户时指定用户所属的用户组</li></ul></li><li><p>创建和删除用户组 - <strong>groupadd</strong> / <strong>groupdel</strong>。</p><blockquote><p>说明：用户组主要是为了方便对一个组里面所有用户的管理。</p></blockquote></li><li><p>修改密码 - <strong>passwd</strong>。</p><pre><code class="language-Shell">[root ~]# passwd hellokittyNew password: Retype new password: passwd: all authentication tokens updated successfully.</code></pre><blockquote><p>说明：输入密码和确认密码没有回显且必须一气呵成的输入完成（不能使用退格键），密码和确认密码需要一致。如果使用 <code>passwd</code>  命令时没有指定命令作用的对象，则表示要修改当前用户的密码。如果想批量修改用户密码，可以使用 <code>chpasswd</code>  命令。</p></blockquote><ul><li><code>-l</code>  /  <code>-u</code>  - 锁定 / 解锁用户。</li><li><code>-d</code>  - 清除用户密码。</li><li><code>-e</code>  - 设置密码立即过期，用户登录时会强制要求修改密码。</li><li><code>-i</code>  - 设置密码过期多少天以后禁用该用户。</li></ul></li><li><p>查看和修改密码有效期 - <strong>chage</strong>。</p><p>设置 hellokitty 用户 100 天后必须修改密码，过期前 15 天通知该用户，过期后 7 天禁用该用户。</p><pre><code class="language-Shell">chage -M 100 -W 15 -I 7 hellokitty</code></pre></li><li><p>切换用户 - <strong>su</strong>。</p><pre><code class="language-Shell">[root ~]# su hellokitty[hellokitty root]$</code></pre></li><li><p>以管理员身份执行命令 - <strong>sudo</strong>。</p><pre><code class="language-Shell">[hellokitty ~]$ ls /rootls: cannot open directory /root: Permission denied[hellokitty ~]$ sudo ls /root[sudo] password for hellokitty:</code></pre><blockquote><p><strong>说明</strong>：如果希望用户能够以管理员身份执行命令，用户必须要出现在 sudoers 名单中，sudoers 文件在  <code>/etc</code>  目录下，如果希望直接编辑该文件也可以使用下面的命令。</p></blockquote></li><li><p>编辑 sudoers 文件 - <strong>visudo</strong>。</p><p>这里使用的编辑器是 vi，关于 vi 的知识在后面有讲解。该文件的部分内容如下所示：</p><pre><code>## Allow root to run any commands anywhere root    ALL=(ALL)   ALL## Allows members of the 'sys' group to run networking, software, ## service management apps and more.# %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS## Allows people in group wheel to run all commands%wheel  ALL=(ALL)   ALL## Same thing without a password# %wheel    ALL=(ALL)   NOPASSWD: ALL## Allows members of the users group to mount and unmount the## cdrom as root# %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom## Allows members of the users group to shutdown this system# %users  localhost=/sbin/shutdown -h now</code></pre></li><li><p>显示用户与用户组的信息 - <strong>id</strong>。</p></li><li><p>给其他用户发消息 -<strong>write</strong> / <strong>wall</strong>。</p><p>发送方：</p><pre><code class="language-Shell">[root ~]# write hellokittyDinner is on me.Call me at 6pm.</code></pre><p>接收方：</p><pre><code class="language-Shell">[hellokitty ~]$ Message from root on pts/0 at 17:41 ...Dinner is on me.Call me at 6pm.EOF</code></pre></li><li><p>查看 / 设置是否接收其他用户发送的消息 - <strong>mesg</strong>。</p></li></ol><pre><code class="language-Shell">[hellokitty ~]$ mesgis y[hellokitty ~]$ mesg n[hellokitty ~]$ mesgis n</code></pre><h3 id="文件系统"><a class="anchor" href="#文件系统">#</a> 文件系统</h3><h4 id="文件和路径"><a class="anchor" href="#文件和路径">#</a> 文件和路径</h4><ol><li>命名规则：文件名的最大长度与文件系统类型有关，一般情况下，文件名不应该超过 255 个字符，虽然绝大多数的字符都可以用于文件名，但是最好使用英文大小写字母、数字、下划线、点这样的符号。文件名中虽然可以使用空格，但应该尽可能避免使用空格，否则在输入文件名时需要用将文件名放在双引号中或者通过 <code>\</code>  对空格进行转义。</li><li>扩展名：在 Linux 系统下文件的扩展名是可选的，但是使用扩展名有助于对文件内容的理解。有些应用程序要通过扩展名来识别文件，但是更多的应用程序并不依赖文件的扩展名，就像 <code>file</code>  命令在识别文件时并不是依据扩展名来判定文件的类型。</li><li>隐藏文件：以点开头的文件在 Linux 系统中是隐藏文件（不可见文件）。</li></ol><h4 id="目录结构"><a class="anchor" href="#目录结构">#</a> 目录结构</h4><ol><li>/bin - 基本命令的二进制文件。</li><li>/boot - 引导加载程序的静态文件。</li><li>/dev - 设备文件。</li><li><strong>/etc</strong> - 配置文件。</li><li>/home - 普通用户主目录的父目录。</li><li>/lib - 共享库文件。</li><li>/lib64 - 共享 64 位库文件。</li><li>/lost+found - 存放未链接文件。</li><li>/media - 自动识别设备的挂载目录。</li><li>/mnt - 临时挂载文件系统的挂载点。</li><li>/opt - 可选插件软件包安装位置。</li><li>/proc -  内核和进程信息。</li><li><strong>/root</strong> - 超级管理员用户主目录。</li><li>/run - 存放系统运行时需要的东西。</li><li>/sbin - 超级用户的二进制文件。</li><li>/sys - 设备的伪文件系统。</li><li>/tmp - 临时文件夹。</li><li><strong>/usr</strong> - 用户应用目录。</li><li>/var - 变量数据目录。</li></ol><h4 id="访问权限"><a class="anchor" href="#访问权限">#</a> 访问权限</h4><ol><li><p><strong>chmod</strong> - 改变文件模式比特。</p><pre><code class="language-Shell">[root ~]# ls -l...-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html...[root ~]# chmod g+w,o+w sohu.html[root ~]# ls -l...-rw-rw-rw-  1 root       root 211878 Jun 19 16:06 sohu.html...[root ~]# chmod 644 sohu.html[root ~]# ls -l...-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html...</code></pre><blockquote><p>说明：通过上面的例子可以看出，用 <code>chmod</code>  改变文件模式比特有两种方式：一种是字符设定法，另一种是数字设定法。除了 <code>chmod</code>  之外，可以通过 <code>umask</code>  来设定哪些权限将在新文件的默认权限中被删除。</p></blockquote><p>长格式查看目录或文件时显示结果及其对应权限的数值如下表所示。</p><p><img data-src="./res/file-mode.png" alt="" /></p></li><li><p><strong>chown</strong> - 改变文件所有者。</p><pre><code class="language-Shell">[root ~]# ls -l...-rw-r--r--  1 root root     54 Jun 20 10:06 readme.txt...[root ~]# chown hellokitty readme.txt[root ~]# ls -l...-rw-r--r--  1 hellokitty root     54 Jun 20 10:06 readme.txt...</code></pre></li><li><p><strong>chgrp</strong> - 改变用户组。</p></li></ol><h4 id="磁盘管理"><a class="anchor" href="#磁盘管理">#</a> 磁盘管理</h4><ol><li><p>列出文件系统的磁盘使用状况 - <strong>df</strong>。</p><pre><code class="language-Shell">[root ~]# df -hFilesystem      Size  Used Avail Use% Mounted on/dev/vda1        40G  5.0G   33G  14% /devtmpfs        486M     0  486M   0% /devtmpfs           497M     0  497M   0% /dev/shmtmpfs           497M  356K  496M   1% /runtmpfs           497M     0  497M   0% /sys/fs/cgrouptmpfs           100M     0  100M   0% /run/user/0</code></pre></li><li><p>磁盘分区表操作 - <strong>fdisk</strong>。</p><pre><code class="language-Shell">[root ~]# fdisk -lDisk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000a42f4   Device Boot      Start         End      Blocks   Id  System/dev/vda1   *        2048    83884031    41940992   83  LinuxDisk /dev/vdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes</code></pre></li><li><p>磁盘分区工具 - <strong>parted</strong>。</p></li><li><p>格式化文件系统 - <strong>mkfs</strong>。</p><pre><code class="language-Shell">[root ~]# mkfs -t ext4 -v /dev/sdb</code></pre><ul><li><code>-t</code>  - 指定文件系统的类型。</li><li><code>-c</code>  - 创建文件系统时检查磁盘损坏情况。</li><li><code>-v</code>  - 显示详细信息。</li></ul></li><li><p>文件系统检查 - <strong>fsck</strong>。</p></li><li><p>转换或拷贝文件 - <strong>dd</strong>。</p></li><li><p>挂载 / 卸载 - <strong>mount</strong> / <strong>umount</strong>。</p></li><li><p>创建 / 激活 / 关闭交换分区 - <strong>mkswap</strong> / <strong>swapon</strong> / <strong>swapoff</strong>。</p></li></ol><blockquote><p><strong>说明</strong>：执行上面这些命令会带有一定的风险，如果不清楚这些命令的用法，最好不用随意使用，在使用的过程中，最好对照参考资料进行操作，并在操作前确认是否要这么做。</p></blockquote><h3 id="编辑器-vim"><a class="anchor" href="#编辑器-vim">#</a> 编辑器 - vim</h3><ol><li><p>启动 vim。可以通过 <code>vi</code>  或 <code>vim</code>  命令来启动 vim，启动时可以指定文件名来打开一个文件，如果没有指定文件名，也可以在保存的时候指定文件名。</p><pre><code class="language-Shell">[root ~]# vim guess.py</code></pre></li><li><p>命令模式、编辑模式和末行模式：启动 vim 进入的是命令模式（也称为 Normal 模式），在命令模式下输入英文字母 <code>i</code>  会进入编辑模式（Insert 模式），屏幕下方出现 <code>-- INSERT --</code>  提示；在编辑模式下按下 <code>Esc</code>  会回到命令模式，此时如果输入英文 <code>:</code>  会进入末行模式，在末行模式下输入 <code>q!</code>  可以在不保存当前工作的情况下强行退出 vim；在命令模式下输入 <code>v</code>  会进入可视模式（Visual 模式），可以用光标选择一个区域再完成对应的操作。</p></li><li><p>保存和退出 vim：在命令模式下输入 <code>:</code>  进入末行模式，输入 <code>wq</code>  可以实现保存退出；如果想放弃编辑的内容输入 <code>q!</code>  强行退出，这一点刚才已经提到过了；在命令模式下也可以直接输入 <code>ZZ</code>  实现保存退出。如果只想保存文件不退出，那么可以在末行模式下输入 <code>w</code> ；可以在 <code>w</code>  后面输入空格再指定要保存的文件名。</p></li><li><p>光标操作。</p><ul><li>在命令模式下可以通过 <code>h</code> 、 <code>j</code> 、 <code>k</code> 、 <code>l</code>  来控制光标向左、下、上、右的方向移动，可以在字母前输入数字来表示移动的距离，例如： <code>10h</code>  表示向左移动 10 个字符。</li><li>在命令模式下可以通过 <code>Ctrl+y</code>  和 <code>Ctrl+e</code>  来实现向上、向下滚动一行文本的操作，可以通过 <code>Ctrl+f</code>  和 <code>Ctrl+b</code>  来实现向前和向后翻页的操作。</li><li>在命令模式下可以通过输入英文字母 <code>G</code>  将光标移到文件的末尾，可以通过 <code>gg</code>  将光标移到文件的开始，也可以通过在 <code>G</code>  前输入数字来将光标移动到指定的行。</li></ul></li><li><p>文本操作。</p><ul><li>删除：在命令模式下可以用 <code>dd</code>  来删除整行；可以在 <code>dd</code>  前加数字来指定删除的行数；可以用 <code>d$</code>  来实现删除从光标处删到行尾的操作，也可以通过 <code>d0</code>  来实现从光标处删到行首的操作；如果想删除一个单词，可以使用 <code>dw</code> ；如果要删除全文，可以在输入 <code>:%d</code> （其中 <code>:</code>  用来从命令模式进入末行模式）。</li><li>复制和粘贴：在命令模式下可以用 <code>yy</code>  来复制整行；可以在 <code>yy</code>  前加数字来指定复制的行数；可以通过 <code>p</code>  将复制的内容粘贴到光标所在的地方。</li><li>撤销和恢复：在命令模式下输入 <code>u</code>  可以撤销之前的操作；通过 <code>Ctrl+r</code>  可以恢复被撤销的操作。</li><li>对内容进行排序：在命令模式下输入 <code>%!sort</code> 。</li></ul></li><li><p>查找和替换。</p><ul><li>查找操作需要输入 <code>/</code>  进入末行模式并提供正则表达式来匹配与之对应的内容，例如： <code>/doc.*\.</code> ，输入 <code>n</code>  来向前搜索，也可以输入 <code>N</code>  来向后搜索。</li><li>替换操作需要输入 <code>:</code>  进入末行模式并指定搜索的范围、正则表达式以及替换后的内容和匹配选项，例如： <code>:1,$s/doc.*/hello/gice</code> ，其中：<ul><li><code>g</code>  - global：全局匹配。</li><li><code>i</code>  - ignore case：忽略大小写匹配。</li><li><code>c</code>  - confirm：替换时需要确认。</li><li><code>e</code>  - error：忽略错误。</li></ul></li></ul></li><li><p>参数设定：在输入 <code>:</code>  进入末行模式后可以对 vim 进行设定。</p><ul><li><p>设置 Tab 键的空格数： <code>set ts=4</code></p></li><li><p>设置显示 / 不显示行号： <code>set nu</code>  /  <code>set nonu</code></p></li><li><p>设置启用 / 关闭高亮语法： <code>syntax on</code>  /  <code>syntax off</code></p></li><li><p>设置显示标尺（光标所在的行和列）：  <code>set ruler</code></p></li><li><p>设置启用 / 关闭搜索结果高亮： <code>set hls</code>  /  <code>set nohls</code></p><blockquote><p>说明：如果希望上面的这些设定在每次启动 vim 时都能自动生效，需要将这些设定写到用户主目录下的.vimrc 文件中。</p></blockquote></li></ul></li><li><p>高级技巧</p><ul><li><p>比较多个文件。</p><pre><code class="language-Shell">[root ~]# vim -d foo.txt bar.txt</code></pre><p><img data-src="./res/vim-diff.png" alt="" /></p></li><li><p>打开多个文件。</p><pre><code class="language-Shell">[root ~]# vim foo.txt bar.txt hello.txt</code></pre><p>启动 vim 后只有一个窗口显示的是 foo.txt，可以在末行模式中输入 <code>ls</code>  查看到打开的三个文件，也可以在末行模式中输入 <code>b &lt;num&gt;</code>  来显示另一个文件，例如可以用 <code>:b 2</code>  将 bar.txt 显示出来，可以用 <code>:b 3</code>  将 hello.txt 显示出来。</p></li><li><p>拆分和切换窗口。</p><p>可以在末行模式中输入 <code>sp</code>  或 <code>vs</code>  来实现对窗口的水平或垂直拆分，这样我们就可以同时打开多个编辑窗口，通过按两次 <code>Ctrl+w</code>  就可以实现编辑窗口的切换，在一个窗口中执行退出操作只会关闭对应的窗口，其他的窗口继续保留。</p><p><img data-src="./res/vim-multi-window.png" alt="" /></p></li><li><p>映射快捷键：在 vim 下可以将一些常用操作映射为快捷键来提升工作效率。</p><ul><li><p>例子 1：在命令模式下输入 <code>F4</code>  执行从第一行开始删除 10000 行代码的操作。</p><p><code>:map &lt;F4&gt; gg10000dd</code> 。</p><p>例子 2：在编辑模式下输入 <code>__main</code>  直接补全为 <code>if __name__ == '__main__':</code> 。</p><p><code>:inoremap __main if __name__ == '__main__':</code></p></li></ul><blockquote><p>说明：上面例子 2 的 <code>inoremap</code>  中的 <code>i</code>  表示映射的键在编辑模式使用，  <code>nore</code>  表示不要递归，这一点非常重要，否则如果键对应的内容中又出现键本身，就会引发递归（相当于进入了死循环）。如果希望映射的快捷键每次启动 vim 时都能生效，需要将映射写到用户主目录下的.vimrc 文件中。</p></blockquote></li><li><p>录制宏。</p><ul><li><p>在命令模式下输入 <code>qa</code>  开始录制宏（其中 <code>a</code>  是寄存器的名字，也可以是其他英文字母或 0-9 的数字）。</p></li><li><p>执行你的操作（光标操作、编辑操作等），这些操作都会被录制下来。</p></li><li><p>如果录制的操作已经完成了，按 <code>q</code>  结束录制。</p></li><li><p>通过 <code>@a</code> （ <code>a</code>  是刚才使用的寄存器的名字）播放宏，如果要多次执行宏可以在前面加数字，例如 <code>100@a</code>  表示将宏播放 100 次。</p></li><li><p>可以试一试下面的例子来体验录制宏的操作，该例子来源于<span class="exturl" data-url="aHR0cHM6Ly9oYXJ0dGxlLmxhbmQvdGFncy5odG1sI1ZpbQ=="> Harttle Land 网站</span>，该网站上提供了很多关于 vim 的使用技巧，有兴趣的可以了解一下。</p><p><img data-src="./res/vim-macro.png" alt="" /></p></li></ul></li></ul></li></ol><h3 id="软件安装和配置"><a class="anchor" href="#软件安装和配置">#</a> 软件安装和配置</h3><h4 id="使用包管理工具"><a class="anchor" href="#使用包管理工具">#</a> 使用包管理工具</h4><ol><li><strong>yum</strong> - Yellowdog Updater Modified。<ul><li><code>yum search</code> ：搜索软件包，例如 <code>yum search nginx</code> 。</li><li><code>yum list installed</code> ：列出已经安装的软件包，例如 <code>yum list installed | grep zlib</code> 。</li><li><code>yum install</code> ：安装软件包，例如 <code>yum install nginx</code> 。</li><li><code>yum remove</code> ：删除软件包，例如 <code>yum remove nginx</code> 。</li><li><code>yum update</code> ：更新软件包，例如 <code>yum update</code>  可以更新所有软件包，而 <code>yum update tar</code>  只会更新 tar。</li><li><code>yum check-update</code> ：检查有哪些可以更新的软件包。</li><li><code>yum info</code> ：显示软件包的相关信息，例如 <code>yum info nginx</code> 。</li></ul></li><li><strong>rpm</strong> - Redhat Package Manager。<ul><li>安装软件包： <code>rpm -ivh &lt;packagename&gt;.rpm</code> 。</li><li>移除软件包： <code>rpm -e &lt;packagename&gt;</code> 。</li><li>查询软件包： <code>rpm -qa</code> ，例如可以用 <code>rpm -qa | grep mysql</code>  来检查是否安装了 MySQL 相关的软件包。</li></ul></li></ol><p>下面以 Nginx 为例，演示如何使用 yum 安装软件。</p><pre><code class="language-Shell">[root ~]# yum -y install nginx...Installed:  nginx.x86_64 1:1.12.2-2.el7Dependency Installed:  nginx-all-modules.noarch 1:1.12.2-2.el7  nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7  nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7  nginx-mod-http-perl.x86_64 1:1.12.2-2.el7  nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7  nginx-mod-mail.x86_64 1:1.12.2-2.el7  nginx-mod-stream.x86_64 1:1.12.2-2.el7Complete![root ~]# yum info nginxLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfileInstalled PackagesName        : nginxArch        : x86_64Epoch       : 1Version     : 1.12.2Release     : 2.el7Size        : 1.5 MRepo        : installedFrom repo   : epelSummary     : A high performance web server and reverse proxy serverURL         : http://nginx.org/License     : BSDDescription : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and            : IMAP protocols, with a strong focus on high concurrency, performance and low            : memory usage.[root ~]# nginx -vnginx version: nginx/1.12.2</code></pre><p>移除 Nginx。</p><pre><code class="language-Shell">[root ~]# yum -y remove nginx</code></pre><p>下面以 MySQL 为例，演示如何使用 rpm 安装软件。要安装 MySQL 需要先到<span class="exturl" data-url="aHR0cHM6Ly93d3cubXlzcWwuY29tLw=="> MySQL 官方网站</span>下载对应的<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy9teXNxbC8="> RPM 文件</span>，当然要选择和你使用的 Linux 系统对应的版本。MySQL 现在是 Oracle 公司旗下的产品，在 MySQL 被收购后，MySQL 的作者重新制作了一个 MySQL 的分支 MariaDB，可以通过 yum 进行安装。</p><pre><code class="language-Shell">[root mysql]# lsmysql-community-client-5.7.22-1.el7.x86_64.rpmmysql-community-common-5.7.22-1.el7.x86_64.rpmmysql-community-libs-5.7.22-1.el7.x86_64.rpmmysql-community-server-5.7.22-1.el7.x86_64.rpm[root mysql]# yum -y remove mariadb-libs[root mysql]# yum -y install libaio[root mysql]#rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm...</code></pre><blockquote><p>说明：由于 MySQL 和<span class="exturl" data-url="aHR0cHM6Ly9tYXJpYWRiLm9yZy8="> MariaDB</span> 的底层依赖库是有冲突的，所以上面我们首先用 <code>yum</code>  移除了名为 mariadb-libs 的依赖库并安装了名为 libaio 支持异步 I/O 操作的依赖库。关于 MySQL 和 MariaDB 之间的关系，可以阅读<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTWFyaWFEQg==">维基百科</span>上关于 MariaDB 的介绍。</p></blockquote><p>移除安装的 MySQL。</p><pre><code class="language-Shell">[root ~]# rpm -qa | grep mysql | xargs rpm -e</code></pre><h4 id="下载解压配置环境变量"><a class="anchor" href="#下载解压配置环境变量">#</a> 下载解压配置环境变量</h4><p>下面以安装 MongoDB 为例，演示这类软件应该如何安装。</p><pre><code class="language-Shell">[root ~]# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz--2018-06-21 18:32:53--  https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgzResolving fastdl.mongodb.org (fastdl.mongodb.org)... 52.85.83.16, 52.85.83.228, 52.85.83.186, ...Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|52.85.83.16|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 100564462 (96M) [application/x-gzip]Saving to: ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’100%[==================================================&gt;] 100,564,462  630KB/s   in 2m 9s2018-06-21 18:35:04 (760 KB/s) - ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ saved [100564462/100564462][root ~]# gunzip mongodb-linux-x86_64-rhel70-3.6.5.tgz[root ~]# tar -xvf mongodb-linux-x86_64-rhel70-3.6.5.tarmongodb-linux-x86_64-rhel70-3.6.5/READMEmongodb-linux-x86_64-rhel70-3.6.5/THIRD-PARTY-NOTICESmongodb-linux-x86_64-rhel70-3.6.5/MPL-2mongodb-linux-x86_64-rhel70-3.6.5/GNU-AGPL-3.0mongodb-linux-x86_64-rhel70-3.6.5/bin/mongodumpmongodb-linux-x86_64-rhel70-3.6.5/bin/mongorestoremongodb-linux-x86_64-rhel70-3.6.5/bin/mongoexportmongodb-linux-x86_64-rhel70-3.6.5/bin/mongoimportmongodb-linux-x86_64-rhel70-3.6.5/bin/mongostatmongodb-linux-x86_64-rhel70-3.6.5/bin/mongotopmongodb-linux-x86_64-rhel70-3.6.5/bin/bsondumpmongodb-linux-x86_64-rhel70-3.6.5/bin/mongofilesmongodb-linux-x86_64-rhel70-3.6.5/bin/mongoreplaymongodb-linux-x86_64-rhel70-3.6.5/bin/mongoperfmongodb-linux-x86_64-rhel70-3.6.5/bin/mongodmongodb-linux-x86_64-rhel70-3.6.5/bin/mongosmongodb-linux-x86_64-rhel70-3.6.5/bin/mongomongodb-linux-x86_64-rhel70-3.6.5/bin/install_compass[root ~]# vim .bash_profile...PATH=$PATH:$HOME/bin:$HOME/mongodb-linux-x86_64-rhel70-3.6.5/binexport PATH...[root ~]# source .bash_profile[root ~]# mongod --versiondb version v3.6.5git version: a20ecd3e3a174162052ff99913bc2ca9a839d618OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013allocator: tcmallocmodules: nonebuild environment:    distmod: rhel70    distarch: x86_64    target_arch: x86_64[root ~]# mongo --versionMongoDB shell version v3.6.5git version: a20ecd3e3a174162052ff99913bc2ca9a839d618OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013allocator: tcmallocmodules: nonebuild environment:    distmod: rhel70    distarch: x86_64    target_arch: x86_64</code></pre><blockquote><p>说明：当然也可以通过 yum 来安装 MongoDB，具体可以参照<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hc3Rlci9hZG1pbmlzdHJhdGlvbi9pbnN0YWxsLW9uLWxpbnV4Lw==">官方网站</span>上给出的说明。</p></blockquote><h4 id="源代码构建安装"><a class="anchor" href="#源代码构建安装">#</a> 源代码构建安装</h4><ol><li><p>安装 Python 3.6。</p><pre><code class="language-Shell">[root ~]# yum install gcc[root ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz[root ~]# gunzip Python-3.6.5.tgz[root ~]# tar -xvf Python-3.6.5.tar[root ~]# cd Python-3.6.5[root ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations[root ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel[root ~]# make &amp;&amp; make install...[root ~]# ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3[root ~]# python3 --versionPython 3.6.5[root ~]# python3 -m pip install -U pip[root ~]# pip3 --version</code></pre><blockquote><p>说明：上面在安装好 Python 之后还需要注册 PATH 环境变量，将 Python 安装路径下 bin 文件夹的绝对路径注册到 PATH 环境变量中。注册环境变量可以修改用户主目录下的.bash_profile 或者 /etc 目录下的 profile 文件，二者的区别在于前者相当于是用户环境变量，而后者相当于是系统环境变量。</p></blockquote></li><li><p>安装 Redis-3.2.12。</p><pre><code class="language-Shell">[root ~]# wget http://download.redis.io/releases/redis-3.2.12.tar.gz[root ~]# gunzip redis-3.2.12.tar.gz[root ~]# tar -xvf redis-3.2.12.tar[root ~]# cd redis-3.2.12[root ~]# make &amp;&amp; make install[root ~]# redis-server --versionRedis server v=3.2.12 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5bc5cd3c03d6ceb6[root ~]# redis-cli --versionredis-cli 3.2.12</code></pre></li></ol><h3 id="配置服务"><a class="anchor" href="#配置服务">#</a> 配置服务</h3><p>我们可以 Linux 系统下安装和配置各种服务，也就是说我们可以把 Linux 系统打造成数据库服务器、Web 服务器、缓存服务器、文件服务器、消息队列服务器等等。Linux 下的大多数服务都被设置为守护进程（驻留在系统后台运行，但不会因为服务还在运行而导致 Linux 无法停止运行），所以我们安装的服务通常名字后面都有一个字母 <code>d</code> ，它是英文单词 <code>daemon</code>  的缩写，例如：防火墙服务叫 firewalld，我们之前安装的 MySQL 服务叫 mysqld，Apache 服务器叫 httpd 等。在安装好服务之后，可以使用 <code>systemctl</code>  命令或 <code>service</code>  命令来完成对服务的启动、停止等操作，具体操作如下所示。</p><ol><li><p>启动防火墙服务。</p><pre><code class="language-Shell">[root ~]# systemctl start firewalld</code></pre></li><li><p>终止防火墙服务。</p><pre><code class="language-Shell">[root ~]# systemctl stop firewalld</code></pre></li><li><p>重启防火墙服务。</p><pre><code class="language-Shell">[root ~]# systemctl restart firewalld</code></pre></li><li><p>查看防火墙服务状态。</p><pre><code class="language-Shell">[root ~]# systemctl status firewalld</code></pre></li><li><p>设置 / 禁用防火墙服务开机自启。</p><pre><code class="language-Shell">[root ~]# systemctl enable firewalldCreated symlink from /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service to /usr/lib/systemd/system/firewalld.service.Created symlink from /etc/systemd/system/multi-user.target.wants/firewalld.service to /usr/lib/systemd/system/firewalld.service.[root ~]# systemctl disable firewalldRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</code></pre></li></ol><h3 id="计划任务"><a class="anchor" href="#计划任务">#</a> 计划任务</h3><ol><li><p>在指定的时间执行命令。</p><ul><li><strong>at</strong> - 将任务排队，在指定的时间执行。</li><li><strong>atq</strong> - 查看待执行的任务队列。</li><li><strong>atrm</strong> - 从队列中删除待执行的任务。</li></ul><p>指定 3 天以后下午 5 点要执行的任务。</p><pre><code class="language-Shell">[root ~]# at 5pm+3daysat&gt; rm -f /root/*.htmlat&gt; &lt;EOT&gt;job 9 at Wed Jun  5 17:00:00 2019</code></pre><p>查看待执行的任务队列。</p><pre><code class="language-Shell">[root ~]# atq9       Wed Jun  5 17:00:00 2019 a root</code></pre><p>从队列中删除指定的任务。</p><pre><code class="language-Shell">[root ~]$ atrm 9</code></pre></li><li><p>计划任务表 - <strong>crontab</strong>。</p><pre><code class="language-Shell">[root ~]# crontab -e* * * * * echo &quot;hello, world!&quot; &gt;&gt; /root/hello.txt59 23 * * * rm -f /root/*.log</code></pre><blockquote><p>说明：输入 <code>crontab -e</code>  命令会打开 vim 来编辑 Cron 表达式并指定触发的任务，上面我们定制了两个计划任务，一个是每分钟向 /root 目录下的 hello.txt 中追加输出 <code>hello, world!</code> ；另一个是每天 23 时 59 分执行删除 /root 目录下以 log 为后缀名的文件。如果不知道 Cron 表达式如何书写，可以参照 /etc/crontab 文件中的提示（下面会讲到）或者用搜索引擎找一下 “Cron 表达式在线生成器” 来生成 Cron 表达式。</p></blockquote><p>和 crontab 相关的文件在 <code>/etc</code>  目录下，通过修改 <code>/etc</code>  目录下的 crontab 文件也能够定制计划任务。</p><pre><code class="language-Shell">[root ~]# cd /etc[root etc]# ls -l | grep cron-rw-------.  1 root root      541 Aug  3  2017 anacrontabdrwxr-xr-x.  2 root root     4096 Mar 27 11:56 cron.ddrwxr-xr-x.  2 root root     4096 Mar 27 11:51 cron.daily-rw-------.  1 root root        0 Aug  3  2017 cron.denydrwxr-xr-x.  2 root root     4096 Mar 27 11:50 cron.hourlydrwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.monthly-rw-r--r--   1 root root      493 Jun 23 15:09 crontabdrwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.weekly[root etc]# vim crontab  1 SHELL=/bin/bash  2 PATH=/sbin:/bin:/usr/sbin:/usr/bin  3 MAILTO=root  4  5 # For details see man 4 crontabs  6  7 # Example of job definition:  8 # .---------------- minute (0 - 59)  9 # |  .------------- hour (0 - 23) 10 # |  |  .---------- day of month (1 - 31) 11 # |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... 12 # |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat 13 # |  |  |  |  | 14 # *  *  *  *  * user-name  command to be executed</code></pre></li></ol><h3 id="网络访问和管理"><a class="anchor" href="#网络访问和管理">#</a> 网络访问和管理</h3><ol><li><p>安全远程连接 - <strong>ssh</strong>。</p><pre><code class="language-Shell">[root ~]$ ssh root@120.77.222.217The authenticity of host '120.77.222.217 (120.77.222.217)' can't be established.ECDSA key fingerprint is SHA256:BhUhykv+FvnIL03I9cLRpWpaCxI91m9n7zBWrcXRa8w.ECDSA key fingerprint is MD5:cc:85:e9:f0:d7:07:1a:26:41:92:77:6b:7f:a0:92:65.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '120.77.222.217' (ECDSA) to the list of known hosts.root@120.77.222.217's password: </code></pre></li><li><p>通过网络获取资源 - <strong>wget</strong>。</p><ul><li>-b 后台下载模式</li><li>-O 下载到指定的目录</li><li>-r 递归下载</li></ul></li><li><p>发送和接收邮件 - <strong>mail</strong>。</p></li><li><p>网络配置工具（旧） - <strong>ifconfig</strong>。</p><pre><code class="language-Shell">[root ~]# ifconfig eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.18.61.250  netmask 255.255.240.0  broadcast 172.18.63.255        ether 00:16:3e:02:b6:46  txqueuelen 1000  (Ethernet)        RX packets 1067841  bytes 1296732947 (1.2 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 409912  bytes 43569163 (41.5 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions </code></pre></li><li><p>网络配置工具（新） - <strong>ip</strong>。</p><pre><code class="language-Shell">[root ~]# ip address1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:16:3e:02:b6:46 brd ff:ff:ff:ff:ff:ff    inet 172.18.61.250/20 brd 172.18.63.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre></li><li><p>网络可达性检查 - <strong>ping</strong>。</p><pre><code class="language-Shell">[root ~]# ping www.baidu.com -c 3PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=1 ttl=51 time=36.3 ms64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=2 ttl=51 time=36.4 ms64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=3 ttl=51 time=36.4 ms--- www.a.shifen.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2002msrtt min/avg/max/mdev = 36.392/36.406/36.427/0.156 ms</code></pre></li><li><p>显示或管理路由表 - <strong>route</strong>。</p></li><li><p>查看网络服务和端口 - <strong>netstat</strong> / <strong>ss</strong>。</p><pre><code class="language-Shell">[root ~]# netstat -nap | grep nginx</code></pre></li><li><p>网络监听抓包 - <strong>tcpdump</strong>。</p></li><li><p>安全文件拷贝 - <strong>scp</strong>。</p></li></ol><pre><code class="language-Shell">[root ~]# scp root@1.2.3.4:/root/guido.jpg hellokitty@4.3.2.1:/home/hellokitty/pic.jpg</code></pre><ol start="11"><li><p>文件同步工具 - <strong>rsync</strong>。</p><blockquote><p>说明：使用 <code>rsync</code>  可以实现文件的自动同步，这个对于文件服务器来说相当重要。关于这个命令的用法，我们在后面讲项目部署的时候为大家详细说明。</p></blockquote></li><li><p>安全文件传输 - <strong>sftp</strong>。</p><pre><code class="language-Shell">[root ~]# sftp root@1.2.3.4root@1.2.3.4's password:Connected to 1.2.3.4.sftp&gt;</code></pre><ul><li><p><code>help</code> ：显示帮助信息。</p></li><li><p><code>ls</code> / <code>lls</code> ：显示远端 / 本地目录列表。</p></li><li><p><code>cd</code> / <code>lcd</code> ：切换远端 / 本地路径。</p></li><li><p><code>mkdir</code> / <code>lmkdir</code> ：创建远端 / 本地目录。</p></li><li><p><code>pwd</code> / <code>lpwd</code> ：显示远端 / 本地当前工作目录。</p></li><li><p><code>get</code> ：下载文件。</p></li><li><p><code>put</code> ：上传文件。</p></li><li><p><code>rm</code> ：删除远端文件。</p></li><li><p><code>bye</code> / <code>exit</code> / <code>quit</code> ：退出 sftp。</p></li></ul></li></ol><h3 id="进程管理"><a class="anchor" href="#进程管理">#</a> 进程管理</h3><ol><li><p>查看进程 - <strong>ps</strong>。</p><pre><code class="language-Shell">[root ~]# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 Jun23 ?        00:00:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 21root         2     0  0 Jun23 ?        00:00:00 [kthreadd]...[root ~]# ps -ef | grep mysqldroot      4943  4581  0 22:45 pts/0    00:00:00 grep --color=auto mysqldmysql    25257     1  0 Jun25 ?        00:00:39 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</code></pre></li><li><p>显示进程状态树 - <strong>pstree</strong>。</p><pre><code class="language-Shell">[root ~]# pstreesystemd─┬─AliYunDun───18*[&#123;AliYunDun&#125;]        ├─AliYunDunUpdate───3*[&#123;AliYunDunUpdate&#125;]        ├─2*[agetty]        ├─aliyun-service───2*[&#123;aliyun-service&#125;]        ├─atd        ├─auditd───&#123;auditd&#125;        ├─dbus-daemon        ├─dhclient        ├─irqbalance        ├─lvmetad        ├─mysqld───28*[&#123;mysqld&#125;]        ├─nginx───2*[nginx]        ├─ntpd        ├─polkitd───6*[&#123;polkitd&#125;]        ├─rsyslogd───2*[&#123;rsyslogd&#125;]        ├─sshd───sshd───bash───pstree        ├─systemd-journal        ├─systemd-logind        ├─systemd-udevd        └─tuned───4*[&#123;tuned&#125;]</code></pre></li><li><p>查找与指定条件匹配的进程 - <strong>pgrep</strong>。</p><pre><code class="language-Shell">[root ~]$ pgrep mysqld3584</code></pre></li><li><p>通过进程号终止进程 - <strong>kill</strong>。</p><pre><code class="language-Shell">[root ~]$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX[root ~]# kill 1234[root ~]# kill -9 1234</code></pre></li><li><p>通过进程名终止进程 - <strong>killall</strong> / <strong>pkill</strong>。</p><p>结束名为 mysqld 的进程。</p><pre><code class="language-Shell">[root ~]# pkill mysqld</code></pre><p>结束 hellokitty 用户的所有进程。</p><pre><code class="language-Shell">[root ~]# pkill -u hellokitty</code></pre><blockquote><p>说明：这样的操作会让 hellokitty 用户和服务器断开连接。</p></blockquote></li><li><p>将进程置于后台运行。</p><ul><li><code>Ctrl+Z</code>  - 快捷键，用于停止进程并置于后台。</li><li><code>&amp;</code>  - 将进程置于后台运行。</li></ul><pre><code class="language-Shell">[root ~]# mongod &amp;[root ~]# redis-server...^Z[4]+  Stopped                 redis-server</code></pre></li><li><p>查询后台进程 - <strong>jobs</strong>。</p><pre><code class="language-Shell">[root ~]# jobs[2]   Running                 mongod &amp;[3]-  Stopped                 cat[4]+  Stopped                 redis-server</code></pre></li><li><p>让进程在后台继续运行 - <strong>bg</strong>。</p><pre><code class="language-Shell">[root ~]# bg %4[4]+ redis-server &amp;[root ~]# jobs[2]   Running                 mongod &amp;[3]+  Stopped                 cat[4]-  Running                 redis-server &amp;</code></pre></li><li><p>将后台进程置于前台 - <strong>fg</strong>。</p><pre><code class="language-Shell">[root ~]# fg %4redis-server</code></pre><blockquote><p>说明：置于前台的进程可以使用 <code>Ctrl+C</code>  来终止它。</p></blockquote></li><li><p>调整程序 / 进程运行时优先级 - <strong>nice</strong> / <strong>renice</strong>。</p></li><li><p>用户登出后进程继续工作 - <strong>nohup</strong>。</p><pre><code class="language-Shell">[root ~]# nohup ping www.baidu.com &gt; result.txt &amp;</code></pre></li><li><p>跟踪进程系统调用情况 - <strong>strace</strong>。</p><pre><code class="language-Shell">[root ~]# pgrep mysqld8803[root ~]# strace -c -p 8803strace: Process 8803 attached^Cstrace: Process 8803 detached% time     seconds  usecs/call     calls    errors syscall------ ----------- ----------- --------- --------- ---------------- 99.18    0.005719        5719         1           restart_syscall  0.49    0.000028          28         1           mprotect  0.24    0.000014          14         1           clone  0.05    0.000003           3         1           mmap  0.03    0.000002           2         1           accept------ ----------- ----------- --------- --------- ----------------100.00    0.005766                     5           total</code></pre><blockquote><p>说明：这个命令的用法和参数都比较复杂，建议大家在真正用到这个命令的时候再根据实际需要进行了解。</p></blockquote></li><li><p>查看当前运行级别 - <strong>runlevel</strong>。</p><pre><code class="language-Shell">[root ~]# runlevelN 3</code></pre></li><li><p>实时监控进程占用资源状况 - <strong>top</strong>。</p><pre><code class="language-Shell">[root ~]# toptop - 23:04:23 up 3 days, 14:10,  1 user,  load average: 0.00, 0.01, 0.05Tasks:  65 total,   1 running,  64 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :  1016168 total,   191060 free,   324700 used,   500408 buff/cacheKiB Swap:        0 total,        0 free,        0 used.   530944 avail Mem...</code></pre><ul><li><code>-c</code>  - 显示进程的整个路径。</li><li><code>-d</code>  - 指定两次刷屏之间的间隔时间（秒为单位）。</li><li><code>-i</code>  - 不显示闲置进程或僵尸进程。</li><li><code>-p</code>  - 显示指定进程的信息。</li></ul></li></ol><h3 id="系统诊断"><a class="anchor" href="#系统诊断">#</a> 系统诊断</h3><ol><li><p>系统启动异常诊断 - <strong>dmesg</strong>。</p></li><li><p>查看系统活动信息 - <strong>sar</strong>。</p><pre><code class="language-Shell">[root ~]# sar -u -r 5 10Linux 3.10.0-957.10.1.el7.x86_64 (izwz97tbgo9lkabnat2lo8z)      06/02/2019      _x86_64_        (2 CPU)06:48:30 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle06:48:35 PM     all      0.10      0.00      0.10      0.00      0.00     99.8006:48:30 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty06:48:35 PM   1772012   2108392     54.33    102816   1634528    784940     20.23    793328   1164704         0</code></pre><ul><li><code>-A</code>  - 显示所有设备（CPU、内存、磁盘）的运行状况。</li><li><code>-u</code>  - 显示所有 CPU 的负载情况。</li><li><code>-d</code>  - 显示所有磁盘的使用情况。</li><li><code>-r</code>  - 显示内存的使用情况。</li><li><code>-n</code>  - 显示网络运行状态。</li></ul></li><li><p>查看内存使用情况 - <strong>free</strong>。</p><pre><code class="language-Shell">[root ~]# free              total        used        free      shared  buff/cache   availableMem:        1016168      323924      190452         356      501792      531800Swap:             0           0           0</code></pre></li><li><p>虚拟内存统计 - <strong>vmstat</strong>。</p><pre><code class="language-Shell">[root ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 2  0      0 204020  79036 667532    0    0     5    18  101   58  1  0 99  0  0</code></pre></li><li><p>CPU 信息统计 - <strong>mpstat</strong>。</p><pre><code class="language-Shell">[root ~]# mpstatLinux 3.10.0-957.5.1.el7.x86_64 (iZ8vba0s66jjlfmo601w4xZ)       05/30/2019      _x86_64_        (1 CPU)01:51:54 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle01:51:54 AM  all    0.71    0.00    0.17    0.04    0.00    0.00    0.00    0.00    0.00   99.07</code></pre></li><li><p>查看进程使用内存状况 - <strong>pmap</strong>。</p><pre><code class="language-Shell">[root ~]# ps  PID TTY          TIME CMD 4581 pts/0    00:00:00 bash 5664 pts/0    00:00:00 ps[root ~]# pmap 45814581:   -bash0000000000400000    884K r-x-- bash00000000006dc000      4K r---- bash00000000006dd000     36K rw--- bash00000000006e6000     24K rw---   [ anon ]0000000001de0000    400K rw---   [ anon ]00007f82fe805000     48K r-x-- libnss_files-2.17.so00007f82fe811000   2044K ----- libnss_files-2.17.so...</code></pre></li><li><p>报告设备 CPU 和 I/O 统计信息 - <strong>iostat</strong>。</p><pre><code class="language-Shell">[root ~]# iostatLinux 3.10.0-693.11.1.el7.x86_64 (iZwz97tbgo9lkabnat2lo8Z)      06/26/2018      _x86_64_       (1 CPU)avg-cpu:  %user   %nice %system %iowait  %steal   %idle           0.79    0.00    0.20    0.04    0.00   98.97Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtnvda               0.85         6.78        21.32    2106565    6623024vdb               0.00         0.01         0.00       2088          0</code></pre></li><li><p>显示所有 PCI 设备 - <strong>lspci</strong>。</p><pre><code class="language-Shell">[root ~]# lspci00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01)00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)00:02.0 VGA compatible controller: Cirrus Logic GD 544600:03.0 Ethernet controller: Red Hat, Inc. Virtio network device00:04.0 Communication controller: Red Hat, Inc. Virtio console00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device00:06.0 SCSI storage controller: Red Hat, Inc. Virtio block device00:07.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon</code></pre></li><li><p>显示进程间通信设施的状态 - <strong>ipcs</strong>。</p><pre><code class="language-Shell">[root ~]# ipcs------ Message Queues --------key        msqid      owner      perms      used-bytes   messages    ------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      ------ Semaphore Arrays --------key        semid      owner      perms      nsems</code></pre></li></ol><h3 id="shell编程"><a class="anchor" href="#shell编程">#</a> Shell 编程</h3><p>之前我们提到过，Shell 是一个连接用户和操作系统的应用程序，它提供了人机交互的界面（接口），用户通过这个界面访问操作系统内核的服务。Shell 脚本是一种为 Shell 编写的脚本程序，我们可以通过 Shell 脚本来进行系统管理，同时也可以通过它进行文件操作。总之，编写 Shell 脚本对于使用 Linux 系统的人来说，应该是一项标配技能。</p><p>互联网上有大量关于 Shell 脚本的相关知识，我不打算再此对 Shell 脚本做一个全面系统的讲解，我们通过下面的代码来感性的认识下 Shell 脚本就行了。</p><p>例子 1：输入两个整数 m 和 n，计算从 m 到 n 的整数求和的结果。</p><pre><code class="language-Shell">#!/usr/bin/bashprintf 'm = 'read mprintf 'n = 'read na=$msum=0while [ $a -le $n ]do    sum=$[ sum + a ]    a=$[ a + 1 ]doneecho '结果: '$sum</code></pre><p>例子 2：自动创建文件夹和指定数量的文件。</p><pre><code class="language-Shell">#!/usr/bin/bashprintf '输入文件夹名: 'read dirprintf '输入文件名: 'read fileprintf '输入文件数量(&lt;1000): 'read numif [ $num -ge 1000 ]then    echo '文件数量不能超过1000'else    if [ -e $dir -a -d $dir ]    then        rm -rf $dir    else        if [ -e $dir -a -f $dir ]        then            rm -f $dir        fi    fi    mkdir -p $dir    index=1    while [ $index -le $num ]    do        if [ $index -lt 10 ]        then            pre='00'        elif [ $index -lt 100 ]        then            pre='0'        else            pre=''        fi        touch $dir'/'$file'_'$pre$index        index=$[ index + 1 ]    donefi</code></pre><p>例子 3：自动安装指定版本的 Redis。</p><pre><code class="language-Shell">#!/usr/bin/bashinstall_redis() &#123;    if ! which redis-server &gt; /dev/null    then        cd /root        wget $1$2'.tar.gz' &gt;&gt; install.log        gunzip /root/$2'.tar.gz'        tar -xf /root/$2'.tar'        cd /root/$2        make &gt;&gt; install.log        make install &gt;&gt; install.log        echo '安装完成'    else        echo '已经安装过Redis'    fi&#125;install_redis 'http://download.redis.io/releases/' $1</code></pre><h3 id="相关资源"><a class="anchor" href="#相关资源">#</a> 相关资源</h3><ol><li><p>Linux 命令行常用快捷键</p><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td>tab</td><td>自动补全命令或路径</td></tr><tr><td>Ctrl+a</td><td>将光标移动到命令行行首</td></tr><tr><td>Ctrl+e</td><td>将光标移动到命令行行尾</td></tr><tr><td>Ctrl+f</td><td>将光标向右移动一个字符</td></tr><tr><td>Ctrl+b</td><td>将光标向左移动一个字符</td></tr><tr><td>Ctrl+k</td><td>剪切从光标到行尾的字符</td></tr><tr><td>Ctrl+u</td><td>剪切从光标到行首的字符</td></tr><tr><td>Ctrl+w</td><td>剪切光标前面的一个单词</td></tr><tr><td>Ctrl+y</td><td>复制剪切命名剪切的内容</td></tr><tr><td>Ctrl+c</td><td>中断正在执行的任务</td></tr><tr><td>Ctrl+h</td><td>删除光标前面的一个字符</td></tr><tr><td>Ctrl+d</td><td>退出当前命令行</td></tr><tr><td>Ctrl+r</td><td>搜索历史命令</td></tr><tr><td>Ctrl+g</td><td>退出历史命令搜索</td></tr><tr><td>Ctrl+l</td><td>清除屏幕上所有内容在屏幕的最上方开启一个新行</td></tr><tr><td>Ctrl+s</td><td>锁定终端使之暂时无法输入内容</td></tr><tr><td>Ctrl+q</td><td>退出终端锁定</td></tr><tr><td>Ctrl+z</td><td>将正在终端执行的任务停下来放到后台</td></tr><tr><td>!!</td><td>执行上一条命令</td></tr><tr><td>! 数字</td><td>执行数字对应的历史命令</td></tr><tr><td>! 字母</td><td>执行最近的以字母打头的命令</td></tr><tr><td>!$ / Esc+.</td><td>获得上一条命令最后一个参数</td></tr><tr><td>Esc+b</td><td>移动到当前单词的开头</td></tr><tr><td>Esc+f</td><td>移动到当前单词的结尾</td></tr></tbody></table></li><li><p>man 查阅命令手册的内容说明</p><table><thead><tr><th>手册中的标题</th><th>功能说明</th></tr></thead><tbody><tr><td>NAME</td><td>命令的说明和介绍</td></tr><tr><td>SYNOPSIS</td><td>使用该命令的基本语法</td></tr><tr><td>DESCRIPTION</td><td>使用该命令的详细描述，各个参数的作用，有时候这些信息会出现在 OPTIONS 中</td></tr><tr><td>OPTIONS</td><td>命令相关参数选项的说明</td></tr><tr><td>EXAMPLES</td><td>使用该命令的参考例子</td></tr><tr><td>EXIT STATUS</td><td>命令结束的退出状态码，通常 0 表示成功执行</td></tr><tr><td>SEE ALSO</td><td>和命令相关的其他命令或信息</td></tr><tr><td>BUGS</td><td>和命令相关的缺陷的描述</td></tr><tr><td>AUTHOR</td><td>该命令的作者介绍</td></tr></tbody></table></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web前端概述</title>
      <link href="/computer-science/python/basic/21-30.Web%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/"/>
      <url>/computer-science/python/basic/21-30.Web%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="web前端概述"><a class="anchor" href="#web前端概述">#</a> Web 前端概述</h2><blockquote><p><strong>说明</strong>：本文使用的部分插图来自<em> Jon Duckett</em> 先生的 *<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNuL2RwLzExMTgwMDgxODkvcmVmPXNyXzFfNT9fX21rX3poX0NOPSVFNCVCQSU5QSVFOSVBOSVBQyVFOSU4MCU4QSVFNyVCRCU5MSVFNyVBQiU5OSZhbXA7a2V5d29yZHM9aHRtbCslMjYrY3NzJmFtcDtxaWQ9MTU1NDYwOTMyNSZhbXA7cz1nYXRld2F5JmFtcDtzcj04LTU=">HTML and CSS: Design and Build Websites</span> * 一书，这是一本非常棒的前端入门书，有兴趣的读者可以在亚马逊或者其他网站上找到该书的购买链接。</p></blockquote><p>HTML 是用来描述网页的一种语言，全称是 Hyper-Text Markup Language，即超文本标记语言。我们浏览网页时看到的文字、按钮、图片、视频等元素，它们都是通过 HTML 书写并通过浏览器来呈现的。</p><h3 id="html简史"><a class="anchor" href="#html简史">#</a> HTML 简史</h3><ol><li>1991 年 10 月：一个非正式 CERN（<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFEJTkwJUU2JUI0JUIyJUU2JUEwJUI4JUU1JUFEJTkwJUU3JUEwJTk0JUU3JUE5JUI2JUU3JUI1JTg0JUU3JUI5JTk0">欧洲核子研究中心</span>）文件首次公开 18 个 HTML 标签，这个文件的作者是物理学家<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTkyJTgyJUU1JUE3JTg2JUMyJUI3JUU0JUJDJUFGJUU3JUJBJUIzJUU2JTk2JUFGLSVFNiU5RCU4RQ==">蒂姆・伯纳斯 - 李</span>，因此他是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JTg3JUU3JUJCJUI0JUU3JUJEJTkx">万维网</span>的发明者，也是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JTg3JUU3JUJCJUI0JUU3JUJEJTkxJUU4JTgxJTk0JUU3JTlCJTlG">万维网联盟</span>的主席。</li><li>1995 年 11 月：HTML 2.0 标准发布（RFC 1866）。</li><li>1997 年 1 月：HTML 3.2 作为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVzND"> W3C</span> 推荐标准发布。</li><li>1997 年 12 月：HTML 4.0 作为 W3C 推荐标准发布。</li><li>1999 年 12 月：HTML4.01 作为 W3C 推荐标准发布。</li><li>2008 年 1 月：HTML5 由 W3C 作为工作草案发布。</li><li>2011 年 5 月：W3C 将 HTML5 推进至 “最终征求”（Last Call）阶段。</li><li>2012 年 12 月：W3C 指定 HTML5 作为 “候选推荐” 阶段。</li><li>2014 年 10 月：HTML5 作为稳定 W3C 推荐标准发布，这意味着 HTML5 的标准化已经完成。</li></ol><h4 id="html5新特性"><a class="anchor" href="#html5新特性">#</a> HTML5 新特性</h4><ol><li>引入原生多媒体支持（audio 和 video 标签）</li><li>引入可编程内容（canvas 标签）</li><li>引入语义 Web（article、aside、details、figure、footer、header、nav、section、summary 等标签）</li><li>引入新的表单控件（日历、邮箱、搜索、滑条等）</li><li>引入对离线存储更好的支持（localStorage 和 sessionStorage）</li><li>引入对定位、拖放、WebSocket、后台任务等的支持</li></ol><h3 id="使用标签承载内容"><a class="anchor" href="#使用标签承载内容">#</a> 使用标签承载内容</h3><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDcxNjM0NDgucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211107163448.png</span>&quot; style=&quot;zoom:35%&quot;&gt;</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vamFja2ZydWVkL215cGljL3Jhdy9tYXN0ZXIvMjAyMTExMDcxNjM3NDEucG5n">https://gitee.com/jackfrued/mypic/raw/master/20211107163741.png</span>&quot; style=&quot;zoom:75%&quot;&gt;</p><h4 id="结构"><a class="anchor" href="#结构">#</a> 结构</h4><ul><li>html<ul><li>head<ul><li>title</li><li>meta</li></ul></li><li>body</li></ul></li></ul><h4 id="文本"><a class="anchor" href="#文本">#</a> 文本</h4><ul><li>标题（heading）和段落（paragraph）<ul><li>h1 ~ h6</li><li>p</li></ul></li><li>上标（superscript）和下标（subscript）<ul><li>sup</li><li>sub</li></ul></li><li>空白（白色空间折叠）</li><li>折行（break）和水平标尺（horizontal ruler）<ul><li>br</li><li>hr</li></ul></li><li>语义化标签<ul><li>加粗和强调 - strong</li><li>引用 - blockquote</li><li>缩写词和首字母缩写词 - abbr /acronym</li><li>引文 - cite</li><li>所有者联系信息 - address</li><li>内容的修改 - ins /del</li></ul></li></ul><h4 id="列表list"><a class="anchor" href="#列表list">#</a> 列表（list）</h4><ul><li>有序列表（ordered list）- ol /li</li><li>无序列表（unordered list）- ul /li</li><li>定义列表（definition list）- dl /dt/dd</li></ul><h4 id="链接anchor"><a class="anchor" href="#链接anchor">#</a> 链接（anchor）</h4><ul><li>页面链接</li><li>锚链接</li><li>功能链接</li></ul><h4 id="图像image"><a class="anchor" href="#图像image">#</a> 图像（image）</h4><ul><li><p>图像存储位置</p><p><img data-src="./res/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84.png" alt="" /></p></li><li><p>图像及其宽高</p></li><li><p>选择正确的图像格式</p><ul><li>JPEG</li><li>GIF</li><li>PNG</li></ul></li><li><p>矢量图</p></li><li><p>语义化标签 - figure /figcaption</p></li></ul><h4 id="表格table"><a class="anchor" href="#表格table">#</a> 表格（table）</h4><ul><li>基本的表格结构 - table /tr/td /th</li><li>表格的标题 - caption</li><li>跨行和跨列 - rowspan 属性 /colspan 属性</li><li>长表格 - thead /tbody/tfoot</li></ul><h4 id="表单form"><a class="anchor" href="#表单form">#</a> 表单（form）</h4><ul><li>重要属性 - action /method/enctype</li><li>表单控件（input）- type 属性<ul><li>文本框 -  <code>text</code>  / 密码框 -  <code>password</code>  / 数字框 -  <code>number</code></li><li>邮箱 -  <code>email</code>  / 电话 -  <code>tel</code>  / 日期 -  <code>date</code>  / 滑条 -  <code>range</code>  / URL -  <code>url</code>  / 搜索 -  <code>search</code></li><li>单选按钮 -  <code>radio</code>  / 复选按钮 -  <code>checkbox</code></li><li>文件上传 -  <code>file</code>  / 隐藏域 -  <code>hidden</code></li><li>提交按钮 -  <code>submit</code>  / 图像按钮 -  <code>image</code>   / 重置按钮 -  <code>reset</code></li></ul></li><li>下拉列表 - select /option</li><li>文本域（多行文本）- textarea</li><li>组合表单元素 - fieldset /legend</li></ul><h4 id="音视频audio-video"><a class="anchor" href="#音视频audio-video">#</a> 音视频（audio /video）</h4><ul><li>视频格式和播放器</li><li>视频托管服务</li><li>添加视频的准备工作</li><li>video 标签和属性 - autoplay /controls/loop /muted/preload /src</li><li>audio 标签和属性 - autoplay /controls/loop /muted/preload /src/width /height/poster</li></ul><h4 id="窗口frame"><a class="anchor" href="#窗口frame">#</a> 窗口（frame）</h4><ul><li><p>框架集（过时，不建议使用） - frameset /frame</p></li><li><p>内嵌窗口 - iframe</p></li></ul><h4 id="其他"><a class="anchor" href="#其他">#</a> 其他</h4><ul><li><p>文档类型</p><pre><code class="language-HTML">&lt;!doctype html&gt;</code></pre><pre><code class="language-HTML">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></pre><pre><code class="language-HTML">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></pre></li><li><p>注释</p><pre><code class="language-HTML">&lt;!-- 这是一段注释，注释不能够嵌套 --&gt;</code></pre></li><li><p>属性</p><ul><li>id：唯一标识</li><li>class：元素所属的类，用于区分不同的元素</li><li>title：元素的额外信息（鼠标悬浮时会显示工具提示文本）</li><li>tabindex：Tab 键切换顺序</li><li>contenteditable：元素是否可编辑</li><li>draggable：元素是否可拖拽</li></ul></li><li><p>块级元素 / 行级元素</p></li><li><p>字符实体（实体替换符）</p><p><img data-src="./res/%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93.png" alt="" /></p></li></ul><h3 id="使用css渲染页面"><a class="anchor" href="#使用css渲染页面">#</a> 使用 CSS 渲染页面</h3><h4 id="简介"><a class="anchor" href="#简介">#</a> 简介</h4><ul><li><p>CSS 的作用</p></li><li><p>CSS 的工作原理</p></li><li><p>规则、属性和值</p><p><img data-src="./res/%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%AD%E6%B3%95.png" alt="" /></p></li><li><p>常用选择器</p><p><img data-src="./res/%E5%B8%B8%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="" /></p></li></ul><h4 id="颜色color"><a class="anchor" href="#颜色color">#</a> 颜色（color）</h4><ul><li>如何指定颜色</li><li>颜色术语和颜色对比</li><li>背景色</li></ul><h4 id="文本text-font"><a class="anchor" href="#文本text-font">#</a> 文本（text /font）</h4><ul><li><p>文本的大小和字型 (font-size /font-family)</p><p><img data-src="./res/%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D.png" alt="" /></p><p><img data-src="./res/%E8%A1%AC%E7%BA%BF%E5%AD%97%E4%BD%93+%E9%9D%9E%E8%A1%AC%E7%BA%BF%E5%AD%97%E4%BD%93+%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93.png" alt="" /></p></li><li><p>粗细、样式、拉伸和装饰 (font-weight /font-style/font-stretch /text-decoration)</p><p><img data-src="./res/%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F.png" alt="" /></p></li><li><p>行间距 (line-height)、字母间距 (letter-spacing) 和单词间距 (word-spacing)</p></li><li><p>对齐 (text-align) 方式和缩进 (text-ident)</p></li><li><p>链接样式（:link / :visited / :active / :hover）</p></li><li><p>CSS3 新属性</p><ul><li>阴影效果 - text-shadow</li><li>首字母和首行文本 (:first-letter / :first-line)</li><li>响应用户</li></ul></li></ul><h4 id="盒子box-model"><a class="anchor" href="#盒子box-model">#</a> 盒子（box model）</h4><ul><li><p>盒子大小的控制（width /height）</p><p><img data-src="./res/%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D.png" alt="" /></p></li><li><p>盒子的边框、外边距和内边距（border /  margin /padding）</p><p><img data-src="./res/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png" alt="" /></p></li><li><p>盒子的显示和隐藏（display /visibility）</p></li><li><p>CSS3 新属性</p><ul><li>边框图像（border-image）</li><li>投影（border-shadow）</li><li>圆角（border-radius）</li></ul></li></ul><h4 id="列表-表格和表单"><a class="anchor" href="#列表-表格和表单">#</a> 列表、表格和表单</h4><ul><li>列表的项目符号（list-style）</li><li>表格的边框和背景（border-collapse）</li><li>表单控件的外观</li><li>表单控件的对齐</li><li>浏览器的开发者工具</li></ul><h4 id="图像"><a class="anchor" href="#图像">#</a> 图像</h4><ul><li>控制图像的大小（display: inline-block）</li><li>对齐图像</li><li>背景图像（background /background-image/background-repeat /background-position）</li></ul><h4 id="布局"><a class="anchor" href="#布局">#</a> 布局</h4><ul><li><p>控制元素的位置（position /z-index）</p><ul><li>普通流</li><li>相对定位</li><li>绝对定位</li><li>固定定位</li><li>浮动元素（float /clear）</li></ul></li><li><p>网站布局</p><ul><li><p>HTML5 布局</p><p><img data-src="./res/%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80-2.png" alt="" /></p></li></ul></li><li><p>适配屏幕尺寸</p><ul><li>固定宽度布局</li><li>流体布局</li><li>布局网格</li></ul></li></ul><h3 id="使用javascript控制行为"><a class="anchor" href="#使用javascript控制行为">#</a> 使用 JavaScript 控制行为</h3><h4 id="javascript基本语法"><a class="anchor" href="#javascript基本语法">#</a> JavaScript 基本语法</h4><ul><li>语句和注释</li><li>变量和数据类型<ul><li>声明和赋值</li><li>简单数据类型和复杂数据类型</li><li>变量的命名规则</li></ul></li><li>表达式和运算符<ul><li>赋值运算符</li><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符： <code>&amp;&amp;</code> 、 <code>||</code> 、 <code>!</code></li></ul></li><li>分支结构<ul><li><code>if...else...</code></li><li><code>switch...cas...default...</code></li></ul></li><li>循环结构<ul><li><code>for</code>  循环</li><li><code>while</code>  循环</li><li><code>do...while</code>  循环</li></ul></li><li>数组<ul><li>创建数组</li><li>操作数组中的元素</li></ul></li><li>函数<ul><li>声明函数</li><li>调用函数</li><li>参数和返回值</li><li>匿名函数</li><li>立即调用函数</li></ul></li></ul><h4 id="面向对象"><a class="anchor" href="#面向对象">#</a> 面向对象</h4><ul><li>对象的概念</li><li>创建对象的字面量语法</li><li>访问成员运算符</li><li>创建对象的构造函数语法<ul><li><code>this</code>  关键字</li></ul></li><li>添加和删除属性<ul><li><code>delete</code>  关键字</li></ul></li><li>标准对象<ul><li><code>Number</code>  /  <code>String</code>  /  <code>Boolean</code>  /  <code>Symbol</code>  /  <code>Array</code>  /  <code>Function</code></li><li><code>Date</code>  /  <code>Error</code>  /  <code>Math</code>  /  <code>RegExp</code>  /  <code>Object</code>  /  <code>Map</code>  /  <code>Set</code></li><li><code>JSON</code>  /  <code>Promise</code>  /  <code>Generator</code>  /  <code>Reflect</code>  /  <code>Proxy</code></li></ul></li></ul><h4 id="bom"><a class="anchor" href="#bom">#</a> BOM</h4><ul><li><code>window</code>  对象的属性和方法</li><li><code>history</code>  对象<ul><li><code>forward()</code>  /  <code>back()</code>  /  <code>go()</code></li></ul></li><li><code>location</code>  对象</li><li><code>navigator</code>  对象</li><li><code>screen</code>  对象</li></ul><h4 id="dom"><a class="anchor" href="#dom">#</a> DOM</h4><ul><li>DOM 树</li><li>访问元素<ul><li><code>getElementById()</code>  /  <code>querySelector()</code></li><li><code>getElementsByClassName()</code>  /  <code>getElementsByTagName()</code>  /  <code>querySelectorAll()</code></li><li><code>parentNode</code>  /  <code>previousSibling</code>  /  <code>nextSibling</code>  /  <code>children</code>  /  <code>firstChild</code>  /  <code>lastChild</code></li></ul></li><li>操作元素<ul><li><code>nodeValue</code></li><li><code>innerHTML</code>  /  <code>textContent</code>  /  <code>createElement()</code>  /  <code>createTextNode()</code>  /  <code>appendChild()</code>  /  <code>insertBefore()</code>  /  <code>removeChild()</code></li><li><code>className</code>  /  <code>id</code>  /  <code>hasAttribute()</code>  /  <code>getAttribute()</code>  /  <code>setAttribute()</code>  /  <code>removeAttribute()</code></li></ul></li><li>事件处理<ul><li>事件类型<ul><li>UI 事件： <code>load</code>  /  <code>unload</code>  /  <code>error</code>  /  <code>resize</code>  /  <code>scroll</code></li><li>键盘事件： <code>keydown</code>  /  <code>keyup</code>  /  <code>keypress</code></li><li>鼠标事件： <code>click</code>  /  <code>dbclick</code>  /  <code>mousedown</code>  /  <code>mouseup</code>  /  <code>mousemove</code>  /  <code>mouseover</code>  /  <code>mouseout</code></li><li>焦点事件： <code>focus</code>  /  <code>blur</code></li><li>表单事件： <code>input</code>  /  <code>change</code>  /  <code>submit</code>  /  <code>reset</code>  /  <code>cut</code>  /  <code>copy</code>  /  <code>paste</code>  /  <code>select</code></li></ul></li><li>事件绑定<ul><li>HTML 事件处理程序（不推荐使用，因为要做到标签与代码分离）</li><li>传统的 DOM 事件处理程序（只能附加一个回调函数）</li><li>事件监听器（旧的浏览器中不被支持）</li></ul></li><li>事件流：事件捕获 / 事件冒泡</li><li>事件对象（低版本 IE 中的 window.event）<ul><li><code>target</code> （有些浏览器使用 srcElement）</li><li><code>type</code></li><li><code>cancelable</code></li><li><code>preventDefault()</code></li><li><code>stopPropagation()</code> （低版本 IE 中的 cancelBubble）</li></ul></li><li>鼠标事件 - 事件发生的位置<ul><li>屏幕位置： <code>screenX</code>  和 <code>screenY</code></li><li>页面位置： <code>pageX</code>  和 <code>pageY</code></li><li>客户端位置： <code>clientX</code>  和 <code>clientY</code></li></ul></li><li>键盘事件 - 哪个键被按下了<ul><li><code>keyCode</code>  属性（有些浏览器使用 <code>which</code> ）</li><li><code>String.fromCharCode(event.keyCode)</code></li></ul></li><li>HTML5 事件<ul><li><code>DOMContentLoaded</code></li><li><code>hashchange</code></li><li><code>beforeunload</code></li></ul></li></ul></li></ul><h4 id="javascript-api"><a class="anchor" href="#javascript-api">#</a> JavaScript API</h4><ul><li><p>客户端存储 -  <code>localStorage</code>  和 <code>sessionStorage</code></p><pre><code class="language-JavaScript">localStorage.colorSetting = '#a4509b';localStorage['colorSetting'] = '#a4509b';localStorage.setItem('colorSetting', '#a4509b');</code></pre></li><li><p>获取位置信息 -  <code>geolocation</code></p><pre><code class="language-JavaScript">navigator.geolocation.getCurrentPosition(function(pos) &#123;       console.log(pos.coords.latitude)    console.log(pos.coords.longitude)&#125;)</code></pre></li><li><p>从服务器获取数据 - Fetch API</p></li><li><p>绘制图形 -  <code>&lt;canvas&gt;</code>  的 API</p></li><li><p>音视频 -  <code>&lt;audio&gt;</code>  和 <code>&lt;video&gt;</code>  的 API</p></li></ul><h3 id="使用jquery"><a class="anchor" href="#使用jquery">#</a> 使用 jQuery</h3><h4 id="jquery概述"><a class="anchor" href="#jquery概述">#</a> jQuery 概述</h4><ol><li>Write Less Do More（用更少的代码来完成更多的工作）</li><li>使用 CSS 选择器来查找元素（更简单更方便）</li><li>使用 jQuery 方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法）</li></ol><h4 id="引入jquery"><a class="anchor" href="#引入jquery">#</a> 引入 jQuery</h4><ul><li>下载 jQuery 的开发版和压缩版</li><li>从 CDN 加载 jQuery</li></ul><pre><code class="language-HTML">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    window.jQuery ||         document.write('&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;')&lt;/script&gt;</code></pre><h4 id="查找元素"><a class="anchor" href="#查找元素">#</a> 查找元素</h4><ul><li>选择器<ul><li>* / element / #id / .class / selector1, selector2</li><li>ancestor descendant / parent&gt;child / previous+next / previous~siblings</li></ul></li><li>筛选器<ul><li>基本筛选器：:not (selector) / :first / :last / :even / :odd / :eq (index) / :gt (index) / :lt (index) / :animated / :focus</li><li>内容筛选器：:contains ('…') / :empty / :parent / :has (selector)</li><li>可见性筛选器：:hidden / :visible</li><li>子节点筛选器：:nth-child (expr) / :first-child / :last-child / :only-child</li><li>属性筛选器：[attribute] / [attribute='value'] / [attribute!='value'] / [attribute^='value'] / [attribute$='value'] / [attribute|='value'] / [attribute~='value']</li></ul></li><li>表单：:input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked</li></ul><h4 id="执行操作"><a class="anchor" href="#执行操作">#</a> 执行操作</h4><ul><li>内容操作<ul><li>获取 / 修改内容： <code>html()</code>  /  <code>text()</code>  /  <code>replaceWith()</code>  /  <code>remove()</code></li><li>获取 / 设置元素： <code>before()</code>  /  <code>after()</code>  /  <code>prepend()</code>  /  <code>append()</code>  /  <code>remove()</code>  /  <code>clone()</code>  /  <code>unwrap()</code>  /  <code>detach()</code>  /  <code>empty()</code>  /  <code>add()</code></li><li>获取 / 修改属性： <code>attr()</code>  /  <code>removeAttr()</code>  /  <code>addClass()</code>  /  <code>removeClass()</code>  /  <code>css()</code></li><li>获取 / 设置表单值： <code>val()</code></li></ul></li><li>查找操作<ul><li>查找方法： <code>find()</code>  /   <code>parent()</code>  /  <code>children()</code>  /  <code>siblings()</code>  /  <code>next()</code>  /  <code>nextAll()</code>  /  <code>prev()</code>  /  <code>prevAll()</code></li><li>筛选器： <code>filter()</code>  /  <code>not()</code>  /  <code>has()</code>  /  <code>is()</code>  /  <code>contains()</code></li><li>索引编号： <code>eq()</code></li></ul></li><li>尺寸和位置<ul><li>尺寸相关： <code>height()</code>  /  <code>width()</code>  /  <code>innerHeight()</code>  /  <code>innerWidth()</code>  /  <code>outerWidth()</code>  /  <code>outerHeight()</code></li><li>位置相关： <code>offset()</code>  /  <code>position()</code>  /  <code>scrollLeft()</code>  /  <code>scrollTop()</code></li></ul></li><li>特效和动画<ul><li>基本动画： <code>show()</code>  /  <code>hide()</code>  /  <code>toggle()</code></li><li>消失出现： <code>fadeIn()</code>  /  <code>fadeOut()</code>  /  <code>fadeTo()</code>  /  <code>fadeToggle()</code></li><li>滑动效果： <code>slideDown()</code>  /  <code>slideUp()</code>  /  <code>slideToggle()</code></li><li>自定义： <code>delay()</code>  /  <code>stop()</code>  /  <code>animate()</code></li></ul></li><li>事件<ul><li>文档加载： <code>ready()</code>  /  <code>load()</code></li><li>用户交互： <code>on()</code>  /  <code>off()</code></li></ul></li></ul><h4 id="链式操作"><a class="anchor" href="#链式操作">#</a> 链式操作</h4><h4 id="检测页面是否可用"><a class="anchor" href="#检测页面是否可用">#</a> 检测页面是否可用</h4><pre><code class="language-HTML">&lt;script&gt;    $(document).ready(function() &#123;            &#125;);&lt;/script&gt;</code></pre><pre><code class="language-HTML">&lt;script&gt;    $(function() &#123;            &#125;);&lt;/script&gt;</code></pre><h4 id="jquery插件"><a class="anchor" href="#jquery插件">#</a> jQuery 插件</h4><ul><li>jQuery Validation</li><li>jQuery Treeview</li><li>jQuery Autocomplete</li><li>jQuery UI</li></ul><h4 id="避免和其他库的冲突"><a class="anchor" href="#避免和其他库的冲突">#</a> 避免和其他库的冲突</h4><p>先引入其他库再引入 jQuery 的情况。</p><pre><code class="language-HTML">&lt;script src=&quot;other.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt;jQuery.noConflict();    jQuery(function() &#123;        jQuery('div').hide();    &#125;);&lt;/script&gt;</code></pre><p>先引入 jQuery 再引入其他库的情况。</p><pre><code class="language-HTML">&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;other.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    jQuery(function() &#123;        jQuery('div').hide();    &#125;);&lt;/script&gt;</code></pre><h4 id="使用ajax"><a class="anchor" href="#使用ajax">#</a> 使用 Ajax</h4><p>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><ul><li>原生的 Ajax</li><li>基于 jQuery 的 Ajax<ul><li>加载内容</li><li>提交表单</li></ul></li></ul><h3 id="前端框架"><a class="anchor" href="#前端框架">#</a> 前端框架</h3><h4 id="渐进式框架-vuejs"><a class="anchor" href="#渐进式框架-vuejs">#</a> 渐进式框架 - <span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv">Vue.js</span></h4><p>前后端分离开发（前端渲染）必选框架。</p><h5 id="快速上手"><a class="anchor" href="#快速上手">#</a> 快速上手</h5><ol><li><p>引入 Vue 的 JavaScript 文件，我们仍然推荐从 CDN 服务器加载它。</p><pre><code class="language-HTML">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>数据绑定（声明式渲染 ）。</p><pre><code class="language-HTML">&lt;div id=&quot;app&quot;&gt;&lt;h1&gt;&#123;&#123; product &#125;&#125;库存信息&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script&gt;const app = new Vue(&#123;el: '#app',data: &#123;product: 'iPhone X'&#125;&#125;);&lt;/script&gt;</code></pre></li><li><p>条件与循环。</p><pre><code class="language-HTML">&lt;div id=&quot;app&quot;&gt;&lt;h1&gt;库存信息&lt;/h1&gt;    &lt;hr&gt;&lt;ul&gt;&lt;li v-for=&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;&lt;span v-if=&quot;product.quantity === 0&quot;&gt;已经售罄&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script&gt;const app = new Vue(&#123;el: '#app',data: &#123;products: [&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;]&#125;&#125;);&lt;/script&gt;</code></pre></li><li><p>计算属性。</p><pre><code class="language-HTML">&lt;div id=&quot;app&quot;&gt;&lt;h1&gt;库存信息&lt;/h1&gt;&lt;hr&gt;&lt;ul&gt;&lt;li v-for=&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;&lt;span v-if=&quot;product.quantity === 0&quot;&gt;已经售罄&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script&gt;const app = new Vue(&#123;el: '#app',data: &#123;products: [&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;]&#125;,computed: &#123;totalQuantity() &#123;return this.products.reduce((sum, product) =&gt; &#123;return sum + product.quantity&#125;, 0);&#125;&#125;&#125;);&lt;/script&gt;</code></pre></li><li><p>处理事件。</p><pre><code class="language-HTML">&lt;div id=&quot;app&quot;&gt;&lt;h1&gt;库存信息&lt;/h1&gt;&lt;hr&gt;&lt;ul&gt;&lt;li v-for=&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;&lt;span v-if=&quot;product.quantity === 0&quot;&gt;已经售罄&lt;/span&gt;&lt;button @click=&quot;product.quantity += 1&quot;&gt;增加库存&lt;/button&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script&gt;const app = new Vue(&#123;el: '#app',data: &#123;products: [&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;]&#125;,computed: &#123;totalQuantity() &#123;return this.products.reduce((sum, product) =&gt; &#123;return sum + product.quantity&#125;, 0);&#125;&#125;&#125;);&lt;/script&gt;</code></pre></li><li><p>用户输入。</p><pre><code class="language-HTML">&lt;div id=&quot;app&quot;&gt;&lt;h1&gt;库存信息&lt;/h1&gt;&lt;hr&gt;&lt;ul&gt;&lt;li v-for=&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &lt;input type=&quot;number&quot; v-model.number=&quot;product.quantity&quot; min=&quot;0&quot;&gt;&lt;span v-if=&quot;product.quantity === 0&quot;&gt;已经售罄&lt;/span&gt;&lt;button @click=&quot;product.quantity += 1&quot;&gt;增加库存&lt;/button&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script&gt;const app = new Vue(&#123;el: '#app',data: &#123;products: [&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;]&#125;,computed: &#123;totalQuantity() &#123;return this.products.reduce((sum, product) =&gt; &#123;return sum + product.quantity&#125;, 0);&#125;&#125;&#125;);&lt;/script&gt;</code></pre></li><li><p>通过网络加载 JSON 数据。</p><pre><code class="language-HTML">&lt;div id=&quot;app&quot;&gt;&lt;h2&gt;库存信息&lt;/h2&gt;&lt;ul&gt;&lt;li v-for=&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;&lt;span v-if=&quot;product.quantity === 0&quot;&gt;已经售罄&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script&gt;const app = new Vue(&#123;el: '#app',data: &#123;products: []&#125;，created() &#123;fetch('https://jackfrued.top/api/products').then(response =&gt; response.json()).then(json =&gt; &#123;this.products = json&#125;);&#125;&#125;);&lt;/script&gt;</code></pre></li></ol><h5 id="使用脚手架-vue-cli"><a class="anchor" href="#使用脚手架-vue-cli">#</a> 使用脚手架 - vue-cli</h5><p>Vue 为商业项目开发提供了非常便捷的脚手架工具 vue-cli，通过工具可以省去手工配置开发环境、测试环境和运行环境的步骤，让开发者只需要关注要解决的问题。</p><ol><li>安装脚手架。</li><li>创建项目。</li><li>安装依赖包。</li><li>运行项目。</li></ol><h4 id="ui框架-element"><a class="anchor" href="#ui框架-element">#</a> UI 框架 - <span class="exturl" data-url="aHR0cDovL2VsZW1lbnQtY24uZWxlbWUuaW8vIy96aC1DTg==">Element</span></h4><p>基于 Vue 2.0 的桌面端组件库，用于构造用户界面，支持响应式布局。</p><ol><li><p>引入 Element 的 CSS 和 JavaScript 文件。</p><pre><code class="language-HTML">&lt;!-- 引入样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>一个简单的例子。</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;el-button @click=&quot;visible = true&quot;&gt;点我&lt;/el-button&gt;&lt;el-dialog :visible.sync=&quot;visible&quot; title=&quot;Hello world&quot;&gt;&lt;p&gt;开始使用Element吧&lt;/p&gt;&lt;/el-dialog&gt;            &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;script&gt;new Vue(&#123;el: '#app',data: &#123;visible: false,&#125;&#125;)&lt;/script&gt;&lt;/html&gt;</code></pre></li><li><p>使用组件。</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;el-table :data=&quot;tableData&quot; stripe style=&quot;width: 100%&quot;&gt;&lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;&lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;&lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt;&lt;/el-table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;script&gt;new Vue(&#123;el: '#app',data: &#123;tableData:  [&#123;date: '2016-05-02',name: '王一霸',address: '上海市普陀区金沙江路 1518 弄'&#125;, &#123;date: '2016-05-04',name: '刘二狗',address: '上海市普陀区金沙江路 1517 弄'&#125;, &#123;date: '2016-05-01',name: '杨三萌',address: '上海市普陀区金沙江路 1519 弄'&#125;, &#123;date: '2016-05-03',name: '陈四吹',address: '上海市普陀区金沙江路 1516 弄'&#125;]&#125;&#125;)&lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><h4 id="报表框架-echarts"><a class="anchor" href="#报表框架-echarts">#</a> 报表框架 - <span class="exturl" data-url="aHR0cHM6Ly9lY2hhcnRzLmJhaWR1LmNvbQ==">ECharts</span></h4><p>百度出品的开源可视化库，常用于生成各种类型的报表。</p><p><img data-src="./res/baidu_echarts.png" alt="" /></p><h4 id="基于弹性盒子的css框架-bulma"><a class="anchor" href="#基于弹性盒子的css框架-bulma">#</a> 基于弹性盒子的 CSS 框架 - <span class="exturl" data-url="aHR0cHM6Ly9idWxtYS5pby8=">Bulma</span></h4><p>Bulma 是一个基于 Flexbox 的现代化的 CSS 框架，其初衷就是移动优先（Mobile First），模块化设计，可以轻松用来实现各种简单或者复杂的内容布局，即使不懂 CSS 的开发者也能够使用它定制出漂亮的页面。</p><pre><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Bulma&lt;/title&gt;&lt;link href=&quot;https://cdn.bootcss.com/bulma/0.7.4/css/bulma.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;div &#123; margin-top: 10px; &#125;.column &#123; color: #fff; background-color: #063; margin: 10px 10px; text-align: center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;columns&quot;&gt;&lt;div class=&quot;column&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;column&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;column&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;column&quot;&gt;4&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;a class=&quot;button is-primary&quot;&gt;Primary&lt;/a&gt;&lt;a class=&quot;button is-link&quot;&gt;Link&lt;/a&gt;&lt;a class=&quot;button is-info&quot;&gt;Info&lt;/a&gt;&lt;a class=&quot;button is-success&quot;&gt;Success&lt;/a&gt;&lt;a class=&quot;button is-warning&quot;&gt;Warning&lt;/a&gt;&lt;a class=&quot;button is-danger&quot;&gt;Danger&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;progress class=&quot;progress is-danger is-medium&quot; max=&quot;100&quot;&gt;60%&lt;/progress&gt;&lt;/div&gt;&lt;div&gt;&lt;table class=&quot;table is-hoverable&quot;&gt;&lt;tr&gt;&lt;th&gt;One&lt;/th&gt;&lt;th&gt;Two&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Three&lt;/td&gt;&lt;td&gt;Four&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Five&lt;/td&gt;&lt;td&gt;Six&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Seven&lt;/td&gt;&lt;td&gt;Eight&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Nine&lt;/td&gt;&lt;td&gt;Ten&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Eleven&lt;/td&gt;&lt;td&gt;Twelve&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="响应式布局框架-bootstrap"><a class="anchor" href="#响应式布局框架-bootstrap">#</a> 响应式布局框架 - <span class="exturl" data-url="aHR0cDovL3d3dy5ib290Y3NzLmNvbS8=">Bootstrap</span></h4><p>用于快速开发 Web 应用程序的前端框架，支持响应式布局。</p><ol><li><p>特点</p><ul><li>支持主流的浏览器和移动设备</li><li>容易上手</li><li>响应式设计</li></ul></li><li><p>内容</p><ul><li>网格系统</li><li>封装的 CSS</li><li>现成的组件</li><li>JavaScript 插件</li></ul></li><li><p>可视化</p><p><img data-src="./res/bootstrap-layoutit.png" alt="" /></p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语言进阶</title>
      <link href="/computer-science/python/basic/16-20.Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/"/>
      <url>/computer-science/python/basic/16-20.Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="python语言进阶"><a class="anchor" href="#python语言进阶">#</a> Python 语言进阶</h2><h3 id="重要知识点"><a class="anchor" href="#重要知识点">#</a> 重要知识点</h3><ul><li><p>生成式（推导式）的用法</p><pre><code class="language-Python">prices = &#123;    'AAPL': 191.88,    'GOOG': 1186.96,    'IBM': 149.24,    'ORCL': 48.44,    'ACN': 166.89,    'FB': 208.09,    'SYMC': 21.29&#125;# 用股票价格大于100元的股票构造一个新的字典prices2 = &#123;key: value for key, value in prices.items() if value &gt; 100&#125;print(prices2)</code></pre><blockquote><p>说明：生成式（推导式）可以用来生成列表、集合和字典。</p></blockquote></li><li><p>嵌套的列表的坑</p><pre><code class="language-Python">names = ['关羽', '张飞', '赵云', '马超', '黄忠']courses = ['语文', '数学', '英语']# 录入五个学生三门课程的成绩# 错误 - 参考http://pythontutor.com/visualize.html#mode=edit# scores = [[None] * len(courses)] * len(names)scores = [[None] * len(courses) for _ in range(len(names))]for row, name in enumerate(names):    for col, course in enumerate(courses):        scores[row][col] = float(input(f'请输入&#123;name&#125;的&#123;course&#125;成绩: '))        print(scores)</code></pre><p><span class="exturl" data-url="aHR0cDovL3B5dGhvbnR1dG9yLmNvbS8=">Python Tutor</span> - VISUALIZE CODE AND GET LIVE HELP</p></li><li><p><code>heapq</code>  模块（堆排序）</p><pre><code class="language-Python">&quot;&quot;&quot;从列表中找出最大的或最小的N个元素堆结构(大根堆/小根堆)&quot;&quot;&quot;import heapqlist1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]list2 = [    &#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125;,    &#123;'name': 'AAPL', 'shares': 50, 'price': 543.22&#125;,    &#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;,    &#123;'name': 'HPQ', 'shares': 35, 'price': 31.75&#125;,    &#123;'name': 'YHOO', 'shares': 45, 'price': 16.35&#125;,    &#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125;]print(heapq.nlargest(3, list1))print(heapq.nsmallest(3, list1))print(heapq.nlargest(2, list2, key=lambda x: x['price']))print(heapq.nlargest(2, list2, key=lambda x: x['shares']))</code></pre></li><li><p><code>itertools</code>  模块</p><pre><code class="language-Python">&quot;&quot;&quot;迭代工具模块&quot;&quot;&quot;import itertools# 产生ABCD的全排列itertools.permutations('ABCD')# 产生ABCDE的五选三组合itertools.combinations('ABCDE', 3)# 产生ABCD和123的笛卡尔积itertools.product('ABCD', '123')# 产生ABC的无限循环序列itertools.cycle(('A', 'B', 'C'))</code></pre></li><li><p><code>collections</code>  模块</p><p>常用的工具类：</p><ul><li><code>namedtuple</code> ：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</li><li><code>deque</code> ：双端队列，是列表的替代实现。Python 中的列表底层是基于数组来实现的，而 deque 底层是双向链表，因此当你需要在头尾添加和删除元素时，deque 会表现出更好的性能，渐近时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li><li><code>Counter</code> ： <code>dict</code>  的子类，键是元素，值是元素的计数，它的 <code>most_common()</code>  方法可以帮助我们获取出现频率最高的元素。 <code>Counter</code>  和 <code>dict</code>  的继承关系我认为是值得商榷的，按照 CARP 原则， <code>Counter</code>  跟 <code>dict</code>  的关系应该设计为关联关系更为合理。</li><li><code>OrderedDict</code> ： <code>dict</code>  的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。</li><li><code>defaultdict</code> ：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的 <code>setdefault()</code>  方法，这种做法更加高效。</li></ul><pre><code class="language-Python">&quot;&quot;&quot;找出序列中出现次数最多的元素&quot;&quot;&quot;from collections import Counterwords = [    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around',    'the', 'eyes', &quot;don't&quot;, 'look', 'around', 'the', 'eyes',    'look', 'into', 'my', 'eyes', &quot;you're&quot;, 'under']counter = Counter(words)print(counter.most_common(3))</code></pre></li></ul><h3 id="数据结构和算法"><a class="anchor" href="#数据结构和算法">#</a> 数据结构和算法</h3><ul><li><p>算法：解决问题的方法和步骤</p></li><li><p>评价算法的好坏：渐近时间复杂度和渐近空间复杂度。</p></li><li><p>渐近时间复杂度的大 O 标记：</p><ul><li>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xhdGV4LmNvZGVjb2dzLmNvbS9naWYubGF0ZXg/TyhjKQ==">http://latex.codecogs.com/gif.latex?O(c)</span>&quot; /&gt; - 常量时间复杂度 - 布隆过滤器 / 哈希存储</li><li>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xhdGV4LmNvZGVjb2dzLmNvbS9naWYubGF0ZXg/Tyhsb2dfMm4p">http://latex.codecogs.com/gif.latex?O(log_2n)</span>&quot; /&gt; - 对数时间复杂度 - 折半查找（二分查找）</li><li>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xhdGV4LmNvZGVjb2dzLmNvbS9naWYubGF0ZXg/TyhuKQ==">http://latex.codecogs.com/gif.latex?O(n)</span>&quot; /&gt; - 线性时间复杂度 - 顺序查找 / 计数排序</li><li>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xhdGV4LmNvZGVjb2dzLmNvbS9naWYubGF0ZXg/TyhuKmxvZ18ybik=">http://latex.codecogs.com/gif.latex?O(n*log_2n)</span>&quot; /&gt; - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序）</li><li>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xhdGV4LmNvZGVjb2dzLmNvbS9naWYubGF0ZXg/TyhuJTVFMik=">http://latex.codecogs.com/gif.latex?O(n^2)</span>&quot; /&gt; - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序）</li><li>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xhdGV4LmNvZGVjb2dzLmNvbS9naWYubGF0ZXg/TyhuJTVFMyk=">http://latex.codecogs.com/gif.latex?O(n^3)</span>&quot; /&gt; - 立方时间复杂度 - Floyd 算法 / 矩阵乘法运算</li><li>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xhdGV4LmNvZGVjb2dzLmNvbS9naWYubGF0ZXg/TygyJTVFbik=">http://latex.codecogs.com/gif.latex?O(2^n)</span>&quot; /&gt; - 几何级数时间复杂度 - 汉诺塔</li><li>&lt;img src=&quot;<span class="exturl" data-url="aHR0cDovL2xhdGV4LmNvZGVjb2dzLmNvbS9naWYubGF0ZXg/TyhuISk=">http://latex.codecogs.com/gif.latex?O(n!)</span>&quot; /&gt; - 阶乘时间复杂度 - 旅行经销商问题 - NPC</li></ul><p><img data-src="./res/algorithm_complexity_1.png" alt="" /></p><p><img data-src="./res/algorithm_complexity_2.png" alt="" /></p></li><li><p>排序算法（选择、冒泡和归并）和查找算法（顺序和折半）</p><pre><code class="language-Python">def select_sort(items, comp=lambda x, y: x &lt; y):    &quot;&quot;&quot;简单选择排序&quot;&quot;&quot;    items = items[:]    for i in range(len(items) - 1):        min_index = i        for j in range(i + 1, len(items)):            if comp(items[j], items[min_index]):                min_index = j        items[i], items[min_index] = items[min_index], items[i]    return items</code></pre><pre><code class="language-Python">def bubble_sort(items, comp=lambda x, y: x &gt; y):    &quot;&quot;&quot;冒泡排序&quot;&quot;&quot;    items = items[:]    for i in range(len(items) - 1):        swapped = False        for j in range(len(items) - 1 - i):            if comp(items[j], items[j + 1]):                items[j], items[j + 1] = items[j + 1], items[j]                swapped = True        if not swapped:            break    return items</code></pre><pre><code class="language-Python">def bubble_sort(items, comp=lambda x, y: x &gt; y):    &quot;&quot;&quot;搅拌排序(冒泡排序升级版)&quot;&quot;&quot;    items = items[:]    for i in range(len(items) - 1):        swapped = False        for j in range(len(items) - 1 - i):            if comp(items[j], items[j + 1]):                items[j], items[j + 1] = items[j + 1], items[j]                swapped = True        if swapped:            swapped = False            for j in range(len(items) - 2 - i, i, -1):                if comp(items[j - 1], items[j]):                    items[j], items[j - 1] = items[j - 1], items[j]                    swapped = True        if not swapped:            break    return items</code></pre><pre><code class="language-Python">def merge(items1, items2, comp=lambda x, y: x &lt; y):    &quot;&quot;&quot;合并(将两个有序的列表合并成一个有序的列表)&quot;&quot;&quot;    items = []    index1, index2 = 0, 0    while index1 &lt; len(items1) and index2 &lt; len(items2):        if comp(items1[index1], items2[index2]):            items.append(items1[index1])            index1 += 1        else:            items.append(items2[index2])            index2 += 1    items += items1[index1:]    items += items2[index2:]    return itemsdef merge_sort(items, comp=lambda x, y: x &lt; y):    return _merge_sort(list(items), comp)def _merge_sort(items, comp):    &quot;&quot;&quot;归并排序&quot;&quot;&quot;    if len(items) &lt; 2:        return items    mid = len(items) // 2    left = _merge_sort(items[:mid], comp)    right = _merge_sort(items[mid:], comp)    return merge(left, right, comp)</code></pre><pre><code class="language-Python">def seq_search(items, key):    &quot;&quot;&quot;顺序查找&quot;&quot;&quot;    for index, item in enumerate(items):        if item == key:            return index    return -1</code></pre><pre><code class="language-Python">def bin_search(items, key):    &quot;&quot;&quot;折半查找&quot;&quot;&quot;    start, end = 0, len(items) - 1    while start &lt;= end:        mid = (start + end) // 2        if key &gt; items[mid]:            start = mid + 1        elif key &lt; items[mid]:            end = mid - 1        else:            return mid    return -1</code></pre></li><li><p>常用算法：</p><ul><li>穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。</li><li>贪婪法 - 在对问题求解时，总是做出在当前看来</li><li>最好的选择，不追求最优解，快速找到满意解。</li><li>分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</li><li>回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。</li><li>动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</li></ul><p>穷举法例子：百钱百鸡和五人分鱼。</p><pre><code class="language-Python"># 公鸡5元一只 母鸡3元一只 小鸡1元三只# 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只for x in range(20):    for y in range(33):        z = 100 - x - y        if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:            print(x, y, z)# A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉# 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份# B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份# 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼fish = 6while True:    total = fish    enough = True    for _ in range(5):        if (total - 1) % 5 == 0:            total = (total - 1) // 5 * 4        else:            enough = False            break    if enough:        print(fish)        break    fish += 5</code></pre><p>贪婪法例子：假设小偷有一个背包，最多能装 20 公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">价格（美元）</th><th style="text-align:center">重量（kg）</th></tr></thead><tbody><tr><td style="text-align:center">电脑</td><td style="text-align:center">200</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">收音机</td><td style="text-align:center">20</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">钟</td><td style="text-align:center">175</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">花瓶</td><td style="text-align:center">50</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">书</td><td style="text-align:center">10</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">油画</td><td style="text-align:center">90</td><td style="text-align:center">9</td></tr></tbody></table><pre><code class="language-Python">&quot;&quot;&quot;贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。输入：20 6电脑 200 20收音机 20 4钟 175 10花瓶 50 2书 10 1油画 90 9&quot;&quot;&quot;class Thing(object):    &quot;&quot;&quot;物品&quot;&quot;&quot;    def __init__(self, name, price, weight):        self.name = name        self.price = price        self.weight = weight    @property    def value(self):        &quot;&quot;&quot;价格重量比&quot;&quot;&quot;        return self.price / self.weightdef input_thing():    &quot;&quot;&quot;输入物品信息&quot;&quot;&quot;    name_str, price_str, weight_str = input().split()    return name_str, int(price_str), int(weight_str)def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    max_weight, num_of_things = map(int, input().split())    all_things = []    for _ in range(num_of_things):        all_things.append(Thing(*input_thing()))    all_things.sort(key=lambda x: x.value, reverse=True)    total_weight = 0    total_price = 0    for thing in all_things:        if total_weight + thing.weight &lt;= max_weight:            print(f'小偷拿走了&#123;thing.name&#125;')            total_weight += thing.weight            total_price += thing.price    print(f'总价值: &#123;total_price&#125;美元')if __name__ == '__main__':    main()</code></pre><p>分治法例子：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLyVFNSVCRiVBQiVFOSU4MCU5RiVFNiU4RSU5MiVFNSVCQSU4Rg==">快速排序</span>。</p><pre><code class="language-Python">&quot;&quot;&quot;快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大&quot;&quot;&quot;def quick_sort(items, comp=lambda x, y: x &lt;= y):    items = list(items)[:]    _quick_sort(items, 0, len(items) - 1, comp)    return itemsdef _quick_sort(items, start, end, comp):    if start &lt; end:        pos = _partition(items, start, end, comp)        _quick_sort(items, start, pos - 1, comp)        _quick_sort(items, pos + 1, end, comp)def _partition(items, start, end, comp):    pivot = items[end]    i = start - 1    for j in range(start, end):        if comp(items[j], pivot):            i += 1            items[i], items[j] = items[j], items[i]    items[i + 1], items[end] = items[end], items[i + 1]    return i + 1</code></pre><p>回溯法例子：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLyVFOSVBQSU5MSVFNSVBMyVBQiVFNSVCNyVBMSVFOSU4MCVCQg==">骑士巡逻</span>。</p><pre><code class="language-Python">&quot;&quot;&quot;递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。&quot;&quot;&quot;import sysimport timeSIZE = 5total = 0def print_board(board):    for row in board:        for col in row:            print(str(col).center(4), end='')        print()def patrol(board, row, col, step=1):    if row &gt;= 0 and row &lt; SIZE and \        col &gt;= 0 and col &lt; SIZE and \        board[row][col] == 0:        board[row][col] = step        if step == SIZE * SIZE:            global total            total += 1            print(f'第&#123;total&#125;种走法: ')            print_board(board)        patrol(board, row - 2, col - 1, step + 1)        patrol(board, row - 1, col - 2, step + 1)        patrol(board, row + 1, col - 2, step + 1)        patrol(board, row + 2, col - 1, step + 1)        patrol(board, row + 2, col + 1, step + 1)        patrol(board, row + 1, col + 2, step + 1)        patrol(board, row - 1, col + 2, step + 1)        patrol(board, row - 2, col + 1, step + 1)        board[row][col] = 0def main():    board = [[0] * SIZE for _ in range(SIZE)]    patrol(board, SIZE - 1, SIZE - 1)if __name__ == '__main__':    main()</code></pre><p>动态规划例子：子列表元素之和的最大值。</p><blockquote><p>说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是 int 类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：</p><p>输入：1 -2 3 5 -3 2</p><p>输出：8</p><p>输入：0 -2 3 5 -1 2</p><p>输出：9</p><p>输入：-9 -2 -3 -5 -3</p><p>输出：-2</p></blockquote><pre><code class="language-Python">def main():    items = list(map(int, input().split()))    overall = partial = items[0]    for i in range(1, len(items)):        partial = max(items[i], partial + items[i])        overall = max(partial, overall)    print(overall)if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明</strong>：这个题目最容易想到的解法是使用二重循环，但是代码的时间性能将会变得非常的糟糕。使用动态规划的思想，仅仅是多用了两个变量，就将原来<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 复杂度的问题变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p></blockquote></li></ul><h3 id="函数的使用方式"><a class="anchor" href="#函数的使用方式">#</a> 函数的使用方式</h3><ul><li><p>将函数视为 “一等公民”</p><ul><li>函数可以赋值给变量</li><li>函数可以作为函数的参数</li><li>函数可以作为函数的返回值</li></ul></li><li><p>高阶函数的用法（ <code>filter</code> 、 <code>map</code>  以及它们的替代品）</p><pre><code class="language-Python">items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))items2 = [x ** 2 for x in range(1, 10) if x % 2]</code></pre></li><li><p>位置参数、可变参数、关键字参数、命名关键字参数</p></li><li><p>参数的元信息（代码可读性问题）</p></li><li><p>匿名函数和内联函数的用法（ <code>lambda</code>  函数）</p></li><li><p>闭包和作用域问题</p><ul><li><p>Python 搜索变量的 LEGB 顺序（Local &gt;&gt;&gt; Embedded &gt;&gt;&gt; Global &gt;&gt;&gt; Built-in）</p></li><li><p><code>global</code>  和 <code>nonlocal</code>  关键字的作用</p><p><code>global</code> ：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。</p><p><code>nonlocal</code> ：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。</p></li></ul></li><li><p>装饰器函数（使用装饰器和取消装饰器）</p><p>例子：输出函数执行时间的装饰器。</p><pre><code class="language-Python">def record_time(func):    &quot;&quot;&quot;自定义装饰函数的装饰器&quot;&quot;&quot;        @wraps(func)    def wrapper(*args, **kwargs):        start = time()        result = func(*args, **kwargs)        print(f'&#123;func.__name__&#125;: &#123;time() - start&#125;秒')        return result            return wrapper</code></pre><p>如果装饰器不希望跟 <code>print</code>  函数耦合，可以编写可以参数化的装饰器。</p><pre><code class="language-Python">from functools import wrapsfrom time import timedef record(output):    &quot;&quot;&quot;可以参数化的装饰器&quot;&quot;&quot;def decorate(func):@wraps(func)def wrapper(*args, **kwargs):start = time()result = func(*args, **kwargs)output(func.__name__, time() - start)return result            return wrapperreturn decorate</code></pre><pre><code class="language-Python">from functools import wrapsfrom time import timeclass Record():    &quot;&quot;&quot;通过定义类的方式定义装饰器&quot;&quot;&quot;    def __init__(self, output):        self.output = output    def __call__(self, func):        @wraps(func)        def wrapper(*args, **kwargs):            start = time()            result = func(*args, **kwargs)            self.output(func.__name__, time() - start)            return result        return wrapper</code></pre><blockquote><p><strong>说明</strong>：由于对带装饰功能的函数添加了 @wraps 装饰器，可以通过 <code>func.__wrapped__</code> 方式获得被装饰之前的函数或类来取消装饰器的作用。</p></blockquote><p>例子：用装饰器来实现单例模式。</p><pre><code class="language-Python">from functools import wrapsdef singleton(cls):    &quot;&quot;&quot;装饰类的装饰器&quot;&quot;&quot;    instances = &#123;&#125;    @wraps(cls)    def wrapper(*args, **kwargs):        if cls not in instances:            instances[cls] = cls(*args, **kwargs)        return instances[cls]    return wrapper@singletonclass President:    &quot;&quot;&quot;总统(单例类)&quot;&quot;&quot;    pass</code></pre><blockquote><p><strong>提示</strong>：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？</p></blockquote><p>线程安全的单例装饰器。</p><pre><code class="language-Python">from functools import wrapsfrom threading import RLockdef singleton(cls):    &quot;&quot;&quot;线程安全的单例装饰器&quot;&quot;&quot;    instances = &#123;&#125;    locker = RLock()    @wraps(cls)    def wrapper(*args, **kwargs):        if cls not in instances:            with locker:                if cls not in instances:                    instances[cls] = cls(*args, **kwargs)        return instances[cls]    return wrapper</code></pre><blockquote><p><strong>提示</strong>：上面的代码用到了 <code>with</code>  上下文语法来进行锁操作，因为锁对象本身就是上下文管理器对象（支持 <code>__enter__</code> 和 <code>__exit__</code> 魔术方法）。在 <code>wrapper</code>  函数中，我们先做了一次不带锁的检查，然后再做带锁的检查，这样做比直接加锁检查性能要更好，如果对象已经创建就没有必须再去加锁而是直接返回该对象就可以了。</p></blockquote></li></ul><h3 id="面向对象相关知识"><a class="anchor" href="#面向对象相关知识">#</a> 面向对象相关知识</h3><ul><li><p>三大支柱：封装、继承、多态</p><p>例子：工资结算系统。</p><pre><code class="language-Python">&quot;&quot;&quot;月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成&quot;&quot;&quot;from abc import ABCMeta, abstractmethodclass Employee(metaclass=ABCMeta):    &quot;&quot;&quot;员工(抽象类)&quot;&quot;&quot;    def __init__(self, name):        self.name = name    @abstractmethod    def get_salary(self):        &quot;&quot;&quot;结算月薪(抽象方法)&quot;&quot;&quot;        passclass Manager(Employee):    &quot;&quot;&quot;部门经理&quot;&quot;&quot;    def get_salary(self):        return 15000.0class Programmer(Employee):    &quot;&quot;&quot;程序员&quot;&quot;&quot;    def __init__(self, name, working_hour=0):        self.working_hour = working_hour        super().__init__(name)    def get_salary(self):        return 200.0 * self.working_hourclass Salesman(Employee):    &quot;&quot;&quot;销售员&quot;&quot;&quot;    def __init__(self, name, sales=0.0):        self.sales = sales        super().__init__(name)    def get_salary(self):        return 1800.0 + self.sales * 0.05class EmployeeFactory:    &quot;&quot;&quot;创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）&quot;&quot;&quot;    @staticmethod    def create(emp_type, *args, **kwargs):        &quot;&quot;&quot;创建员工&quot;&quot;&quot;        all_emp_types = &#123;'M': Manager, 'P': Programmer, 'S': Salesman&#125;        cls = all_emp_types[emp_type.upper()]        return cls(*args, **kwargs) if cls else Nonedef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    emps = [        EmployeeFactory.create('M', '曹操'),         EmployeeFactory.create('P', '荀彧', 120),        EmployeeFactory.create('P', '郭嘉', 85),         EmployeeFactory.create('S', '典韦', 123000),    ]    for emp in emps:        print(f'&#123;emp.name&#125;: &#123;emp.get_salary():.2f&#125;元')if __name__ == '__main__':    main()</code></pre></li><li><p>类与类之间的关系</p><ul><li>is-a 关系：继承</li><li>has-a 关系：关联 / 聚合 / 合成</li><li>use-a 关系：依赖</li></ul><p>例子：扑克游戏。</p><pre><code class="language-Python">&quot;&quot;&quot;经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择&quot;&quot;&quot;from enum import Enum, uniqueimport random@uniqueclass Suite(Enum):    &quot;&quot;&quot;花色&quot;&quot;&quot;    SPADE, HEART, CLUB, DIAMOND = range(4)    def __lt__(self, other):        return self.value &lt; other.valueclass Card:    &quot;&quot;&quot;牌&quot;&quot;&quot;    def __init__(self, suite, face):        &quot;&quot;&quot;初始化方法&quot;&quot;&quot;        self.suite = suite        self.face = face    def show(self):        &quot;&quot;&quot;显示牌面&quot;&quot;&quot;        suites = ['♠︎', '♥︎', '♣︎', '♦︎']        faces = ['', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']        return f'&#123;suites[self.suite.value]&#125;&#123;faces[self.face]&#125;'    def __repr__(self):        return self.show()class Poker:    &quot;&quot;&quot;扑克&quot;&quot;&quot;    def __init__(self):        self.index = 0        self.cards = [Card(suite, face)                      for suite in Suite                      for face in range(1, 14)]    def shuffle(self):        &quot;&quot;&quot;洗牌（随机乱序）&quot;&quot;&quot;        random.shuffle(self.cards)        self.index = 0    def deal(self):        &quot;&quot;&quot;发牌&quot;&quot;&quot;        card = self.cards[self.index]        self.index += 1        return card    @property    def has_more(self):        return self.index &lt; len(self.cards)class Player:    &quot;&quot;&quot;玩家&quot;&quot;&quot;    def __init__(self, name):        self.name = name        self.cards = []    def get_one(self, card):        &quot;&quot;&quot;摸一张牌&quot;&quot;&quot;        self.cards.append(card)    def sort(self, comp=lambda card: (card.suite, card.face)):        &quot;&quot;&quot;整理手上的牌&quot;&quot;&quot;        self.cards.sort(key=comp)def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    poker = Poker()    poker.shuffle()    players = [Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐')]    while poker.has_more:        for player in players:                player.get_one(poker.deal())    for player in players:        player.sort()        print(player.name, end=': ')        print(player.cards)if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码中使用了 Emoji 字符来表示扑克牌的四种花色，在某些不支持 Emoji 字符的系统上可能无法显示。</p></blockquote></li><li><p>对象的复制（深复制 / 深拷贝 / 深度克隆和浅复制 / 浅拷贝 / 影子克隆）</p></li><li><p>垃圾回收、循环引用和弱引用</p><p>Python 使用了自动化内存管理，这种管理机制以<strong>引用计数</strong>为基础，同时也引入了<strong>标记 - 清除</strong>和<strong>分代收集</strong>两种机制为辅的策略。</p><pre><code class="language-C">typedef struct _object &#123;    /* 引用计数 */    int ob_refcnt;    /* 对象指针 */    struct _typeobject *ob_type;&#125; PyObject;</code></pre><pre><code class="language-C">/* 增加引用计数的宏定义 */#define Py_INCREF(op)   ((op)-&gt;ob_refcnt++)/* 减少引用计数的宏定义 */#define Py_DECREF(op) \ //减少计数    if (--(op)-&gt;ob_refcnt != 0) \        ; \    else \        __Py_Dealloc((PyObject *)(op))</code></pre><p>导致引用计数 + 1 的情况：</p><ul><li>对象被创建，例如 <code>a = 23</code></li><li>对象被引用，例如 <code>b = a</code></li><li>对象被作为参数，传入到一个函数中，例如 <code>f(a)</code></li><li>对象作为一个元素，存储在容器中，例如 <code>list1 = [a, a]</code></li></ul><p>导致引用计数 - 1 的情况：</p><ul><li>对象的别名被显式销毁，例如 <code>del a</code></li><li>对象的别名被赋予新的对象，例如 <code>a = 24</code></li><li>一个对象离开它的作用域，例如 f 函数执行完毕时，f 函数中的局部变量（全局变量不会）</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ul><p>引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python 中引入了 “标记 - 清除” 和 “分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。</p><pre><code class="language-Python"># 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收# 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效# 如果不想造成循环引用可以使用弱引用list1 = []list2 = [] list1.append(list2)list2.append(list1)</code></pre><p>以下情况会导致垃圾回收：</p><ul><li>调用 <code>gc.collect()</code></li><li><code>gc</code>  模块的计数器达到阀值</li><li>程序退出</li></ul><p>如果循环引用中两个对象都定义了 <code>__del__</code> 方法， <code>gc</code>  模块不会销毁这些不可达对象，因为 gc 模块不知道应该先调用哪个对象的 <code>__del__</code> 方法，这个问题在 Python 3.6 中得到了解决。</p><p>也可以通过 <code>weakref</code>  模块构造弱引用的方式来解决循环引用的问题。</p></li><li><p>魔法属性和方法（请参考《Python 魔法方法指南》）</p><p>有几个小问题请大家思考：</p><ul><li>自定义的对象能不能使用运算符做运算？</li><li>自定义的对象能不能放到 <code>set</code>  中？能去重吗？</li><li>自定义的对象能不能作为 <code>dict</code>  的键？</li><li>自定义的对象能不能使用上下文语法？</li></ul></li><li><p>混入（Mixin）</p><p>例子：自定义字典限制只有在指定的 key 不存在时才能在字典中设置键值对。</p><pre><code class="language-Python">class SetOnceMappingMixin:    &quot;&quot;&quot;自定义混入类&quot;&quot;&quot;    __slots__ = ()    def __setitem__(self, key, value):        if key in self:            raise KeyError(str(key) + ' already set')        return super().__setitem__(key, value)class SetOnceDict(SetOnceMappingMixin, dict):    &quot;&quot;&quot;自定义字典&quot;&quot;&quot;    passmy_dict= SetOnceDict()try:    my_dict['username'] = 'jackfrued'    my_dict['username'] = 'hellokitty'except KeyError:    passprint(my_dict)</code></pre></li><li><p>元编程和元类</p><p>对象是通过类创建的，类是通过元类创建的，元类提供了创建类的元信息。所有的类都直接或间接的继承自 <code>object</code> ，所有的元类都直接或间接的继承自 <code>type</code> 。</p><p>例子：用元类实现单例模式。</p><pre><code class="language-Python">import threadingclass SingletonMeta(type):    &quot;&quot;&quot;自定义元类&quot;&quot;&quot;    def __init__(cls, *args, **kwargs):        cls.__instance = None        cls.__lock = threading.RLock()        super().__init__(*args, **kwargs)    def __call__(cls, *args, **kwargs):        if cls.__instance is None:            with cls.__lock:                if cls.__instance is None:                    cls.__instance = super().__call__(*args, **kwargs)        return cls.__instanceclass President(metaclass=SingletonMeta):    &quot;&quot;&quot;总统(单例类)&quot;&quot;&quot;        pass</code></pre></li><li><p>面向对象设计原则</p><ul><li>单一职责原则 （<strong>S</strong>RP）- 一个类只做该做的事情（类的设计要高内聚）</li><li>开闭原则 （<strong>O</strong>CP）- 软件实体应该对扩展开发对修改关闭</li><li>依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）</li><li>里氏替换原则（<strong>L</strong>SP） - 任何时候可以用子类对象替换掉父类对象</li><li>接口隔离原则（<strong>I</strong>SP）- 接口要小而专不要大而全（Python 中没有接口的概念）</li><li>合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码</li><li>最少知识原则（迪米特法则，Lo<strong>D</strong>）- 不要给没有必然联系的对象发消息</li></ul><blockquote><p><strong>说明</strong>：上面加粗的字母放在一起称为面向对象的<strong> SOLID</strong> 原则。</p></blockquote></li><li><p>GoF 设计模式</p><ul><li>创建型模式：单例、工厂、建造者、原型</li><li>结构型模式：适配器、门面（外观）、代理</li><li>行为型模式：迭代器、观察者、状态、策略</li></ul><p>例子：可插拔的哈希算法（策略模式）。</p><pre><code class="language-Python">class StreamHasher():    &quot;&quot;&quot;哈希摘要生成器&quot;&quot;&quot;    def __init__(self, alg='md5', size=4096):        self.size = size        alg = alg.lower()        self.hasher = getattr(__import__('hashlib'), alg.lower())()    def __call__(self, stream):        return self.to_digest(stream)    def to_digest(self, stream):        &quot;&quot;&quot;生成十六进制形式的摘要&quot;&quot;&quot;        for buf in iter(lambda: stream.read(self.size), b''):            self.hasher.update(buf)        return self.hasher.hexdigest()def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    hasher1 = StreamHasher()    with open('Python-3.7.6.tgz', 'rb') as stream:        print(hasher1.to_digest(stream))    hasher2 = StreamHasher('sha1')    with open('Python-3.7.6.tgz', 'rb') as stream:        print(hasher2(stream))if __name__ == '__main__':    main()</code></pre></li></ul><h3 id="迭代器和生成器"><a class="anchor" href="#迭代器和生成器">#</a> 迭代器和生成器</h3><ul><li><p>迭代器是实现了迭代器协议的对象。</p><ul><li>Python 中没有像 <code>protocol</code>  或 <code>interface</code>  这样的定义协议的关键字。</li><li>Python 中用魔术方法表示协议。</li><li><code>__iter__</code> 和 <code>__next__</code> 魔术方法就是迭代器协议。</li></ul><pre><code class="language-Python">class Fib(object):    &quot;&quot;&quot;迭代器&quot;&quot;&quot;        def __init__(self, num):        self.num = num        self.a, self.b = 0, 1        self.idx = 0       def __iter__(self):        return self    def __next__(self):        if self.idx &lt; self.num:            self.a, self.b = self.b, self.a + self.b            self.idx += 1            return self.a        raise StopIteration()</code></pre></li><li><p>生成器是语法简化版的迭代器。</p><pre><code class="language-Python">def fib(num):    &quot;&quot;&quot;生成器&quot;&quot;&quot;    a, b = 0, 1    for _ in range(num):        a, b = b, a + b        yield a</code></pre></li><li><p>生成器进化为协程。</p><p>生成器对象可以使用 <code>send()</code>  方法发送数据，发送的数据会成为生成器函数中通过 <code>yield</code>  表达式获得的值。这样，生成器就可以作为协程使用，协程简单的说就是可以相互协作的子程序。</p><pre><code class="language-Python">def calc_avg():    &quot;&quot;&quot;流式计算平均值&quot;&quot;&quot;    total, counter = 0, 0    avg_value = None    while True:        value = yield avg_value        total, counter = total + value, counter + 1        avg_value = total / countergen = calc_avg()next(gen)print(gen.send(10))print(gen.send(20))print(gen.send(30))</code></pre></li></ul><h3 id="并发编程"><a class="anchor" href="#并发编程">#</a> 并发编程</h3><p>Python 中实现并发编程的三种方案：多线程、多进程和异步 I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。</p><ul><li><p>多线程：Python 中提供了 <code>Thread</code>  类并辅以 <code>Lock</code> 、 <code>Condition</code> 、 <code>Event</code> 、 <code>Semaphore</code>  和 <code>Barrier</code> 。Python 中有 GIL 来防止多个线程同时执行本地字节码，这个锁对于 CPython 是必须的，因为 CPython 的内存管理并不是线程安全的，因为 GIL 的存在多线程并不能发挥 CPU 的多核特性。</p><pre><code class="language-Python">&quot;&quot;&quot;面试题：进程和线程的区别和联系？进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程线程 - 操作系统分配CPU的基本单位并发编程（concurrent programming）1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行2. 改善用户体验 - 让耗时间的操作不会造成程序的假死&quot;&quot;&quot;import globimport osimport threadingfrom PIL import ImagePREFIX = 'thumbnails'def generate_thumbnail(infile, size, format='PNG'):    &quot;&quot;&quot;生成指定图片文件的缩略图&quot;&quot;&quot;file, ext = os.path.splitext(infile)file = file[file.rfind('/') + 1:]outfile = f'&#123;PREFIX&#125;/&#123;file&#125;_&#123;size[0]&#125;_&#123;size[1]&#125;.&#123;ext&#125;'img = Image.open(infile)img.thumbnail(size, Image.ANTIALIAS)img.save(outfile, format)def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;if not os.path.exists(PREFIX):os.mkdir(PREFIX)for infile in glob.glob('images/*.png'):for size in (32, 64, 128):            # 创建并启动线程threading.Thread(target=generate_thumbnail, args=(infile, (size, size))).start()if __name__ == '__main__':main()</code></pre><p>多个线程竞争资源的情况。</p><pre><code class="language-Python">&quot;&quot;&quot;多线程程序如果没有竞争资源处理起来通常也比较简单当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱说明：临界资源就是被多个线程竞争的资源&quot;&quot;&quot;import timeimport threadingfrom concurrent.futures import ThreadPoolExecutorclass Account(object):    &quot;&quot;&quot;银行账户&quot;&quot;&quot;    def __init__(self):        self.balance = 0.0        self.lock = threading.Lock()    def deposit(self, money):        # 通过锁保护临界资源        with self.lock:            new_balance = self.balance + money            time.sleep(0.001)            self.balance = new_balancedef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    account = Account()    # 创建线程池    pool = ThreadPoolExecutor(max_workers=10)    futures = []    for _ in range(100):        future = pool.submit(account.deposit, 1)        futures.append(future)    # 关闭线程池    pool.shutdown()    for future in futures:        future.result()    print(account.balance)if __name__ == '__main__':    main()</code></pre><p>修改上面的程序，启动 5 个线程向账户中存钱，5 个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用 <code>threading</code>  模块的 <code>Condition</code>  来实现线程调度，该对象也是基于锁来创建的，代码如下所示：</p><pre><code class="language-Python">&quot;&quot;&quot;多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）多个线程竞争多个资源（线程数&gt;资源数） - 信号量（Semaphore）多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition&quot;&quot;&quot;from concurrent.futures import ThreadPoolExecutorfrom random import randintfrom time import sleepimport threadingclass Account:    &quot;&quot;&quot;银行账户&quot;&quot;&quot;    def __init__(self, balance=0):        self.balance = balance        lock = threading.RLock()        self.condition = threading.Condition(lock)    def withdraw(self, money):        &quot;&quot;&quot;取钱&quot;&quot;&quot;        with self.condition:            while money &gt; self.balance:                self.condition.wait()            new_balance = self.balance - money            sleep(0.001)            self.balance = new_balance    def deposit(self, money):        &quot;&quot;&quot;存钱&quot;&quot;&quot;        with self.condition:            new_balance = self.balance + money            sleep(0.001)            self.balance = new_balance            self.condition.notify_all()def add_money(account):    while True:        money = randint(5, 10)        account.deposit(money)        print(threading.current_thread().name,               ':', money, '====&gt;', account.balance)        sleep(0.5)def sub_money(account):    while True:        money = randint(10, 30)        account.withdraw(money)        print(threading.current_thread().name,               ':', money, '&lt;====', account.balance)        sleep(1)def main():    account = Account()    with ThreadPoolExecutor(max_workers=15) as pool:        for _ in range(5):            pool.submit(add_money, account)        for _ in range(10):            pool.submit(sub_money, account)if __name__ == '__main__':    main()</code></pre></li><li><p>多进程：多进程可以有效的解决 GIL 的问题，实现多进程主要的类是 <code>Process</code> ，其他辅助的类跟 <code>threading</code>  模块中的类似，进程间共享数据可以使用管道、套接字等，在 <code>multiprocessing</code>  模块中有一个 <code>Queue</code>  类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。</p><pre><code class="language-Python">&quot;&quot;&quot;多进程和进程池的使用多线程因为GIL的存在不能够发挥CPU的多核特性对于计算密集型任务应该考虑使用多进程time python3 example22.pyreal    0m11.512suser    0m39.319ssys     0m0.169s使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU&quot;&quot;&quot;import concurrent.futuresimport mathPRIMES = [    1116281,    1297337,    104395303,    472882027,    533000389,    817504243,    982451653,    112272535095293,    112582705942171,    112272535095293,    115280095190773,    115797848077099,    1099726899285419] * 5def is_prime(n):    &quot;&quot;&quot;判断素数&quot;&quot;&quot;    if n % 2 == 0:        return False    sqrt_n = int(math.floor(math.sqrt(n)))    for i in range(3, sqrt_n + 1, 2):        if n % i == 0:            return False    return Truedef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    with concurrent.futures.ProcessPoolExecutor() as executor:        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):            print('%d is prime: %s' % (number, prime))if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>重点</strong>：<strong>多线程和多进程的比较</strong>。</p><p>以下情况需要使用多线程：</p><ol><li>程序需要维护许多共享的状态（尤其是可变状态），Python 中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。</li><li>程序会花费大量时间在 I/O 操作上，没有太多并行计算的需求且不需占用太多的内存。</li></ol><p>以下情况需要使用多进程：</p><ol><li>程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。</li><li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li><li>程序在内存使用方面没有任何限制且不强依赖于 I/O 操作（如：读写文件、套接字等）。</li></ol></blockquote></li><li><p>异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将 CPU 处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者 <code>future</code>  对象来获取任务执行的结果。Python 3 通过 <code>asyncio</code>  模块和 <code>await</code>  和 <code>async</code>  关键字（在 Python 3.7 中正式被列为关键字）来支持异步处理。</p><pre><code class="language-Python">&quot;&quot;&quot;异步I/O - async / await&quot;&quot;&quot;import asynciodef num_generator(m, n):    &quot;&quot;&quot;指定范围的数字生成器&quot;&quot;&quot;    yield from range(m, n + 1)async def prime_filter(m, n):    &quot;&quot;&quot;素数过滤器&quot;&quot;&quot;    primes = []    for i in num_generator(m, n):        flag = True        for j in range(2, int(i ** 0.5 + 1)):            if i % j == 0:                flag = False                break        if flag:            print('Prime =&gt;', i)            primes.append(i)        await asyncio.sleep(0.001)    return tuple(primes)async def square_mapper(m, n):    &quot;&quot;&quot;平方映射器&quot;&quot;&quot;    squares = []    for i in num_generator(m, n):        print('Square =&gt;', i * i)        squares.append(i * i)        await asyncio.sleep(0.001)    return squaresdef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    loop = asyncio.get_event_loop()    future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100))    future.add_done_callback(lambda x: print(x.result()))    loop.run_until_complete(future)    loop.close()if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码使用 <code>get_event_loop</code>  函数获得系统默认的事件循环，通过 <code>gather</code>  函数可以获得一个 <code>future</code>  对象， <code>future</code>  对象的 <code>add_done_callback</code>  可以添加执行完成时的回调函数， <code>loop</code>  对象的 <code>run_until_complete</code>  方法可以等待通过 <code>future</code>  对象获得协程执行结果。</p></blockquote><p>Python 中有一个名为 <code>aiohttp</code>  的三方库，它提供了异步的 HTTP 客户端和服务器，这个三方库可以跟 <code>asyncio</code>  模块一起工作，并提供了对 <code>Future</code>  对象的支持。Python 3.6 中引入了 <code>async</code>  和 <code>await</code>  来定义异步执行的函数以及创建异步上下文，在 Python 3.7 中它们正式成为了关键字。下面的代码异步的从 5 个 URL 中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p><pre><code class="language-Python">import asyncioimport reimport aiohttpPATTERN = re.compile(r'\&lt;title\&gt;(?P&lt;title&gt;.*)\&lt;\/title\&gt;')async def fetch_page(session, url):    async with session.get(url, ssl=False) as resp:        return await resp.text()async def show_title(url):    async with aiohttp.ClientSession() as session:        html = await fetch_page(session, url)        print(PATTERN.search(html).group('title'))def main():    urls = ('https://www.python.org/',            'https://git-scm.com/',            'https://www.jd.com/',            'https://www.taobao.com/',            'https://www.douban.com/')    loop = asyncio.get_event_loop()    cos = [show_title(url) for url in urls]    loop.run_until_complete(asyncio.wait(cos))    loop.close()if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>重点</strong>：<strong>异步 I/O 与多进程的比较</strong>。</p><p>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时， <code>asyncio</code>  就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑 <code>asyncio</code> ，它很适合编写没有实时数据处理需求的 Web 应用服务器。</p></blockquote><p>Python 还有很多用于处理并行任务的三方库，例如： <code>joblib</code> 、 <code>PyMP</code>  等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的 Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是 AMQP（高级消息队列协议），AMQP 源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache 的 ActiveMQ、RabbitMQ 等。</p><p>要实现任务的异步化，可以使用名为 <code>Celery</code>  的三方库。 <code>Celery</code>  是 Python 编写的分布式任务队列，它使用分布式消息进行工作，可以基于 RabbitMQ 或 Redis 来作为后端的消息代理。</p></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像和办公文档处理</title>
      <link href="/computer-science/python/basic/15.%E5%9B%BE%E5%83%8F%E5%92%8C%E5%8A%9E%E5%85%AC%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86/"/>
      <url>/computer-science/python/basic/15.%E5%9B%BE%E5%83%8F%E5%92%8C%E5%8A%9E%E5%85%AC%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="图像和办公文档处理"><a class="anchor" href="#图像和办公文档处理">#</a> 图像和办公文档处理</h2><p>用程序来处理图像和办公文档经常出现在实际开发中，Python 的标准库中虽然没有直接支持这些操作的模块，但我们可以通过 Python 生态圈中的第三方模块来完成这些操作。</p><h3 id="操作图像"><a class="anchor" href="#操作图像">#</a> 操作图像</h3><h4 id="计算机图像相关知识"><a class="anchor" href="#计算机图像相关知识">#</a> 计算机图像相关知识</h4><ol><li><p>颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个 RGB 值或 RGBA 值（其中的 A 表示 Alpha 通道，它决定了透过这个图像的像素，也就是透明度）。</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">RGBA 值</th><th style="text-align:center">名称</th><th style="text-align:center">RGBA 值</th></tr></thead><tbody><tr><td style="text-align:center">White</td><td style="text-align:center">(255, 255, 255, 255)</td><td style="text-align:center">Red</td><td style="text-align:center">(255, 0, 0, 255)</td></tr><tr><td style="text-align:center">Green</td><td style="text-align:center">(0, 255, 0, 255)</td><td style="text-align:center">Blue</td><td style="text-align:center">(0, 0, 255, 255)</td></tr><tr><td style="text-align:center">Gray</td><td style="text-align:center">(128, 128, 128, 255)</td><td style="text-align:center">Yellow</td><td style="text-align:center">(255, 255, 0, 255)</td></tr><tr><td style="text-align:center">Black</td><td style="text-align:center">(0, 0, 0, 255)</td><td style="text-align:center">Purple</td><td style="text-align:center">(128, 0, 128, 255)</td></tr></tbody></table></li><li><p>像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。</p></li></ol><h4 id="用pillow操作图像"><a class="anchor" href="#用pillow操作图像">#</a> 用 Pillow 操作图像</h4><p>Pillow 是由从著名的 Python 图像处理库 PIL 发展出来的一个分支，通过 Pillow 可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装 Pillow。</p><pre><code class="language-Shell">pip install pillow</code></pre><p>Pillow 中最为重要的是 Image 类，读取和处理图像都要通过这个类来完成。</p><pre><code class="language-Python">&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt;&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; image.format, image.size, image.mode('JPEG', (500, 750), 'RGB')&gt;&gt;&gt; image.show()</code></pre><p><img data-src="./res/image-show.png" alt="" /></p><ol><li><p>剪裁图像</p><pre><code class="language-Python">&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; rect = 80, 20, 310, 360&gt;&gt;&gt; image.crop(rect).show()</code></pre><p><img data-src="./res/image-crop.png" alt="" /></p></li><li><p>生成缩略图</p><pre><code class="language-Python">&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; size = 128, 128&gt;&gt;&gt; image.thumbnail(size)&gt;&gt;&gt; image.show()</code></pre><p><img data-src="./res/image-thumbnail.png" alt="" /></p></li><li><p>缩放和黏贴图像</p><pre><code class="language-Python">&gt;&gt;&gt; image1 = Image.open('./res/luohao.png')&gt;&gt;&gt; image2 = Image.open('./res/guido.jpg')&gt;&gt;&gt; rect = 80, 20, 310, 360&gt;&gt;&gt; guido_head = image2.crop(rect)&gt;&gt;&gt; width, height = guido_head.size&gt;&gt;&gt; image1.paste(guido_head.resize((int(width / 1.5), int(height / 1.5))), (172, 40))</code></pre><p><img data-src="./res/image-paste.png" alt="" /></p></li><li><p>旋转和翻转</p><pre><code class="language-Python">&gt;&gt;&gt; image = Image.open('./res/guido.png')&gt;&gt;&gt; image.rotate(180).show()&gt;&gt;&gt; image.transpose(Image.FLIP_LEFT_RIGHT).show()</code></pre><p><img data-src="./res/image-rotate.png" alt="" /></p><p><img data-src="./res/image-transpose.png" alt="" /></p></li><li><p>操作像素</p><pre><code class="language-Python">&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; for x in range(80, 310):...     for y in range(20, 360):...         image.putpixel((x, y), (128, 128, 128))... &gt;&gt;&gt; image.show()</code></pre><p><img data-src="./res/image-putpixel.png" alt="" /></p></li><li><p>滤镜效果</p><pre><code class="language-Python">&gt;&gt;&gt; from PIL import Image, ImageFilter&gt;&gt;&gt;&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; image.filter(ImageFilter.CONTOUR).show()</code></pre><p><img data-src="./res/image-filter.png" alt="" /></p></li></ol><h3 id="处理excel电子表格"><a class="anchor" href="#处理excel电子表格">#</a> 处理 Excel 电子表格</h3><p>Python 的 openpyxl 模块让我们可以在 Python 程序中读取和修改 Excel 电子表格，由于微软从 Office 2007 开始使用了新的文件格式，这使得 Office Excel 和 LibreOffice Calc、OpenOffice Calc 是完全兼容的，这就意味着 openpyxl 模块也能处理来自这些软件生成的电子表格。</p><pre><code class="language-Python">import datetimefrom openpyxl import Workbookwb = Workbook()ws = wb.activews['A1'] = 42ws.append([1, 2, 3])ws['A2'] = datetime.datetime.now()wb.save(&quot;sample.xlsx&quot;)</code></pre><h3 id="处理word文档"><a class="anchor" href="#处理word文档">#</a> 处理 Word 文档</h3><p>利用 python-docx 模块，Python 可以创建和修改 Word 文档，当然这里的 Word 文档不仅仅是指通过微软的 Office 软件创建的扩展名为 docx 的文档，LibreOffice Writer 和 OpenOffice Writer 都是免费的字处理软件。</p><pre><code class="language-Python">from docx import Documentfrom docx.shared import Inchesdocument = Document()document.add_heading('Document Title', 0)p = document.add_paragraph('A plain paragraph having some ')p.add_run('bold').bold = Truep.add_run(' and some ')p.add_run('italic.').italic = Truedocument.add_heading('Heading, level 1', level=1)document.add_paragraph('Intense quote', style='Intense Quote')document.add_paragraph(    'first item in unordered list', style='List Bullet')document.add_paragraph(    'first item in ordered list', style='List Number')document.add_picture('monty-truth.png', width=Inches(1.25))records = (    (3, '101', 'Spam'),    (7, '422', 'Eggs'),    (4, '631', 'Spam, spam, eggs, and spam'))table = document.add_table(rows=1, cols=3)hdr_cells = table.rows[0].cellshdr_cells[0].text = 'Qty'hdr_cells[1].text = 'Id'hdr_cells[2].text = 'Desc'for qty, id, desc in records:    row_cells = table.add_row().cells    row_cells[0].text = str(qty)    row_cells[1].text = id    row_cells[2].text = descdocument.add_page_break()document.save('demo.docx')</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程入门</title>
      <link href="/computer-science/python/basic/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
      <url>/computer-science/python/basic/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a class="anchor" href="#">#</a> </h2><h3 id="计算机网络基础"><a class="anchor" href="#计算机网络基础">#</a> 计算机网络基础</h3><p>计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个 “复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读 Andrew S.Tanenbaum 老师的经典之作《计算机网络》或 Kurose 和 Ross 老师合著的《计算机网络：自顶向下方法》来了解计算机网络的相关知识。</p><h4 id="计算机网络发展史"><a class="anchor" href="#计算机网络发展史">#</a> 计算机网络发展史</h4><ol><li><p>1960s - 美国国防部 ARPANET 项目问世，奠定了分组交换网络的基础。</p><p><img data-src="./res/arpanet.png" alt="" /></p></li><li><p>1980s - 国际标准化组织（ISO）发布 OSI/RM，奠定了网络技术标准化的基础。</p><p><img data-src="./res/osimodel.png" alt="" /></p></li><li><p>1990s - 英国人<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JThGJTkwJUU1JUE3JTg2JUMyJUI3JUU2JTlGJThGJUU1JTg1JUE3JUU4JThDJUIyLSVFNiU5RCU4RQ==">蒂姆・伯纳斯 - 李</span>发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。</p><p>在没有浏览器的年代，上网是这样的。</p><p><img data-src="./res/before-browser.jpg" alt="" /></p><p>有了浏览器以后，上网是这样的。</p><p><img data-src="./res/after-browser.jpg" alt="" /></p></li></ol><h4 id="tcpip模型"><a class="anchor" href="#tcpip模型">#</a> TCP/IP 模型</h4><p>实现网络通信的基础是网络通信协议，这些协议通常是由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJTkyJUU4JTgxJTk0JUU3JUJEJTkxJUU1JUI3JUE1JUU3JUE4JThCJUU0JUJCJUJCJUU1JThBJUExJUU3JUJCJTg0">互联网工程任务组</span> （IETF）制定的。所谓 “协议” 就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的 Internet 的基础的是 TCP/IP 协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为 TCP/IP 模型。与国际标准化组织发布的 OSI/RM 这个七层模型不同，TCP/IP 是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。</p><p><img data-src="./res/TCP-IP-model.png" alt="" /></p><p>IP 通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的 IP 地址，IP 地址就是主机在计算机网络上的身份标识。当然由于 IPv4 地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的 IP 地址并不是全球唯一的 IP 地址，而是一个<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvJUU1JUIxJTgwJUU1JTlGJTlGJUU3JUJEJTkx">局域网（LAN）</span>中的内部 IP 地址，通过<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJEJTkxJUU3JUJCJTlDJUU1JTlDJUIwJUU1JTlEJTgwJUU4JUJEJUFDJUU2JThEJUEy">网络地址转换（NAT）服务</span>我们也可以实现对网络的访问。计算机网络上有大量的被我们称为 “<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUFGJUU3JTk0JUIxJUU1JTk5JUE4">路由器</span>” 的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。</p><p>TCP 全称传输控制协议，它是基于 IP 提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将 TCP 称为可靠的传输协议是因为 TCP 向调用者承诺了三件事情：</p><ol><li>数据不传丢不传错（利用握手、校验和重传机制可以实现）。</li><li>流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。</li><li>拥塞控制（通过 RTT 时间以及对滑动窗口的控制缓解网络拥堵）。</li></ol><h4 id="网络应用模式"><a class="anchor" href="#网络应用模式">#</a> 网络应用模式</h4><ol><li>C/S 模式和 B/S 模式。这里的 C 指的是 Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而 B 指的是 Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过 C 或 B 都可以实现对 S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。</li><li>去中心化的网络应用模式。不管是 B/S 还是 C/S 都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。</li></ol><h3 id="基于http协议的网络资源访问"><a class="anchor" href="#基于http协议的网络资源访问">#</a> 基于 HTTP 协议的网络资源访问</h3><h4 id="http超文本传输协议"><a class="anchor" href="#http超文本传输协议">#</a> HTTP（超文本传输协议）</h4><p>HTTP 是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对 HTTP 的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUE4JUU3JTkwJTgzJUU4JUIzJTg3JUU4JUE4JThBJUU3JUI2JUIy">万维网</span>数据通信的基础，设计 HTTP 最初的目的是为了提供一种发布和接收<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFRNTA=="> HTML</span> 页面的方法，通过 HTTP 或者<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI2JTg1JUU2JTk2JTg3JUU2JTlDJUFDJUU0JUJDJUEwJUU4JUJFJTkzJUU1JUFFJTg5JUU1JTg1JUE4JUU1JThEJThGJUU4JUFFJUFF"> HTTPS</span>（超文本传输安全协议）请求的资源由 URI（<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI1JUIxJUU0JUI4JTgwJUU4JUIzJTg3JUU2JUJBJTkwJUU2JUE4JTk5JUU4JUFEJTk4JUU3JUFDJUE2">统一资源标识符</span>）来标识。关于 HTTP 的更多内容，我们推荐阅读阮一峰老师的<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDgvaHR0cC5odG1s">《HTTP 协议入门》</span>，简单的说，通过 HTTP 我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络 API（有的地方也称之为网络数据接口）就是基于 HTTP 来实现数据传输的。</p><h4 id="json格式"><a class="anchor" href="#json格式">#</a> JSON 格式</h4><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管 JSON 是最初只是 Javascript 中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持 JSON 格式数据的生成和解析，Python 内置的 json 模块也提供了这方面的功能。由于 JSON 是纯文本，它和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvWE1M"> XML</span> 一样都适用于异构系统之间的数据交换，而相较于 XML，JSON 显得更加的轻便和优雅。下面是表达同样信息的 XML 和 JSON，而 JSON 的优势是相当直观的。</p><p>XML 的例子：</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;message&gt;&lt;from&gt;Alice&lt;/from&gt;&lt;to&gt;Bob&lt;/to&gt;&lt;content&gt;Will you marry me?&lt;/content&gt;&lt;/message&gt;</code></pre><p>JSON 的例子：</p><pre><code class="language-JSON">&#123;    &quot;from&quot;: &quot;Alice&quot;,    &quot;to&quot;: &quot;Bob&quot;,    &quot;content&quot;: &quot;Will you marry me?&quot;&#125;</code></pre><h4 id="requests库"><a class="anchor" href="#requests库">#</a> requests 库</h4><p>requests 是一个基于 HTTP 协议来使用网络的第三库，其<span class="exturl" data-url="aHR0cDovL2NuLnB5dGhvbi1yZXF1ZXN0cy5vcmcvemhfQ04vbGF0ZXN0Lw==">官方网站</span>有这样的一句介绍它的话：“Requests 是唯一的一个<strong>非转基因</strong>的 Python HTTP 库，人类可以安全享用。” 简单的说，使用 requests 库可以非常方便的使用 HTTP，避免安全缺陷、冗余代码以及 “重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过 requests 来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了<span class="exturl" data-url="aHR0cHM6Ly93d3cudGlhbmFwaS5jb20v">天行数据</span>提供的网络 API。</p><p>我们可以先通过 pip 安装 requests 及其依赖库。</p><pre><code class="language-Shell">pip install requests</code></pre><p>如果使用 PyCharm 作为开发工具，可以直接在代码中书写 <code>import requests</code> ，然后通过代码修复功能来自动下载安装 requests。</p><pre><code class="language-Python">from time import timefrom threading import Threadimport requests# 继承Thread类创建自定义的线程类class DownloadHanlder(Thread):    def __init__(self, url):        super().__init__()        self.url = url    def run(self):        filename = self.url[self.url.rfind('/') + 1:]        resp = requests.get(self.url)        with open('/Users/Hao/' + filename, 'wb') as f:            f.write(resp.content)def main():    # 通过requests模块的get函数获取网络资源    # 下面的代码中使用了天行数据接口提供的网络API    # 要使用该数据接口需要在天行数据的网站上注册    # 然后用自己的Key替换掉下面代码的中APIKey即可    resp = requests.get(        'http://api.tianapi.com/meinv/?key=APIKey&amp;num=10')    # 将服务器返回的JSON格式的数据解析为字典    data_model = resp.json()    for mm_dict in data_model['newslist']:        url = mm_dict['picUrl']        # 通过多线程的方式实现图片下载        DownloadHanlder(url).start()if __name__ == '__main__':    main()</code></pre><h3 id="基于传输层协议的套接字编程"><a class="anchor" href="#基于传输层协议的套接字编程">#</a> 基于传输层协议的套接字编程</h3><p>套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQyVFOCVBRiVBRCVFOCVBOCU4MA=="> C 语言</span>写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在 Python 中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP 套接字）、数据报套接字和原始套接字。</p><h4 id="tcp套接字"><a class="anchor" href="#tcp套接字">#</a> TCP 套接字</h4><p>所谓 TCP 套接字就是使用 TCP 协议提供的传输服务来实现网络通信的编程接口。在 Python 中可以通过创建 socket 对象并指定 type 属性为 SOCK_STREAM 来使用 TCP 套接字。由于一台主机可能拥有多个 IP 地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的 IP 地址和端口上。这里的端口并不是物理设备而是对 IP 地址的扩展，用于区分不同的服务，例如我们通常将 HTTP 服务跟 80 端口绑定，而 MySQL 数据库服务默认绑定在 3306 端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是 HTTP 服务器还是数据库服务器提供的服务。端口的取值范围是 0~65535，而 1024 以下的端口我们通常称之为 “著名端口”（留给像 FTP、HTTP、SMTP 等 “著名服务” 使用的端口，有的地方也称之为 “周知端口”），自定义的服务通常不使用这些端口，除非自定义的是 HTTP 或 FTP 这样的著名服务。</p><p>下面的代码实现了一个提供时间日期的服务器。</p><pre><code class="language-Python">from socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimedef main():    # 1.创建套接字对象并指定使用哪种传输服务    # family=AF_INET - IPv4地址    # family=AF_INET6 - IPv6地址    # type=SOCK_STREAM - TCP套接字    # type=SOCK_DGRAM - UDP套接字    # type=SOCK_RAW - 原始套接字    server = socket(family=AF_INET, type=SOCK_STREAM)    # 2.绑定IP地址和端口(端口用于区分不同的服务)    # 同一时间在同一个端口上只能绑定一个服务否则报错    server.bind(('192.168.1.2', 6789))    # 3.开启监听 - 监听客户端连接到服务器    # 参数512可以理解为连接队列的大小    server.listen(512)    print('服务器启动开始监听...')    while True:        # 4.通过循环接收客户端的连接并作出相应的处理(提供服务)        # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行        # accept方法返回一个元组其中的第一个元素是客户端对象        # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)        client, addr = server.accept()        print(str(addr) + '连接到了服务器.')        # 5.发送数据        client.send(str(datetime.now()).encode('utf-8'))        # 6.断开连接        client.close()if __name__ == '__main__':    main()</code></pre><p>运行服务器程序后我们可以通过 Windows 系统的 telnet 来访问该服务器，结果如下图所示。</p><pre><code class="language-Shell">telnet 192.168.1.2 6789</code></pre><p><img data-src="./res/telnet.png" alt="" /></p><p>当然我们也可以通过 Python 的程序来实现 TCP 客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。</p><pre><code class="language-Python">from socket import socketdef main():    # 1.创建套接字对象默认使用IPv4和TCP协议    client = socket()    # 2.连接到服务器(需要指定IP地址和端口)    client.connect(('192.168.1.2', 6789))    # 3.从服务器接收数据    print(client.recv(1024).decode('utf-8'))    client.close()if __name__ == '__main__':    main()</code></pre><p>需要注意的是，上面的服务器并没有使用多线程或者异步 I/O 的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。</p><p>服务器端代码：</p><pre><code class="language-Python">from socket import socket, SOCK_STREAM, AF_INETfrom base64 import b64encodefrom json import dumpsfrom threading import Threaddef main():        # 自定义线程类    class FileTransferHandler(Thread):        def __init__(self, cclient):            super().__init__()            self.cclient = cclient        def run(self):            my_dict = &#123;&#125;            my_dict['filename'] = 'guido.jpg'            # JSON是纯文本不能携带二进制数据            # 所以图片的二进制数据要处理成base64编码            my_dict['filedata'] = data            # 通过dumps函数将字典处理成JSON字符串            json_str = dumps(my_dict)            # 发送JSON字符串            self.cclient.send(json_str.encode('utf-8'))            self.cclient.close()    # 1.创建套接字对象并指定使用哪种传输服务    server = socket()    # 2.绑定IP地址和端口(区分不同的服务)    server.bind(('192.168.1.2', 5566))    # 3.开启监听 - 监听客户端连接到服务器    server.listen(512)    print('服务器启动开始监听...')    with open('guido.jpg', 'rb') as f:        # 将二进制数据处理成base64再解码成字符串        data = b64encode(f.read()).decode('utf-8')    while True:        client, addr = server.accept()        # 启动一个线程来处理客户端的请求        FileTransferHandler(client).start()if __name__ == '__main__':    main()</code></pre><p>客户端代码：</p><pre><code class="language-Python">from socket import socketfrom json import loadsfrom base64 import b64decodedef main():    client = socket()    client.connect(('192.168.1.2', 5566))    # 定义一个保存二进制数据的对象    in_data = bytes()    # 由于不知道服务器发送的数据有多大每次接收1024字节    data = client.recv(1024)    while data:        # 将收到的数据拼接起来        in_data += data        data = client.recv(1024)    # 将收到的二进制数据解码成JSON字符串并转换成字典    # loads函数的作用就是将JSON字符串转成字典对象    my_dict = loads(in_data.decode('utf-8'))    filename = my_dict['filename']    filedata = my_dict['filedata'].encode('utf-8')    with open('/Users/Hao/' + filename, 'wb') as f:        # 将base64格式的数据解码成二进制数据并写入文件        f.write(b64decode(filedata))    print('图片已保存.')if __name__ == '__main__':    main()</code></pre><p>在这个案例中，我们使用了 JSON 作为数据传输的格式（通过 JSON 格式对传输的数据进行了序列化和反序列化的操作），但是 JSON 并不能携带二进制数据，因此对图片的二进制数据进行了 Base64 编码的处理。Base64 是一种用 64 个字符表示所有二进制数据的编码方式，通过将二进制数据每 6 位一组的方式重新组织，刚好可以使用 0~9 的数字、大小写字母以及 “+” 和 “/” 总共 64 个字符表示从 <code>000000</code>  到 <code>111111</code>  的 64 种状态。<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0">维基百科</span>上有关于 Base64 编码的详细讲解，不熟悉 Base64 的读者可以自行阅读。</p><blockquote><p><strong>说明：</strong> 上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。</p></blockquote><h4 id="udp套接字"><a class="anchor" href="#udp套接字">#</a> UDP 套接字</h4><p>传输层除了有可靠的传输协议 TCP 之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称 UDP。TCP 和 UDP 都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了 TCP 中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP 可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在 Python 中也可以使用 UDP 套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。</p><h3 id="网络应用开发"><a class="anchor" href="#网络应用开发">#</a> 网络应用开发</h3><h4 id="发送电子邮件"><a class="anchor" href="#发送电子邮件">#</a> 发送电子邮件</h4><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p><p>就像我们可以用 HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用 SMTP（简单邮件传输协议），SMTP 也是一个建立在 TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而 Python 中的 smtplib 模块将这些操作简化成了几个简单的函数。</p><p>下面的代码演示了如何在 Python 发送邮件。</p><pre><code class="language-Python">from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextdef main():    # 请自行修改下面的邮件发送者和接收者    sender = 'abcdefg@126.com'    receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com']    message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8')    message['From'] = Header('王大锤', 'utf-8')    message['To'] = Header('骆昊', 'utf-8')    message['Subject'] = Header('示例代码实验邮件', 'utf-8')    smtper = SMTP('smtp.126.com')    # 请自行修改下面的登录口令    smtper.login(sender, 'secretpass')    smtper.sendmail(sender, receivers, message.as_string())    print('邮件发送完成!')if __name__ == '__main__':    main()</code></pre><p>如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。</p><pre><code class="language-Python">from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartimport urllibdef main():    # 创建一个带附件的邮件消息对象    message = MIMEMultipart()        # 创建文本内容    text_content = MIMEText('附件中有本月数据请查收', 'plain', 'utf-8')    message['Subject'] = Header('本月数据', 'utf-8')    # 将文本内容添加到邮件消息对象中    message.attach(text_content)    # 读取文件并将文件作为附件添加到邮件消息对象中    with open('/Users/Hao/Desktop/hello.txt', 'rb') as f:        txt = MIMEText(f.read(), 'base64', 'utf-8')        txt['Content-Type'] = 'text/plain'        txt['Content-Disposition'] = 'attachment; filename=hello.txt'        message.attach(txt)    # 读取文件并将文件作为附件添加到邮件消息对象中    with open('/Users/Hao/Desktop/汇总数据.xlsx', 'rb') as f:        xls = MIMEText(f.read(), 'base64', 'utf-8')        xls['Content-Type'] = 'application/vnd.ms-excel'        xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx'        message.attach(xls)        # 创建SMTP对象    smtper = SMTP('smtp.126.com')    # 开启安全连接    # smtper.starttls()    sender = 'abcdefg@126.com'    receivers = ['uvwxyz@qq.com']    # 登录到SMTP服务器    # 请注意此处不是使用密码而是邮件客户端授权码进行登录    # 对此有疑问的读者可以联系自己使用的邮件服务器客服    smtper.login(sender, 'secretpass')    # 发送邮件    smtper.sendmail(sender, receivers, message.as_string())    # 与邮件服务器断开连接    smtper.quit()    print('发送完成!')if __name__ == '__main__':    main()</code></pre><h4 id="发送短信"><a class="anchor" href="#发送短信">#</a> 发送短信</h4><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了<span class="exturl" data-url="aHR0cDovL3d3dy5paHV5aS5jb20v">互亿无线</span>短信平台（该平台为注册用户提供了 50 条免费短信以及常用开发语言发送短信的 demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的 API 接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p><pre><code class="language-Python">import urllib.parseimport http.clientimport jsondef main():    host  = &quot;106.ihuyi.com&quot;    sms_send_uri = &quot;/webservice/sms.php?method=Submit&quot;    # 下面的参数需要填入自己注册的账号和对应的密码    params = urllib.parse.urlencode(&#123;'account': '你自己的账号', 'password' : '你自己的密码', 'content': '您的验证码是：147258。请不要把验证码泄露给其他人。', 'mobile': '接收者的手机号', 'format':'json' &#125;)    print(params)    headers = &#123;'Content-type': 'application/x-www-form-urlencoded', 'Accept': 'text/plain'&#125;    conn = http.client.HTTPConnection(host, port=80, timeout=30)    conn.request('POST', sms_send_uri, params, headers)    response = conn.getresponse()    response_str = response.read()    jsonstr = response_str.decode('utf-8')    print(json.loads(jsonstr))    conn.close()if __name__ == '__main__':    main()</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="/computer-science/python/basic/13.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/computer-science/python/basic/13.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和线程"><a class="anchor" href="#进程和线程">#</a> 进程和线程</h2><p>今天我们使用的计算机早已进入多 CPU 或多核时代，而我们使用的操作系统都是支持 “多任务” 的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的 “并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。</p><h3 id="概念"><a class="anchor" href="#概念">#</a> 概念</h3><p>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过 fork 或 spawn 的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。</p><p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得 CPU 调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核 CPU 系统中，真正的并发是不可能的，因为在某个时刻能够获得 CPU 的只有唯一的一个线程，多个线程共享了 CPU 的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如 macOS 中的 “活动监视器”、Windows 中的 “任务管理器”）来证实，如下图所示。</p><p><img data-src="./res/macos-monitor.png" alt="" /></p><p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的 CPU 执行时间，导致其他程序无法获得足够的 CPU 执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。</p><p>Python 既支持多进程又支持多线程，因此使用 Python 实现并发编程主要有 3 种方式：多进程、多线程、多进程 + 多线程。</p><h3 id="python中的多进程"><a class="anchor" href="#python中的多进程">#</a> Python 中的多进程</h3><p>Unix 和 Linux 操作系统上提供了 <code>fork()</code>  系统调用来创建进程，调用 <code>fork()</code>  函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的 PID。 <code>fork()</code>  函数非常特殊它会返回两次，父进程中可以通过 <code>fork()</code>  函数的返回值得到子进程的 PID，而子进程中的返回值永远都是 0。Python 的 os 模块提供了 <code>fork()</code>  函数。由于 Windows 系统没有 <code>fork()</code>  调用，因此要实现跨平台的多进程编程，可以使用 multiprocessing 模块的 <code>Process</code>  类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（ <code>Pool</code> ）、用于进程间通信的队列（ <code>Queue</code> ）和管道（ <code>Pipe</code> ）等。</p><p>下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。</p><pre><code class="language-Python">from random import randintfrom time import time, sleepdef download_task(filename):    print('开始下载%s...' % filename)    time_to_download = randint(5, 10)    sleep(time_to_download)    print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main():    start = time()    download_task('Python从入门到住院.pdf')    download_task('Peking Hot.avi')    end = time()    print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__':    main()</code></pre><p>下面是运行程序得到的一次运行结果。</p><pre><code class="language-Shell">开始下载Python从入门到住院.pdf...Python从入门到住院.pdf下载完成! 耗费了6秒开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒总共耗费了13.01秒.</code></pre><p>从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。</p><pre><code class="language-Python">from multiprocessing import Processfrom os import getpidfrom random import randintfrom time import time, sleepdef download_task(filename):    print('启动下载进程，进程号[%d].' % getpid())    print('开始下载%s...' % filename)    time_to_download = randint(5, 10)    sleep(time_to_download)    print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main():    start = time()    p1 = Process(target=download_task, args=('Python从入门到住院.pdf', ))    p1.start()    p2 = Process(target=download_task, args=('Peking Hot.avi', ))    p2.start()    p1.join()    p2.join()    end = time()    print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__':    main()</code></pre><p>在上面的代码中，我们通过 <code>Process</code>  类创建了进程对象，通过 <code>target</code>  参数我们传入一个函数来表示进程启动后要执行的代码，后面的 <code>args</code>  是一个元组，它代表了传递给函数的参数。 <code>Process</code>  对象的 <code>start</code>  方法用来启动进程，而 <code>join</code>  方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务 “同时” 启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。</p><pre><code class="language-Shell">启动下载进程，进程号[1530].开始下载Python从入门到住院.pdf...启动下载进程，进程号[1531].开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒Python从入门到住院.pdf下载完成! 耗费了10秒总共耗费了10.01秒.</code></pre><p>我们也可以使用 subprocess 模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出 Ping，一个输出 Pong，两个进程输出的 Ping 和 Pong 加起来一共 10 个。听起来很简单吧，但是如果这样写可是错的哦。</p><pre><code class="language-Python">from multiprocessing import Processfrom time import sleepcounter = 0def sub_task(string):    global counter    while counter &lt; 10:        print(string, end='', flush=True)        counter += 1        sleep(0.01)        def main():    Process(target=sub_task, args=('Ping', )).start()    Process(target=sub_task, args=('Pong', )).start()if __name__ == '__main__':    main()</code></pre><p>看起来没毛病，但是最后的结果是 Ping 和 Pong 各输出了 10 个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个 <code>counter</code>  变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用 multiprocessing 模块中的 <code>Queue</code>  类，它是可以被多个进程共享的队列，底层是通过管道和<a href="">信号量（semaphore）</a>机制来实现的，有兴趣的读者可以自己尝试一下。</p><h3 id="python中的多线程"><a class="anchor" href="#python中的多线程">#</a> Python 中的多线程</h3><p>在 Python 早期的版本中就引入了 thread 模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用 threading 模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。</p><pre><code class="language-Python">from random import randintfrom threading import Threadfrom time import time, sleepdef download(filename):    print('开始下载%s...' % filename)    time_to_download = randint(5, 10)    sleep(time_to_download)    print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main():    start = time()    t1 = Thread(target=download, args=('Python从入门到住院.pdf',))    t1.start()    t2 = Thread(target=download, args=('Peking Hot.avi',))    t2.start()    t1.join()    t2.join()    end = time()    print('总共耗费了%.3f秒' % (end - start))if __name__ == '__main__':    main()</code></pre><p>我们可以直接使用 threading 模块的 <code>Thread</code>  类来创建线程，但是我们之前讲过一个非常重要的概念叫 “继承”，我们可以从已有的类创建新类，因此也可以通过继承 <code>Thread</code>  类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。</p><pre><code class="language-Python">from random import randintfrom threading import Threadfrom time import time, sleepclass DownloadTask(Thread):    def __init__(self, filename):        super().__init__()        self._filename = filename    def run(self):        print('开始下载%s...' % self._filename)        time_to_download = randint(5, 10)        sleep(time_to_download)        print('%s下载完成! 耗费了%d秒' % (self._filename, time_to_download))def main():    start = time()    t1 = DownloadTask('Python从入门到住院.pdf')    t1.start()    t2 = DownloadTask('Peking Hot.avi')    t2.start()    t1.join()    t2.join()    end = time()    print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__':    main()</code></pre><p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为 “资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为 “临界资源”，对 “临界资源” 的访问需要加上保护，否则资源会处于 “混乱” 的状态。下面的例子演示了 100 个线程向同一个银行账户转账（转入 1 元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。</p><pre><code class="language-Python">from time import sleepfrom threading import Threadclass Account(object):    def __init__(self):        self._balance = 0    def deposit(self, money):        # 计算存款后的余额        new_balance = self._balance + money        # 模拟受理存款业务需要0.01秒的时间        sleep(0.01)        # 修改账户余额        self._balance = new_balance    @property    def balance(self):        return self._balanceclass AddMoneyThread(Thread):    def __init__(self, account, money):        super().__init__()        self._account = account        self._money = money    def run(self):        self._account.deposit(self._money)def main():    account = Account()    threads = []    # 创建100个存款的线程向同一个账户中存钱    for _ in range(100):        t = AddMoneyThread(account, 1)        threads.append(t)        t.start()    # 等所有存款的线程都执行完毕    for t in threads:        t.join()    print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__':    main()</code></pre><p>运行上面的程序，结果让人大跌眼镜，100 个线程分别向账户中转入 1 元钱，结果居然远远小于 100 元。之所以出现这种情况是因为我们没有对银行账户这个 “临界资源” 加以保护，多个线程同时向账户中存钱时，会一起执行到 <code>new_balance = self._balance + money</code>  这行代码，多个线程得到的账户余额都是初始状态下的 <code>0</code> ，所以都是 <code>0</code>  上面做了 + 1 的操作，因此得到了错误的结果。在这种情况下，“锁” 就可以派上用场了。我们可以通过 “锁” 来保护 “临界资源”，只有获得 “锁” 的线程才能访问 “临界资源”，而其他没有得到 “锁” 的线程只能被阻塞起来，直到获得 “锁” 的线程释放了 “锁”，其他线程才有机会获得 “锁”，进而访问被保护的 “临界资源”。下面的代码演示了如何使用 “锁” 来保护对银行账户的操作，从而获得正确的结果。</p><pre><code class="language-Python">from time import sleepfrom threading import Thread, Lockclass Account(object):    def __init__(self):        self._balance = 0        self._lock = Lock()    def deposit(self, money):        # 先获取锁才能执行后续的代码        self._lock.acquire()        try:            new_balance = self._balance + money            sleep(0.01)            self._balance = new_balance        finally:            # 在finally中执行释放锁的操作保证正常异常锁都能释放            self._lock.release()    @property    def balance(self):        return self._balanceclass AddMoneyThread(Thread):    def __init__(self, account, money):        super().__init__()        self._account = account        self._money = money    def run(self):        self._account.deposit(self._money)def main():    account = Account()    threads = []    for _ in range(100):        t = AddMoneyThread(account, 1)        threads.append(t)        t.start()    for t in threads:        t.join()    print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__':    main()</code></pre><p>比较遗憾的一件事情是 Python 的多线程并不能发挥 CPU 的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为 Python 的解释器有一个 “全局解释器锁”（GIL）的东西，任何线程执行前必须先获得 GIL 锁，然后每执行 100 条字节码，解释器就自动释放 GIL 锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。</p><h3 id="多进程还是多线程"><a class="anchor" href="#多进程还是多线程">#</a> 多进程还是多线程</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这 5 科的作业，每项作业耗时 1 小时。如果你先花 1 小时做语文作业，做完了，再花 1 小时做数学作业，这样，依次全部做完，一共花 5 小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做 1 分钟语文，再切换到数学作业，做 1 分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核 CPU 执行多任务是一样的了，以旁观者的角度来看，你就正在同时写 5 科作业。</p><p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU 寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p><p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和 I/O 密集型。计算密集型任务的特点是要进行大量的计算，消耗 CPU 资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠 CPU 的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU 执行任务的效率就越低。计算密集型任务由于主要消耗 CPU 资源，这类任务用 Python 这样的脚本语言去执行效率通常很低，最能胜任这类任务的是 C 语言，我们之前提到过 Python 中有嵌入 C/C++ 代码的机制。</p><p>除了计算密集型任务，其他的涉及到网络、存储介质 I/O 的任务都可以视为 I/O 密集型任务，这类任务的特点是 CPU 消耗很少，任务的大部分时间都在等待 I/O 操作完成（因为 I/O 的速度远远低于 CPU 和内存的速度）。对于 I/O 密集型任务，如果启动多任务，就可以减少 I/O 等待时间从而让 CPU 高效率的运转。有一大类的任务都属于 I/O 密集型任务，这其中包括了我们很快会涉及到的网络应用和 Web 应用。</p><blockquote><p><strong>说明：</strong> 上面的内容和例子来自于<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDMxNjA4OTU1NzI2NGE2YjM0ODk1OGY0NDk5NDlkZjQyYTZkM2EyZTU0MmMwMDA=">廖雪峰官方网站的《Python 教程》</span>，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。</p></blockquote><h3 id="单线程异步io"><a class="anchor" href="#单线程异步io">#</a> 单线程 + 异步 I/O</h3><p>现代操作系统对 I/O 操作的改进中最为重要的就是支持异步 I/O。如果充分利用操作系统提供的异步 I/O 支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx 就是支持异步 I/O 的 Web 服务器，它在单核 CPU 上采用单进程模型就可以高效地支持多任务。在多核 CPU 上，可以运行多个进程（数量与 CPU 核心数相同），充分利用多核 CPU。用 Node.js 开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。</p><p>在 Python 语言中，单线程 + 异步 I/O 的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用 CPU 的多核特性，最简单的方法是多进程 + 协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。</p><h3 id="应用案例"><a class="anchor" href="#应用案例">#</a> 应用案例</h3><h4 id="例子1将耗时间的任务放到线程中以获得更好的用户体验"><a class="anchor" href="#例子1将耗时间的任务放到线程中以获得更好的用户体验">#</a> 例子 1：将耗时间的任务放到线程中以获得更好的用户体验。</h4><p>如下所示的界面中，有 “下载” 和 “关于” 两个按钮，用休眠的方式模拟点击 “下载” 按钮会联网下载文件需要耗费 10 秒的时间，如果不使用 “多线程”，我们会发现，当点击 “下载” 按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。</p><pre><code class="language-Python">import timeimport tkinterimport tkinter.messageboxdef download():    # 模拟下载任务需要花费10秒钟时间    time.sleep(10)    tkinter.messagebox.showinfo('提示', '下载完成!')def show_about():    tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)')def main():    top = tkinter.Tk()    top.title('单线程')    top.geometry('200x150')    top.wm_attributes('-topmost', True)    panel = tkinter.Frame(top)    button1 = tkinter.Button(panel, text='下载', command=download)    button1.pack(side='left')    button2 = tkinter.Button(panel, text='关于', command=show_about)    button2.pack(side='right')    panel.pack(side='bottom')    tkinter.mainloop()if __name__ == '__main__':    main()</code></pre><p>如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。</p><pre><code class="language-Python">import timeimport tkinterimport tkinter.messageboxfrom threading import Threaddef main():    class DownloadTaskHandler(Thread):        def run(self):            time.sleep(10)            tkinter.messagebox.showinfo('提示', '下载完成!')            # 启用下载按钮            button1.config(state=tkinter.NORMAL)    def download():        # 禁用下载按钮        button1.config(state=tkinter.DISABLED)        # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行)        # 在线程中处理耗时间的下载任务        DownloadTaskHandler(daemon=True).start()    def show_about():        tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)')    top = tkinter.Tk()    top.title('单线程')    top.geometry('200x150')    top.wm_attributes('-topmost', 1)    panel = tkinter.Frame(top)    button1 = tkinter.Button(panel, text='下载', command=download)    button1.pack(side='left')    button2 = tkinter.Button(panel, text='关于', command=show_about)    button2.pack(side='right')    panel.pack(side='bottom')    tkinter.mainloop()if __name__ == '__main__':    main()</code></pre><h4 id="例子2使用多进程对复杂任务进行分而治之"><a class="anchor" href="#例子2使用多进程对复杂任务进行分而治之">#</a> 例子 2：使用多进程对复杂任务进行 “分而治之”。</h4><p>我们来完成 1~100000000 求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。</p><pre><code class="language-Python">from time import timedef main():    total = 0    number_list = [x for x in range(1, 100000001)]    start = time()    for number in number_list:        total += number    print(total)    end = time()    print('Execution time: %.3fs' % (end - start))if __name__ == '__main__':    main()</code></pre><p>在上面的代码中，我故意先去创建了一个列表容器然后填入了 100000000 个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到 8 个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。</p><pre><code class="language-Python">from multiprocessing import Process, Queuefrom random import randintfrom time import timedef task_handler(curr_list, result_queue):    total = 0    for number in curr_list:        total += number    result_queue.put(total)def main():    processes = []    number_list = [x for x in range(1, 100000001)]    result_queue = Queue()    index = 0    # 启动8个进程将数据切片后进行运算    for _ in range(8):        p = Process(target=task_handler,                    args=(number_list[index:index + 12500000], result_queue))        index += 12500000        processes.append(p)        p.start()    # 开始记录所有进程执行完成花费的时间    start = time()    for p in processes:        p.join()    # 合并执行结果    total = 0    while not result_queue.empty():        total += result_queue.get()    print(total)    end = time()    print('Execution time: ', (end - start), 's', sep='')if __name__ == '__main__':    main()</code></pre><p>比较两段代码的执行结果（在我目前使用的 MacBook 上，上面的代码需要大概 6 秒左右的时间，而下面的代码只需要不到 1 秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的 CPU 执行时间以及更好的利用了 CPU 的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过 <code>multiprocessing.managers</code>  模块中提供的管理器将 <code>Queue</code>  对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用正则表达式</title>
      <link href="/computer-science/python/basic/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/computer-science/python/basic/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="使用正则表达式"><a class="anchor" href="#使用正则表达式">#</a> 使用正则表达式</h2><h3 id="正则表达式相关知识"><a class="anchor" href="#正则表达式相关知识">#</a> 正则表达式相关知识</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在 Windows 操作系统中使用过文件查找并且在指定文件名时使用过通配符（* 和？），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以 0 开头，后面跟着 2-3 个数字，然后是一个连字号 “-”，最后是 7 或 8 位数字的字符串（像 028-12345678 或 0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python 通过标准库中的 re 模块来支持正则表达式操作。</p><p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是 11 位的数字（注意并不是随机的 11 位数字，因为你没有见过 “25012345678” 这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p><p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<span class="exturl" data-url="aHR0cHM6Ly9kZWVyY2hhby5uZXQvdHV0b3JpYWxzL3JlZ2V4L3JlZ2V4Lmh0bQ==">《正则表达式 30 分钟入门教程》</span>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p><table><thead><tr><th>符号</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符</td><td>b.t</td><td>可以匹配 bat /but/b#t /b1t 等</td></tr><tr><td>\w</td><td>匹配字母 / 数字 / 下划线</td><td>b\wt</td><td>可以匹配 bat /b1t /b_t 等 &lt;br&gt; 但不能匹配 b#t</td></tr><tr><td>\s</td><td>匹配空白字符（包括 \r、\n、\t 等）</td><td>love\syou</td><td>可以匹配 love you</td></tr><tr><td>\d</td><td>匹配数字</td><td>\d\d</td><td>可以匹配 01 / 23 / 99 等</td></tr><tr><td>\b</td><td>匹配单词的边界</td><td>\bThe\b</td><td></td></tr><tr><td>^</td><td>匹配字符串的开始</td><td>^The</td><td>可以匹配 The 开头的字符串</td></tr><tr><td>$</td><td>匹配字符串的结束</td><td>.exe$</td><td>可以匹配.exe 结尾的字符串</td></tr><tr><td>\W</td><td>匹配非字母 / 数字 / 下划线</td><td>b\Wt</td><td>可以匹配 b#t /b@t 等 &lt;br&gt; 但不能匹配 but /b1t /b_t 等</td></tr><tr><td>\S</td><td>匹配非空白字符</td><td>love\Syou</td><td>可以匹配 love#you 等 &lt;br&gt; 但不能匹配 love you</td></tr><tr><td>\D</td><td>匹配非数字</td><td>\d\D</td><td>可以匹配 9a / 3# / 0F 等</td></tr><tr><td>\B</td><td>匹配非单词边界</td><td>\Bio\B</td><td></td></tr><tr><td>[]</td><td>匹配来自字符集的任意单一字符</td><td>[aeiou]</td><td>可以匹配任一元音字母字符</td></tr><tr><td>[^]</td><td>匹配不在字符集中的任意单一字符</td><td>[^aeiou]</td><td>可以匹配任一非元音字母字符</td></tr><tr><td>*</td><td>匹配 0 次或多次</td><td>\w*</td><td></td></tr><tr><td>+</td><td>匹配 1 次或多次</td><td>\w+</td><td></td></tr><tr><td>?</td><td>匹配 0 次或 1 次</td><td>\w?</td><td></td></tr><tr><td N=""></td><td>匹配 N 次</td><td 3="">\w</td><td></td></tr><tr><td M,=""></td><td>匹配至少 M 次</td><td 3,="">\w</td><td></td></tr><tr><td M,N=""></td><td>匹配至少 M 次至多 N 次</td><td 3,6="">\w</td><td></td></tr><tr><td>|</td><td>分支</td><td>foo|bar</td><td>可以匹配 foo 或者 bar</td></tr><tr><td>(?#)</td><td>注释</td><td></td><td></td></tr><tr><td>(exp)</td><td>匹配 exp 并捕获到自动命名的组中</td><td></td><td></td></tr><tr><td>(?&lt;name&gt;exp)</td><td>匹配 exp 并捕获到名为 name 的组中</td><td></td><td></td></tr><tr><td>(?:exp)</td><td>匹配 exp 但是不捕获匹配的文本</td><td></td><td></td></tr><tr><td>(?=exp)</td><td>匹配 exp 前面的位置</td><td>\b\w+(?=ing)</td><td>可以匹配 I'm dancing 中的 danc</td></tr><tr><td>(?&lt;=exp)</td><td>匹配 exp 后面的位置</td><td>(?&lt;=\bdanc)\w+\b</td><td>可以匹配 I love dancing and reading 中的第一个 ing</td></tr><tr><td>(?!exp)</td><td>匹配后面不是 exp 的位置</td><td></td><td></td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是 exp 的位置</td><td></td><td></td></tr><tr><td>*?</td><td>重复任意次，但尽可能少重复</td><td>a.*b&lt;br&gt;a.*?b</td><td>将正则表达式应用于 aabab，前者会匹配整个字符串 aabab，后者会匹配 aab 和 ab 两个字符串</td></tr><tr><td>+?</td><td>重复 1 次或多次，但尽可能少重复</td><td></td><td></td></tr><tr><td>??</td><td>重复 0 次或 1 次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,N}?</td><td>重复 M 到 N 次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,}?</td><td>重复 M 次以上，但尽可能少重复</td><td></td><td></td></tr></tbody></table><blockquote><p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用 \ 进行转义处理，例如想匹配小数点可以写成 \. 就可以了，因为直接写。会匹配任意字符；同理，想匹配圆括号必须写成 \(和 \)，否则圆括号被视为正则表达式中的分组。</p></blockquote><h3 id="python对正则表达式的支持"><a class="anchor" href="#python对正则表达式的支持">#</a> Python 对正则表达式的支持</h3><p>Python 提供了 re 模块来支持正则表达式相关操作，下面是 re 模块中的核心函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>compile(pattern, flags=0)</td><td>编译正则表达式返回正则表达式对象</td></tr><tr><td>match(pattern, string, flags=0)</td><td>用正则表达式匹配字符串 成功返回匹配对象 否则返回 None</td></tr><tr><td>search(pattern, string, flags=0)</td><td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回 None</td></tr><tr><td>split(pattern, string, maxsplit=0, flags=0)</td><td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td></tr><tr><td>sub(pattern, repl, string, count=0, flags=0)</td><td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用 count 指定替换的次数</td></tr><tr><td>fullmatch(pattern, string, flags=0)</td><td>match 函数的完全匹配（从字符串开头到结尾）版本</td></tr><tr><td>findall(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td></tr><tr><td>finditer(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td></tr><tr><td>purge()</td><td>清除隐式编译的正则表达式的缓存</td></tr><tr><td>re.I / re.IGNORECASE</td><td>忽略大小写匹配标记</td></tr><tr><td>re.M / re.MULTILINE</td><td>多行匹配标记</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 上面提到的 re 模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过 compile 函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p></blockquote><p>下面我们通过一系列的例子来告诉大家在 Python 中如何使用正则表达式。</p><h4 id="例子1验证输入用户名和qq号是否有效并给出对应的提示信息"><a class="anchor" href="#例子1验证输入用户名和qq号是否有效并给出对应的提示信息">#</a> 例子 1：验证输入用户名和 QQ 号是否有效并给出对应的提示信息。</h4><pre><code class="language-Python">&quot;&quot;&quot;验证输入用户名和QQ号是否有效并给出对应的提示信息要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0&quot;&quot;&quot;import redef main():    username = input('请输入用户名: ')    qq = input('请输入QQ号: ')    # match函数的第一个参数是正则表达式字符串或正则表达式对象    # 第二个参数是要跟正则表达式做匹配的字符串对象    m1 = re.match(r'^[0-9a-zA-Z_]&#123;6,20&#125;$', username)    if not m1:        print('请输入有效的用户名.')    m2 = re.match(r'^[1-9]\d&#123;4,11&#125;$', qq)    if not m2:        print('请输入有效的QQ号.')    if m1 and m2:        print('你输入的信息是有效的!')if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>提示：</strong> 上面在书写正则表达式时使用了 “原始字符串” 的写法（在字符串前面加上了 r），所谓 “原始字符串” 就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作 \\，例如表示数字的 \d 得书写成 \\d，这样不仅写起来不方便，阅读的时候也会很吃力。</p></blockquote><h4 id="例子2从一段文字中提取出国内手机号码"><a class="anchor" href="#例子2从一段文字中提取出国内手机号码">#</a> 例子 2：从一段文字中提取出国内手机号码。</h4><p>下面这张图是截止到 2017 年底，国内三家运营商推出的手机号段。</p><p><img data-src="./res/tel-start-number.png" alt="" /></p><pre><code class="language-Python">import redef main():    # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字    pattern = re.compile(r'(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)')    sentence = '''    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，    不是15600998765，也是110或119，王大锤的手机号才是15600998765。    '''    # 查找所有匹配并保存到一个列表中    mylist = re.findall(pattern, sentence)    print(mylist)    print('--------华丽的分隔线--------')    # 通过迭代器取出匹配对象并获得匹配的内容    for temp in pattern.finditer(sentence):        print(temp.group())    print('--------华丽的分隔线--------')    # 通过search函数指定搜索位置找出所有匹配    m = pattern.search(sentence)    while m:        print(m.group())        m = pattern.search(sentence, m.end())if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明：</strong> 上面匹配国内手机号的正则表达式并不够好，因为像 14 开头的号码只有 145 或 147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是： <code>(?&lt;=\D)(1[38]\d&#123;9&#125;|14[57]\d&#123;8&#125;|15[0-35-9]\d&#123;8&#125;|17[678]\d&#123;8&#125;)(?=\D)</code> ，国内最近好像有 19 和 16 开头的手机号了，但是这个暂时不在我们考虑之列。</p></blockquote><h4 id="例子3替换字符串中的不良内容"><a class="anchor" href="#例子3替换字符串中的不良内容">#</a> 例子 3：替换字符串中的不良内容</h4><pre><code class="language-Python">import redef main():    sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.'    purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔',                      '*', sentence, flags=re.IGNORECASE)    print(purified)  # 你丫是*吗? 我*你大爷的. * you.if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明：</strong> re 模块的正则表达式相关函数中都有一个 flags 参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为 flags 参数指定多个值，可以使用<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL3B5dGhvbi9weXRob24tb3BlcmF0b3JzLmh0bWwjeXNmNQ==">按位或运算符</span>进行叠加，如 <code>flags=re.I | re.M</code> 。</p></blockquote><h4 id="例子4拆分长字符串"><a class="anchor" href="#例子4拆分长字符串">#</a> 例子 4：拆分长字符串</h4><pre><code class="language-Python">import redef main():    poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。'    sentence_list = re.split(r'[，。, .]', poem)    while '' in sentence_list:        sentence_list.remove('')    print(sentence_list)  # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']if __name__ == '__main__':    main()</code></pre><h3 id="后话"><a class="anchor" href="#后话">#</a> 后话</h3><p>如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3J1bW15LmNvbS9zb2Z0d2FyZS9CZWF1dGlmdWxTb3VwLw=="> Beautiful Soup</span> 或<span class="exturl" data-url="aHR0cDovL2x4bWwuZGUv"> Lxml</span> 来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件和异常</title>
      <link href="/computer-science/python/basic/11.%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
      <url>/computer-science/python/basic/11.%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="文件和异常"><a class="anchor" href="#文件和异常">#</a> 文件和异常</h2><p>实际开发中常常会遇到对数据进行<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTYlOEMlODElRTQlQjklODUlRTUlOEMlOTY=">持久化</span>操作的场景，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到 “文件” 这个词，可能需要先科普一下关于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk2JTg3JUU0JUJCJUI2JUU3JUIzJUJCJUU3JUJCJTlG">文件系统</span>的知识，但是这里我们并不浪费笔墨介绍这个概念，请大家自行通过维基百科进行了解。</p><p>在 Python 中实现文件的读写操作其实非常简单，通过 Python 内置的 <code>open</code>  函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。</p><table><thead><tr><th>操作模式</th><th>具体含义</th></tr></thead><tbody><tr><td><code>'r'</code></td><td>读取 （默认）</td></tr><tr><td><code>'w'</code></td><td>写入（会先截断之前的内容）</td></tr><tr><td><code>'x'</code></td><td>写入，如果文件已经存在会产生异常</td></tr><tr><td><code>'a'</code></td><td>追加，将内容写入到已有文件的末尾</td></tr><tr><td><code>'b'</code></td><td>二进制模式</td></tr><tr><td><code>'t'</code></td><td>文本模式（默认）</td></tr><tr><td><code>'+'</code></td><td>更新（既可以读又可以写）</td></tr></tbody></table><p>下面这张图来自于<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29t">菜鸟教程</span>网站，它展示了如果根据应用程序的需要来设置操作模式。</p><p><img data-src="./res/file-open-mode.png" alt="" /></p><h3 id="读写文本文件"><a class="anchor" href="#读写文本文件">#</a> 读写文本文件</h3><p>读取文本文件时，需要在使用 <code>open</code>  函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为 <code>'r'</code> （如果不指定，默认值也是 <code>'r'</code> ），然后通过 <code>encoding</code>  参数指定编码（如果不指定，默认值是 None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与 encoding 参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。</p><pre><code class="language-Python">def main():    f = open('致橡树.txt', 'r', encoding='utf-8')    print(f.read())    f.close()if __name__ == '__main__':    main()</code></pre><p>请注意上面的代码，如果 <code>open</code>  函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用 Python 的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。</p><pre><code class="language-Python">def main():    f = None    try:        f = open('致橡树.txt', 'r', encoding='utf-8')        print(f.read())    except FileNotFoundError:        print('无法打开指定的文件!')    except LookupError:        print('指定了未知的编码!')    except UnicodeDecodeError:        print('读取文件时解码错误!')    finally:        if f:            f.close()if __name__ == '__main__':    main()</code></pre><p>在 Python 中，我们可以将那些在运行时可能会出现状况的代码放在 <code>try</code>  代码块中，在 <code>try</code>  代码块的后面可以跟上一个或多个 <code>except</code>  来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发 <code>FileNotFoundError</code> ，指定了未知的编码会引发 <code>LookupError</code> ，而如果读取文件时无法按指定方式解码会引发 <code>UnicodeDecodeError</code> ，我们在 <code>try</code>  后面跟上了三个 <code>except</code>  分别处理这三种不同的异常状况。最后我们使用 <code>finally</code>  代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于 <code>finally</code>  块的代码不论程序正常还是异常都会执行到（甚至是调用了 <code>sys</code>  模块的 <code>exit</code>  函数退出 Python 环境， <code>finally</code>  块都会被执行，因为 <code>exit</code>  函数实质上是引发了 <code>SystemExit</code>  异常），因此我们通常把 <code>finally</code>  块称为 “总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在 <code>finally</code>  代码块中关闭文件对象释放资源，也可以使用上下文语法，通过 <code>with</code>  关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。</p><pre><code class="language-Python">def main():    try:        with open('致橡树.txt', 'r', encoding='utf-8') as f:            print(f.read())    except FileNotFoundError:        print('无法打开指定的文件!')    except LookupError:        print('指定了未知的编码!')    except UnicodeDecodeError:        print('读取文件时解码错误!')if __name__ == '__main__':    main()</code></pre><p>除了使用文件对象的 <code>read</code>  方法读取文件之外，还可以使用 <code>for-in</code>  循环逐行读取或者用 <code>readlines</code>  方法将文件按行读取到一个列表容器中，代码如下所示。</p><pre><code class="language-Python">import timedef main():    # 一次性读取整个文件内容    with open('致橡树.txt', 'r', encoding='utf-8') as f:        print(f.read())    # 通过for-in循环逐行读取    with open('致橡树.txt', mode='r') as f:        for line in f:            print(line, end='')            time.sleep(0.5)    print()    # 读取文件按行读取到列表中    with open('致橡树.txt') as f:        lines = f.readlines()    print(lines)    if __name__ == '__main__':    main()</code></pre><p>要将文本信息写入文件文件也非常简单，在使用 <code>open</code>  函数时指定好文件名并将文件模式设置为 <code>'w'</code>  即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为 <code>'a'</code> 。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将 1-9999 之间的素数分别写入三个文件中（1-99 之间的素数保存在 a.txt 中，100-999 之间的素数保存在 b.txt 中，1000-9999 之间的素数保存在 c.txt 中）。</p><pre><code class="language-Python">from math import sqrtdef is_prime(n):    &quot;&quot;&quot;判断素数的函数&quot;&quot;&quot;    assert n &gt; 0    for factor in range(2, int(sqrt(n)) + 1):        if n % factor == 0:            return False    return True if n != 1 else Falsedef main():    filenames = ('a.txt', 'b.txt', 'c.txt')    fs_list = []    try:        for filename in filenames:            fs_list.append(open(filename, 'w', encoding='utf-8'))        for number in range(1, 10000):            if is_prime(number):                if number &lt; 100:                    fs_list[0].write(str(number) + '\n')                elif number &lt; 1000:                    fs_list[1].write(str(number) + '\n')                else:                    fs_list[2].write(str(number) + '\n')    except IOError as ex:        print(ex)        print('写文件时发生错误!')    finally:        for fs in fs_list:            fs.close()    print('操作完成!')if __name__ == '__main__':    main()</code></pre><h3 id="读写二进制文件"><a class="anchor" href="#读写二进制文件">#</a> 读写二进制文件</h3><p>知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。</p><pre><code class="language-Python">def main():    try:        with open('guido.jpg', 'rb') as fs1:            data = fs1.read()            print(type(data))  # &lt;class 'bytes'&gt;        with open('吉多.jpg', 'wb') as fs2:            fs2.write(data)    except FileNotFoundError as e:        print('指定的文件无法打开.')    except IOError as e:        print('读写文件时出现错误.')    print('程序执行结束.')if __name__ == '__main__':    main()</code></pre><h3 id="读写json文件"><a class="anchor" href="#读写json文件">#</a> 读写 JSON 文件</h3><p>通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以 JSON 格式进行保存。JSON 是 “JavaScript Object Notation” 的缩写，它本来是 JavaScript 语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为 JSON 也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前 JSON 基本上已经取代了 XML 作为异构系统间交换数据的事实标准。关于 JSON 的知识，更多的可以参考<span class="exturl" data-url="aHR0cDovL2pzb24ub3Jn"> JSON 的官方网站</span>，从这个网站也可以了解到每种语言处理 JSON 数据格式可以使用的工具或三方库，下面是一个 JSON 的简单例子。</p><pre><code class="language-JSON">&#123;    &quot;name&quot;: &quot;骆昊&quot;,    &quot;age&quot;: 38,    &quot;qq&quot;: 957658,    &quot;friends&quot;: [&quot;王大锤&quot;, &quot;白元芳&quot;],    &quot;cars&quot;: [        &#123;&quot;brand&quot;: &quot;BYD&quot;, &quot;max_speed&quot;: 180&#125;,        &#123;&quot;brand&quot;: &quot;Audi&quot;, &quot;max_speed&quot;: 280&#125;,        &#123;&quot;brand&quot;: &quot;Benz&quot;, &quot;max_speed&quot;: 320&#125;    ]&#125;</code></pre><p>可能大家已经注意到了，上面的 JSON 跟 Python 中的字典其实是一样一样的，事实上 JSON 的数据类型和 Python 的数据类型是很容易找到对应关系的，如下面两张表所示。</p><table><thead><tr><th>JSON</th><th>Python</th></tr></thead><tbody><tr><td>object</td><td>dict</td></tr><tr><td>array</td><td>list</td></tr><tr><td>string</td><td>str</td></tr><tr><td>number (int / real)</td><td>int / float</td></tr><tr><td>true / false</td><td>True / False</td></tr><tr><td>null</td><td>None</td></tr></tbody><tbody><tr><td>Python</td><td>JSON</td></tr><tr><td>--------------------------------------</td><td>------------</td></tr><tr><td>dict</td><td>object</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>str</td><td>string</td></tr><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True / False</td><td>true / false</td></tr><tr><td>None</td><td>null</td></tr></tbody></table><p>我们使用 Python 中的 json 模块就可以将字典或列表以 JSON 格式保存到文件中，代码如下所示。</p><pre><code class="language-Python">import jsondef main():    mydict = &#123;        'name': '骆昊',        'age': 38,        'qq': 957658,        'friends': ['王大锤', '白元芳'],        'cars': [            &#123;'brand': 'BYD', 'max_speed': 180&#125;,            &#123;'brand': 'Audi', 'max_speed': 280&#125;,            &#123;'brand': 'Benz', 'max_speed': 320&#125;        ]    &#125;    try:        with open('data.json', 'w', encoding='utf-8') as fs:            json.dump(mydict, fs)    except IOError as e:        print(e)    print('保存数据完成!')if __name__ == '__main__':    main()</code></pre><p>json 模块主要有四个比较重要的函数，分别是：</p><ul><li><code>dump</code>  - 将 Python 对象按照 JSON 格式序列化到文件中</li><li><code>dumps</code>  - 将 Python 对象处理成 JSON 格式的字符串</li><li><code>load</code>  - 将文件中的 JSON 数据反序列化成对象</li><li><code>loads</code>  - 将字符串的内容反序列化成 Python 对象</li></ul><p>这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnLw==">维基百科</span>上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。</p><p>目前绝大多数网络数据服务（或称之为网络 API）都是基于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI2JTg1JUU2JTk2JTg3JUU2JTlDJUFDJUU0JUJDJUEwJUU4JUJFJTkzJUU1JThEJThGJUU4JUFFJUFF"> HTTP 协议</span>提供 JSON 格式的数据，关于 HTTP 协议的相关知识，可以看看阮一峰老师的<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDgvaHR0cC5odG1s">《HTTP 协议入门》</span>，如果想了解国内的网络数据服务，可以看看<span class="exturl" data-url="aHR0cHM6Ly93d3cuanVoZS5jbi8=">聚合数据</span>和<span class="exturl" data-url="aHR0cDovL3d3dy5hdmF0YXJkYXRhLmNuLw==">阿凡达数据</span>等网站，国外的可以看看<span class="exturl" data-url="aHR0cDovL2FwaXMuaW8v"> {API} Search</span> 网站。下面的例子演示了如何使用<span class="exturl" data-url="aHR0cDovL2RvY3MucHl0aG9uLXJlcXVlc3RzLm9yZy96aF9DTi9sYXRlc3Qv"> requests</span> 模块（封装得足够好的第三方网络访问模块）访问网络 API 获取国内新闻，如何通过 json 模块解析 JSON 数据并显示新闻标题，这个例子使用了<span class="exturl" data-url="aHR0cHM6Ly93d3cudGlhbmFwaS5jb20v">天行数据</span>提供的国内新闻数据接口，其中的 APIKey 需要自己到该网站申请。</p><pre><code class="language-Python">import requestsimport jsondef main():    resp = requests.get('http://api.tianapi.com/guonei/?key=APIKey&amp;num=10')    data_model = json.loads(resp.text)    for news in data_model['newslist']:        print(news['title'])if __name__ == '__main__':    main()</code></pre><p>在 Python 中要实现序列化和反序列化除了使用 json 模块之外，还可以使用 pickle 和 shelve 模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被 Python 识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于 Python 异常机制的知识，可以看看 segmentfault 上面的文章<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNzczNjc4Mw==">《总结：Python 中的异常处理》</span>，这篇文章不仅介绍了 Python 中异常机制的使用，还总结了一系列的最佳实践，很值得一读。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形用户界面和游戏开发</title>
      <link href="/computer-science/python/basic/10.%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
      <url>/computer-science/python/basic/10.%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="图形用户界面和游戏开发"><a class="anchor" href="#图形用户界面和游戏开发">#</a> 图形用户界面和游戏开发</h2><h3 id="基于tkinter模块的gui"><a class="anchor" href="#基于tkinter模块的gui">#</a> 基于 tkinter 模块的 GUI</h3><p>GUI 是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python 默认的 GUI 开发模块是 tkinter（在 Python 3 以前的版本中名为 Tkinter），从这个名字就可以看出它是基于 Tk 的，Tk 是一个工具包，最初是为 Tcl 设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的 GUI 控件。当然 Tk 并不是最新和最好的选择，也没有功能特别强大的 GUI 控件，事实上，开发 GUI 应用并不是 Python 最擅长的工作，如果真的需要使用 Python 开发 GUI 应用，wxPython、PyQt、PyGTK 等模块都是不错的选择。</p><p>基本上使用 tkinter 来开发 GUI 应用需要以下 5 个步骤：</p><ol><li>导入 tkinter 模块中我们需要的东西。</li><li>创建一个顶层窗口对象并用它来承载整个 GUI 应用。</li><li>在顶层窗口对象上添加 GUI 组件。</li><li>通过代码将这些 GUI 组件的功能组织起来。</li><li>进入主事件循环 (main loop)。</li></ol><p>下面的代码演示了如何使用 tkinter 做一个简单的 GUI 应用。</p><pre><code class="language-Python">import tkinterimport tkinter.messageboxdef main():    flag = True    # 修改标签上的文字    def change_label_text():        nonlocal flag        flag = not flag        color, msg = ('red', 'Hello, world!')\            if flag else ('blue', 'Goodbye, world!')        label.config(text=msg, fg=color)    # 确认退出    def confirm_to_quit():        if tkinter.messagebox.askokcancel('温馨提示', '确定要退出吗?'):            top.quit()    # 创建顶层窗口    top = tkinter.Tk()    # 设置窗口大小    top.geometry('240x160')    # 设置窗口标题    top.title('小游戏')    # 创建标签对象并添加到顶层窗口    label = tkinter.Label(top, text='Hello, world!', font='Arial -32', fg='red')    label.pack(expand=1)    # 创建一个装按钮的容器    panel = tkinter.Frame(top)    # 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数    button1 = tkinter.Button(panel, text='修改', command=change_label_text)    button1.pack(side='left')    button2 = tkinter.Button(panel, text='退出', command=confirm_to_quit)    button2.pack(side='right')    panel.pack(side='bottom')    # 开启主事件循环    tkinter.mainloop()if __name__ == '__main__':    main()</code></pre><p>需要说明的是，GUI 应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk 为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和 Grid（基于网格坐标来摆放控件），此处不进行赘述。</p><h3 id="使用pygame进行游戏开发"><a class="anchor" href="#使用pygame进行游戏开发">#</a> 使用 Pygame 进行游戏开发</h3><p>Pygame 是一个开源的 Python 模块，专门用于多媒体应用（如电子游戏）的开发，其中包含对图像、声音、视频、事件、碰撞等的支持。Pygame 建立在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU0RM"> SDL</span> 的基础上，SDL 是一套跨平台的多媒体开发库，用 C 语言实现，被广泛的应用于游戏、模拟器、播放器等的开发。而 Pygame 让游戏开发者不再被底层语言束缚，可以更多的关注游戏的功能和逻辑。</p><p>下面我们来完成一个简单的小游戏，游戏的名字叫 “大球吃小球”，当然完成这个游戏并不是重点，学会使用 Pygame 也不是重点，最重要的我们要在这个过程中体会如何使用前面讲解的面向对象程序设计，学会用这种编程思想去解决现实中的问题。</p><h4 id="制作游戏窗口"><a class="anchor" href="#制作游戏窗口">#</a> 制作游戏窗口</h4><pre><code class="language-Python">import pygamedef main():    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen = pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption('大球吃小球')    running = True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type == pygame.QUIT:                running = Falseif __name__ == '__main__':    main()</code></pre><h4 id="在窗口中绘图"><a class="anchor" href="#在窗口中绘图">#</a> 在窗口中绘图</h4><p>可以通过 pygame 中 draw 模块的函数在窗口上绘图，可以绘制的图形包括：线条、矩形、多边形、圆、椭圆、圆弧等。需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点 <code>(0, 0)</code> ，向右是 x 轴的正向，向下是 y 轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTgzJThGJUU3JUI0JUEw">像素</span>。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将一张图片放大若干倍，就可以看到这些点。pygame 中表示颜色用的是色光<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThFJTlGJUU4JTg5JUIy">三原色</span>表示法，即通过一个元组或列表来指定颜色的 RGB 值，每个值都在 0~255 之间，因为是每种原色都用一个 8 位（bit）的值来表示，三种颜色相当于一共由 24 位构成，这也就是常说的 “24 位颜色表示法”。</p><pre><code class="language-Python">import pygamedef main():    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen = pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption('大球吃小球')    # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组)    screen.fill((242, 242, 242))    # 绘制一个圆(参数分别是: 屏幕, 颜色, 圆心位置, 半径, 0表示填充圆)    pygame.draw.circle(screen, (255, 0, 0,), (100, 100), 30, 0)    # 刷新当前窗口(渲染窗口将绘制的图像呈现出来)    pygame.display.flip()    running = True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type == pygame.QUIT:                running = Falseif __name__ == '__main__':    main()</code></pre><h4 id="加载图像"><a class="anchor" href="#加载图像">#</a> 加载图像</h4><p>如果需要直接加载图像到窗口上，可以使用 pygame 中 image 模块的函数来加载图像，再通过之前获得的窗口对象的 <code>blit</code>  方法渲染图像，代码如下所示。</p><pre><code class="language-Python">import pygamedef main():    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen = pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption('大球吃小球')    # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组)    screen.fill((255, 255, 255))    # 通过指定的文件名加载图像    ball_image = pygame.image.load('./res/ball.png')    # 在窗口上渲染图像    screen.blit(ball_image, (50, 50))    # 刷新当前窗口(渲染窗口将绘制的图像呈现出来)    pygame.display.flip()    running = True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type == pygame.QUIT:                running = Falseif __name__ == '__main__':    main()</code></pre><h4 id="实现动画效果"><a class="anchor" href="#实现动画效果">#</a> 实现动画效果</h4><p>说到<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThBJUE4JUU3JTk0JUJC">动画</span>这个词大家都不会陌生，事实上要实现动画效果，本身的原理也非常简单，就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果。如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在循环中修改小球的位置再刷新整个窗口即可。</p><pre><code class="language-Python">import pygamedef main():    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen = pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption('大球吃小球')    # 定义变量来表示小球在屏幕上的位置    x, y = 50, 50    running = True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type == pygame.QUIT:                running = False        screen.fill((255, 255, 255))        pygame.draw.circle(screen, (255, 0, 0,), (x, y), 30, 0)        pygame.display.flip()        # 每隔50毫秒就改变小球的位置再刷新窗口        pygame.time.delay(50)        x, y = x + 5, y + 5if __name__ == '__main__':    main()</code></pre><h4 id="碰撞检测"><a class="anchor" href="#碰撞检测">#</a> 碰撞检测</h4><p>通常一个游戏中会有很多对象出现，而这些对象之间的 “碰撞” 在所难免，比如炮弹击中了飞机、箱子撞到了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame 的 sprite（动画精灵）模块就提供了对碰撞检测的支持，这里我们暂时不介绍 sprite 模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查球心的距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球，当然要做到这一点，我们可以把之前学习到的面向对象的知识应用起来。</p><pre><code class="language-Python">from enum import Enum, uniquefrom math import sqrtfrom random import randintimport pygame@uniqueclass Color(Enum):    &quot;&quot;&quot;颜色&quot;&quot;&quot;    RED = (255, 0, 0)    GREEN = (0, 255, 0)    BLUE = (0, 0, 255)    BLACK = (0, 0, 0)    WHITE = (255, 255, 255)    GRAY = (242, 242, 242)    @staticmethod    def random_color():        &quot;&quot;&quot;获得随机颜色&quot;&quot;&quot;        r = randint(0, 255)        g = randint(0, 255)        b = randint(0, 255)        return (r, g, b)class Ball(object):    &quot;&quot;&quot;球&quot;&quot;&quot;    def __init__(self, x, y, radius, sx, sy, color=Color.RED):        &quot;&quot;&quot;初始化方法&quot;&quot;&quot;        self.x = x        self.y = y        self.radius = radius        self.sx = sx        self.sy = sy        self.color = color        self.alive = True    def move(self, screen):        &quot;&quot;&quot;移动&quot;&quot;&quot;        self.x += self.sx        self.y += self.sy        if self.x - self.radius &lt;= 0 or \                self.x + self.radius &gt;= screen.get_width():            self.sx = -self.sx        if self.y - self.radius &lt;= 0 or \                self.y + self.radius &gt;= screen.get_height():            self.sy = -self.sy    def eat(self, other):        &quot;&quot;&quot;吃其他球&quot;&quot;&quot;        if self.alive and other.alive and self != other:            dx, dy = self.x - other.x, self.y - other.y            distance = sqrt(dx ** 2 + dy ** 2)            if distance &lt; self.radius + other.radius \                    and self.radius &gt; other.radius:                other.alive = False                self.radius = self.radius + int(other.radius * 0.146)    def draw(self, screen):        &quot;&quot;&quot;在窗口上绘制球&quot;&quot;&quot;        pygame.draw.circle(screen, self.color,                           (self.x, self.y), self.radius, 0)</code></pre><h4 id="事件处理"><a class="anchor" href="#事件处理">#</a> 事件处理</h4><p>可以在事件循环中对鼠标事件进行处理，通过事件对象的 <code>type</code>  属性可以判定事件类型，再通过 <code>pos</code>  属性就可以获得鼠标点击的位置。如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似。</p><pre><code class="language-Python">def main():    # 定义用来装所有球的容器    balls = []    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen = pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption('大球吃小球')    running = True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type == pygame.QUIT:                running = False            # 处理鼠标事件的代码            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:                # 获得点击鼠标的位置                x, y = event.pos                radius = randint(10, 100)                sx, sy = randint(-10, 10), randint(-10, 10)                color = Color.random_color()                # 在点击鼠标的位置创建一个球(大小、速度和颜色随机)                ball = Ball(x, y, radius, sx, sy, color)                # 将球添加到列表容器中                balls.append(ball)        screen.fill((255, 255, 255))        # 取出容器中的球 如果没被吃掉就绘制 被吃掉了就移除        for ball in balls:            if ball.alive:                ball.draw(screen)            else:                balls.remove(ball)        pygame.display.flip()        # 每隔50毫秒就改变球的位置再刷新窗口        pygame.time.delay(50)        for ball in balls:            ball.move(screen)            # 检查球有没有吃到其他的球            for other in balls:                ball.eat(other)if __name__ == '__main__':    main()</code></pre><p>上面的两段代码合在一起，我们就完成了 “大球吃小球” 的游戏（如下图所示），准确的说它算不上一个游戏，但是做一个小游戏的基本知识我们已经通过这个例子告诉大家了，有了这些知识已经可以开始你的小游戏开发之旅了。其实上面的代码中还有很多值得改进的地方，比如刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程的知识后，用一个后台线程来处理这些事可能是更好的选择。如果希望获得更好的用户体验，我们还可以在游戏中加入背景音乐以及在球与球发生碰撞时播放音效，利用 pygame 的 mixer 和 music 模块，我们可以很容易的做到这一点，大家可以自行了解这方面的知识。事实上，想了解更多的关于 pygame 的知识，最好的教程是<span class="exturl" data-url="aHR0cHM6Ly93d3cucHlnYW1lLm9yZy9uZXdz"> pygame 的官方网站</span>，如果英语没毛病就可以赶紧去看看啦。 如果想开发<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvM0QlRTYlQjglQjglRTYlODglOEY="> 3D 游戏</span>，pygame 就显得力不从心了，对 3D 游戏开发如果有兴趣的读者不妨看看<span class="exturl" data-url="aHR0cHM6Ly93d3cucGFuZGEzZC5vcmcv"> Panda3D</span>。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象进阶</title>
      <link href="/computer-science/python/basic/09.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
      <url>/computer-science/python/basic/09.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象进阶"><a class="anchor" href="#面向对象进阶">#</a> 面向对象进阶</h2><p>在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对 Python 中的面向对象编程进行更为深入的了解。</p><h3 id="property装饰器"><a class="anchor" href="#property装饰器">#</a> @property 装饰器</h3><p>之前我们讨论过 Python 中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的 getter（访问器）和 setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用 @property 包装器来包装 getter 和 setter 方法，使得对属性的访问既安全又方便，代码如下所示。</p><pre><code class="language-Python">class Person(object):    def __init__(self, name, age):        self._name = name        self._age = age    # 访问器 - getter方法    @property    def name(self):        return self._name    # 访问器 - getter方法    @property    def age(self):        return self._age    # 修改器 - setter方法    @age.setter    def age(self, age):        self._age = age    def play(self):        if self._age &lt;= 16:            print('%s正在玩飞行棋.' % self._name)        else:            print('%s正在玩斗地主.' % self._name)def main():    person = Person('王大锤', 12)    person.play()    person.age = 22    person.play()    # person.name = '白元芳'  # AttributeError: can't set attributeif __name__ == '__main__':    main()</code></pre><h3 id="__slots__魔法"><a class="anchor" href="#__slots__魔法">#</a> __slots__魔法</h3><p>我们讲到这里，不知道大家是否已经意识到，Python 是一门<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThBJUE4JUU2JTgwJTgxJUU4JUFGJUFEJUU4JUE4JTgw">动态语言</span>。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p><pre><code class="language-Python">class Person(object):    # 限定Person对象只能绑定_name, _age和_gender属性    __slots__ = ('_name', '_age', '_gender')    def __init__(self, name, age):        self._name = name        self._age = age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age = age    def play(self):        if self._age &lt;= 16:            print('%s正在玩飞行棋.' % self._name)        else:            print('%s正在玩斗地主.' % self._name)def main():    person = Person('王大锤', 22)    person.play()    person._gender = '男'    # AttributeError: 'Person' object has no attribute '_is_gay'    # person._is_gay = True</code></pre><h3 id="静态方法和类方法"><a class="anchor" href="#静态方法和类方法">#</a> 静态方法和类方法</h3><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个 “三角形” 类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。</p><pre><code class="language-Python">from math import sqrtclass Triangle(object):    def __init__(self, a, b, c):        self._a = a        self._b = b        self._c = c    @staticmethod    def is_valid(a, b, c):        return a + b &gt; c and b + c &gt; a and a + c &gt; b    def perimeter(self):        return self._a + self._b + self._c    def area(self):        half = self.perimeter() / 2        return sqrt(half * (half - self._a) *                    (half - self._b) * (half - self._c))def main():    a, b, c = 3, 4, 5    # 静态方法和类方法都是通过给类发消息来调用的    if Triangle.is_valid(a, b, c):        t = Triangle(a, b, c)        print(t.perimeter())        # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数        # print(Triangle.perimeter(t))        print(t.area())        # print(Triangle.area(t))    else:        print('无法构成三角形.')if __name__ == '__main__':    main()</code></pre><p>和静态方法比较类似，Python 还可以在类中定义类方法，类方法的第一个参数约定名为 cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。</p><pre><code class="language-Python">from time import time, localtime, sleepclass Clock(object):    &quot;&quot;&quot;数字时钟&quot;&quot;&quot;    def __init__(self, hour=0, minute=0, second=0):        self._hour = hour        self._minute = minute        self._second = second    @classmethod    def now(cls):        ctime = localtime(time())        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)    def run(self):        &quot;&quot;&quot;走字&quot;&quot;&quot;        self._second += 1        if self._second == 60:            self._second = 0            self._minute += 1            if self._minute == 60:                self._minute = 0                self._hour += 1                if self._hour == 24:                    self._hour = 0    def show(self):        &quot;&quot;&quot;显示时间&quot;&quot;&quot;        return '%02d:%02d:%02d' % \               (self._hour, self._minute, self._second)def main():    # 通过类方法创建对象并获取系统时间    clock = Clock.now()    while True:        print(clock.show())        sleep(1)        clock.run()if __name__ == '__main__':    main()</code></pre><h3 id="类之间的关系"><a class="anchor" href="#类之间的关系">#</a> 类之间的关系</h3><p>简单的说，类和类之间的关系有三种：is-a、has-a 和 use-a 关系。</p><ul><li>is-a 关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li><li>has-a 关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li><li>use-a 关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li></ul><p>我们可以使用一种叫做<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJCJTlGJUU0JUI4JTgwJUU1JUJCJUJBJUU2JUE4JUExJUU4JUFGJUFEJUU4JUE4JTgw"> UML</span>（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于 UML 我们在这里不做详细的介绍，有兴趣的读者可以自行阅读<span class="exturl" data-url="aHR0cHM6Ly9lLmpkLmNvbS8zMDM5Mjk0OS5odG1s">《UML 面向对象设计基础》</span>一书。</p><p><img data-src="./res/uml-components.png" alt="" /></p><p><img data-src="./res/uml-example.png" alt="" /></p><p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。</p><h3 id="继承和多态"><a class="anchor" href="#继承和多态">#</a> 继承和多态</h3><p>刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTg3JThDJUU2JUIwJThGJUU2JTlCJUJGJUU2JThEJUEyJUU1JThFJTlGJUU1JTg4JTk5">里氏替换原则</span>。下面我们先看一个继承的例子。</p><pre><code class="language-Python">class Person(object):    &quot;&quot;&quot;人&quot;&quot;&quot;    def __init__(self, name, age):        self._name = name        self._age = age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age = age    def play(self):        print('%s正在愉快的玩耍.' % self._name)    def watch_av(self):        if self._age &gt;= 18:            print('%s正在观看爱情动作片.' % self._name)        else:            print('%s只能观看《熊出没》.' % self._name)class Student(Person):    &quot;&quot;&quot;学生&quot;&quot;&quot;    def __init__(self, name, age, grade):        super().__init__(name, age)        self._grade = grade    @property    def grade(self):        return self._grade    @grade.setter    def grade(self, grade):        self._grade = grade    def study(self, course):        print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person):    &quot;&quot;&quot;老师&quot;&quot;&quot;    def __init__(self, name, age, title):        super().__init__(name, age)        self._title = title    @property    def title(self):        return self._title    @title.setter    def title(self, title):        self._title = title    def teach(self, course):        print('%s%s正在讲%s.' % (self._name, self._title, course))def main():    stu = Student('王大锤', 15, '初三')    stu.study('数学')    stu.watch_av()    t = Teacher('骆昊', 38, '砖家')    t.teach('Python程序设计')    t.watch_av()if __name__ == '__main__':    main()</code></pre><p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。</p><pre><code class="language-Python">from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta):    &quot;&quot;&quot;宠物&quot;&quot;&quot;    def __init__(self, nickname):        self._nickname = nickname    @abstractmethod    def make_voice(self):        &quot;&quot;&quot;发出声音&quot;&quot;&quot;        passclass Dog(Pet):    &quot;&quot;&quot;狗&quot;&quot;&quot;    def make_voice(self):        print('%s: 汪汪汪...' % self._nickname)class Cat(Pet):    &quot;&quot;&quot;猫&quot;&quot;&quot;    def make_voice(self):        print('%s: 喵...喵...' % self._nickname)def main():    pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')]    for pet in pets:        pet.make_voice()if __name__ == '__main__':    main()</code></pre><p>在上面的代码中，我们将 <code>Pet</code>  类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python 从语法层面并没有像 Java 或 C# 那样提供对抽象类的支持，但是我们可以通过 <code>abc</code>  模块的 <code>ABCMeta</code>  元类和 <code>abstractmethod</code>  包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中， <code>Dog</code>  和 <code>Cat</code>  两个子类分别对 <code>Pet</code>  类中的 <code>make_voice</code>  抽象方法进行了重写并给出了不同的实现版本，当我们在 <code>main</code>  函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p><h3 id="综合案例"><a class="anchor" href="#综合案例">#</a> 综合案例</h3><h4 id="案例1奥特曼打小怪兽"><a class="anchor" href="#案例1奥特曼打小怪兽">#</a> 案例 1：奥特曼打小怪兽。</h4><pre><code class="language-Python">from abc import ABCMeta, abstractmethodfrom random import randint, randrangeclass Fighter(object, metaclass=ABCMeta):    &quot;&quot;&quot;战斗者&quot;&quot;&quot;    # 通过__slots__魔法限定对象可以绑定的成员变量    __slots__ = ('_name', '_hp')    def __init__(self, name, hp):        &quot;&quot;&quot;初始化方法        :param name: 名字        :param hp: 生命值        &quot;&quot;&quot;        self._name = name        self._hp = hp    @property    def name(self):        return self._name    @property    def hp(self):        return self._hp    @hp.setter    def hp(self, hp):        self._hp = hp if hp &gt;= 0 else 0    @property    def alive(self):        return self._hp &gt; 0    @abstractmethod    def attack(self, other):        &quot;&quot;&quot;攻击        :param other: 被攻击的对象        &quot;&quot;&quot;        passclass Ultraman(Fighter):    &quot;&quot;&quot;奥特曼&quot;&quot;&quot;    __slots__ = ('_name', '_hp', '_mp')    def __init__(self, name, hp, mp):        &quot;&quot;&quot;初始化方法        :param name: 名字        :param hp: 生命值        :param mp: 魔法值        &quot;&quot;&quot;        super().__init__(name, hp)        self._mp = mp    def attack(self, other):        other.hp -= randint(15, 25)    def huge_attack(self, other):        &quot;&quot;&quot;究极必杀技(打掉对方至少50点或四分之三的血)        :param other: 被攻击的对象        :return: 使用成功返回True否则返回False        &quot;&quot;&quot;        if self._mp &gt;= 50:            self._mp -= 50            injury = other.hp * 3 // 4            injury = injury if injury &gt;= 50 else 50            other.hp -= injury            return True        else:            self.attack(other)            return False    def magic_attack(self, others):        &quot;&quot;&quot;魔法攻击        :param others: 被攻击的群体        :return: 使用魔法成功返回True否则返回False        &quot;&quot;&quot;        if self._mp &gt;= 20:            self._mp -= 20            for temp in others:                if temp.alive:                    temp.hp -= randint(10, 15)            return True        else:            return False    def resume(self):        &quot;&quot;&quot;恢复魔法值&quot;&quot;&quot;        incr_point = randint(1, 10)        self._mp += incr_point        return incr_point    def __str__(self):        return '~~~%s奥特曼~~~\n' % self._name + \            '生命值: %d\n' % self._hp + \            '魔法值: %d\n' % self._mpclass Monster(Fighter):    &quot;&quot;&quot;小怪兽&quot;&quot;&quot;    __slots__ = ('_name', '_hp')    def attack(self, other):        other.hp -= randint(10, 20)    def __str__(self):        return '~~~%s小怪兽~~~\n' % self._name + \            '生命值: %d\n' % self._hpdef is_any_alive(monsters):    &quot;&quot;&quot;判断有没有小怪兽是活着的&quot;&quot;&quot;    for monster in monsters:        if monster.alive &gt; 0:            return True    return Falsedef select_alive_one(monsters):    &quot;&quot;&quot;选中一只活着的小怪兽&quot;&quot;&quot;    monsters_len = len(monsters)    while True:        index = randrange(monsters_len)        monster = monsters[index]        if monster.alive &gt; 0:            return monsterdef display_info(ultraman, monsters):    &quot;&quot;&quot;显示奥特曼和小怪兽的信息&quot;&quot;&quot;    print(ultraman)    for monster in monsters:        print(monster, end='')def main():    u = Ultraman('骆昊', 1000, 120)    m1 = Monster('狄仁杰', 250)    m2 = Monster('白元芳', 500)    m3 = Monster('王大锤', 750)    ms = [m1, m2, m3]    fight_round = 1    while u.alive and is_any_alive(ms):        print('========第%02d回合========' % fight_round)        m = select_alive_one(ms)  # 选中一只小怪兽        skill = randint(1, 10)   # 通过随机数选择使用哪种技能        if skill &lt;= 6:  # 60%的概率使用普通攻击            print('%s使用普通攻击打了%s.' % (u.name, m.name))            u.attack(m)            print('%s的魔法值恢复了%d点.' % (u.name, u.resume()))        elif skill &lt;= 9:  # 30%的概率使用魔法攻击(可能因魔法值不足而失败)            if u.magic_attack(ms):                print('%s使用了魔法攻击.' % u.name)            else:                print('%s使用魔法失败.' % u.name)        else:  # 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击)            if u.huge_attack(m):                print('%s使用究极必杀技虐了%s.' % (u.name, m.name))            else:                print('%s使用普通攻击打了%s.' % (u.name, m.name))                print('%s的魔法值恢复了%d点.' % (u.name, u.resume()))        if m.alive &gt; 0:  # 如果选中的小怪兽没有死就回击奥特曼            print('%s回击了%s.' % (m.name, u.name))            m.attack(u)        display_info(u, ms)  # 每个回合结束后显示奥特曼和小怪兽的信息        fight_round += 1    print('\n========战斗结束!========\n')    if u.alive &gt; 0:        print('%s奥特曼胜利!' % u.name)    else:        print('小怪兽胜利!')if __name__ == '__main__':    main()</code></pre><h4 id="案例2扑克游戏"><a class="anchor" href="#案例2扑克游戏">#</a> 案例 2：扑克游戏。</h4><pre><code class="language-Python">import randomclass Card(object):    &quot;&quot;&quot;一张牌&quot;&quot;&quot;    def __init__(self, suite, face):        self._suite = suite        self._face = face    @property    def face(self):        return self._face    @property    def suite(self):        return self._suite    def __str__(self):        if self._face == 1:            face_str = 'A'        elif self._face == 11:            face_str = 'J'        elif self._face == 12:            face_str = 'Q'        elif self._face == 13:            face_str = 'K'        else:            face_str = str(self._face)        return '%s%s' % (self._suite, face_str)        def __repr__(self):        return self.__str__()class Poker(object):    &quot;&quot;&quot;一副牌&quot;&quot;&quot;    def __init__(self):        self._cards = [Card(suite, face)                        for suite in '♠♥♣♦'                       for face in range(1, 14)]        self._current = 0    @property    def cards(self):        return self._cards    def shuffle(self):        &quot;&quot;&quot;洗牌(随机乱序)&quot;&quot;&quot;        self._current = 0        random.shuffle(self._cards)    @property    def next(self):        &quot;&quot;&quot;发牌&quot;&quot;&quot;        card = self._cards[self._current]        self._current += 1        return card    @property    def has_next(self):        &quot;&quot;&quot;还有没有牌&quot;&quot;&quot;        return self._current &lt; len(self._cards)class Player(object):    &quot;&quot;&quot;玩家&quot;&quot;&quot;    def __init__(self, name):        self._name = name        self._cards_on_hand = []    @property    def name(self):        return self._name    @property    def cards_on_hand(self):        return self._cards_on_hand    def get(self, card):        &quot;&quot;&quot;摸牌&quot;&quot;&quot;        self._cards_on_hand.append(card)    def arrange(self, card_key):        &quot;&quot;&quot;玩家整理手上的牌&quot;&quot;&quot;        self._cards_on_hand.sort(key=card_key)# 排序规则-先根据花色再根据点数排序def get_key(card):    return (card.suite, card.face)def main():    p = Poker()    p.shuffle()    players = [Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐')]    for _ in range(13):        for player in players:            player.get(p.next)    for player in players:        print(player.name + ':', end=' ')        player.arrange(get_key)        print(player.cards_on_hand)if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明：</strong> 大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如 21 点 (Black Jack)，游戏的规则可以自己在网上找一找。</p></blockquote><h4 id="案例3工资结算系统"><a class="anchor" href="#案例3工资结算系统">#</a> 案例 3：工资结算系统。</h4><pre><code class="language-Python">&quot;&quot;&quot;某公司有三种类型的员工 分别是部门经理、程序员和销售员需要设计一个工资结算系统 根据提供的员工信息来计算月薪部门经理的月薪是每月固定15000元程序员的月薪按本月工作时间计算 每小时150元销售员的月薪是1200元的底薪加上销售额5%的提成&quot;&quot;&quot;from abc import ABCMeta, abstractmethodclass Employee(object, metaclass=ABCMeta):    &quot;&quot;&quot;员工&quot;&quot;&quot;    def __init__(self, name):        &quot;&quot;&quot;        初始化方法        :param name: 姓名        &quot;&quot;&quot;        self._name = name    @property    def name(self):        return self._name    @abstractmethod    def get_salary(self):        &quot;&quot;&quot;        获得月薪        :return: 月薪        &quot;&quot;&quot;        passclass Manager(Employee):    &quot;&quot;&quot;部门经理&quot;&quot;&quot;    def get_salary(self):        return 15000.0class Programmer(Employee):    &quot;&quot;&quot;程序员&quot;&quot;&quot;    def __init__(self, name, working_hour=0):        super().__init__(name)        self._working_hour = working_hour    @property    def working_hour(self):        return self._working_hour    @working_hour.setter    def working_hour(self, working_hour):        self._working_hour = working_hour if working_hour &gt; 0 else 0    def get_salary(self):        return 150.0 * self._working_hourclass Salesman(Employee):    &quot;&quot;&quot;销售员&quot;&quot;&quot;    def __init__(self, name, sales=0):        super().__init__(name)        self._sales = sales    @property    def sales(self):        return self._sales    @sales.setter    def sales(self, sales):        self._sales = sales if sales &gt; 0 else 0    def get_salary(self):        return 1200.0 + self._sales * 0.05def main():    emps = [        Manager('刘备'), Programmer('诸葛亮'),        Manager('曹操'), Salesman('荀彧'),        Salesman('吕布'), Programmer('张辽'),        Programmer('赵云')    ]    for emp in emps:        if isinstance(emp, Programmer):            emp.working_hour = int(input('请输入%s本月工作时间: ' % emp.name))        elif isinstance(emp, Salesman):            emp.sales = float(input('请输入%s本月销售额: ' % emp.name))        # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态)        print('%s本月工资为: ￥%s元' %              (emp.name, emp.get_salary()))if __name__ == '__main__':    main()</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程基础</title>
      <link href="/computer-science/python/basic/08.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/computer-science/python/basic/08.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象编程基础"><a class="anchor" href="#面向对象编程基础">#</a> 面向对象编程基础</h2><p>活在当下的程序员应该都听过 &quot;面向对象编程&quot; 一词，也经常有人问能不能用一句话解释下什么是 &quot;面向对象编程&quot;，我们先来看看比较正式的说法。</p><p>&quot;把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。&quot;</p><p>这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tLw==">知乎</span>。</p><p><img data-src="./res/oop-zhihu.png" alt="" /></p><blockquote><p><strong>说明：</strong> 以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。</p></blockquote><p>之前我们说过 &quot;<strong> 程序是指令的集合</strong> &quot;，我们在程序中书写的语句在执行时会变成一条或多条指令然后由 CPU 去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，&quot; 每个人都应该学习编程 &quot;这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪 60 年代末期，&quot;<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJEJUFGJUU0JUJCJUI2JUU1JThEJUIxJUU2JTlDJUJB"> 软件危机</span> &quot;、&quot;<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJEJUFGJUU0JUJCJUI2JUU1JUI3JUE1JUU3JUE4JThC"> 软件工程</span> &quot; 等一系列的概念开始在行业中出现。</p><p>当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的 &quot;<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUIyJUExJUU2JTlDJTg5JUU5JTkzJUI2JUU1JUJDJUI5"> 银弹</span> &quot;，真正让软件开发者看到希望的是上世纪 70 年代诞生的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU21hbGx0YWxr"> Smalltalk</span> 编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU2ltdWxh"> Simula</span> 语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为 “对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。</p><blockquote><p><strong>说明：</strong> 当然面向对象也不是解决软件开发中所有问题的最后的 “银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python 也不例外。</p></blockquote><h3 id="类和对象"><a class="anchor" href="#类和对象">#</a> 类和对象</h3><p>简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做 “类” 的东西。</p><p><img data-src="./res/object-feature.png" alt="" /></p><h3 id="定义类"><a class="anchor" href="#定义类">#</a> 定义类</h3><p>在 Python 中可以使用 <code>class</code>  关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。</p><pre><code class="language-Python">class Student(object):    # __init__是一个特殊方法用于在创建对象时进行初始化操作    # 通过这个方法我们可以为学生对象绑定name和age两个属性    def __init__(self, name, age):        self.name = name        self.age = age    def study(self, course_name):        print('%s正在学习%s.' % (self.name, course_name))    # PEP 8要求标识符的名字用全小写多个单词用下划线连接    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)    def watch_movie(self):        if self.age &lt; 18:            print('%s只能观看《熊出没》.' % self.name)        else:            print('%s正在观看岛国爱情大电影.' % self.name)</code></pre><blockquote><p><strong>说明：</strong> 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。</p></blockquote><h3 id="创建和使用对象"><a class="anchor" href="#创建和使用对象">#</a> 创建和使用对象</h3><p>当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。</p><pre><code class="language-Python">def main():    # 创建学生对象并指定姓名和年龄    stu1 = Student('骆昊', 38)    # 给对象发study消息    stu1.study('Python程序设计')    # 给对象发watch_av消息    stu1.watch_movie()    stu2 = Student('王大锤', 15)    stu2.study('思想品德')    stu2.watch_movie()if __name__ == '__main__':    main()</code></pre><h3 id="访问可见性问题"><a class="anchor" href="#访问可见性问题">#</a> 访问可见性问题</h3><p>对于上面的代码，有 C++、Java、C# 等编程经验的程序员可能会问，我们给 <code>Student</code>  对象绑定的 <code>name</code>  和 <code>age</code>  属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在 Python 中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。</p><pre><code class="language-Python">class Test:    def __init__(self, foo):        self.__foo = foo    def __bar(self):        print(self.__foo)        print('__bar')def main():    test = Test('hello')    # AttributeError: 'Test' object has no attribute '__bar'    test.__bar()    # AttributeError: 'Test' object has no attribute '__foo'    print(test.__foo)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>但是，Python 并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是 &quot;<strong>We are all consenting adults here</strong>&quot;。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。</p><pre><code class="language-Python">class Test:    def __init__(self, foo):        self.__foo = foo    def __bar(self):        print(self.__foo)        print('__bar')def main():    test = Test('hello')    test._Test__bar()    print(test._Test__foo)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数 Python 程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFja2ZydWVkL2FydGljbGUvZGV0YWlscy83OTUyMTQwNA==">《Python - 那些年我们踩过的那些坑》</span>文章中的讲解。</p><h3 id="面向对象的支柱"><a class="anchor" href="#面向对象的支柱">#</a> 面向对象的支柱</h3><p>面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是 &quot;隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口&quot;。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。</p><h3 id="练习"><a class="anchor" href="#练习">#</a> 练习</h3><h4 id="练习1定义一个类描述数字时钟"><a class="anchor" href="#练习1定义一个类描述数字时钟">#</a> 练习 1：定义一个类描述数字时钟。</h4><p>参考答案：</p><pre><code class="language-Python">from time import sleepclass Clock(object):    &quot;&quot;&quot;数字时钟&quot;&quot;&quot;    def __init__(self, hour=0, minute=0, second=0):        &quot;&quot;&quot;初始化方法        :param hour: 时        :param minute: 分        :param second: 秒        &quot;&quot;&quot;        self._hour = hour        self._minute = minute        self._second = second    def run(self):        &quot;&quot;&quot;走字&quot;&quot;&quot;        self._second += 1        if self._second == 60:            self._second = 0            self._minute += 1            if self._minute == 60:                self._minute = 0                self._hour += 1                if self._hour == 24:                    self._hour = 0    def show(self):        &quot;&quot;&quot;显示时间&quot;&quot;&quot;        return '%02d:%02d:%02d' % \               (self._hour, self._minute, self._second)def main():    clock = Clock(23, 59, 58)    while True:        print(clock.show())        sleep(1)        clock.run()if __name__ == '__main__':    main()</code></pre><h4 id="练习2定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法"><a class="anchor" href="#练习2定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法">#</a> 练习 2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。</h4><p>参考答案：</p><pre><code class="language-Python">from math import sqrtclass Point(object):    def __init__(self, x=0, y=0):        &quot;&quot;&quot;初始化方法                :param x: 横坐标        :param y: 纵坐标        &quot;&quot;&quot;        self.x = x        self.y = y    def move_to(self, x, y):        &quot;&quot;&quot;移动到指定位置                :param x: 新的横坐标        &quot;param y: 新的纵坐标        &quot;&quot;&quot;        self.x = x        self.y = y    def move_by(self, dx, dy):        &quot;&quot;&quot;移动指定的增量                :param dx: 横坐标的增量        &quot;param dy: 纵坐标的增量        &quot;&quot;&quot;        self.x += dx        self.y += dy    def distance_to(self, other):        &quot;&quot;&quot;计算与另一个点的距离                :param other: 另一个点        &quot;&quot;&quot;        dx = self.x - other.x        dy = self.y - other.y        return sqrt(dx ** 2 + dy ** 2)    def __str__(self):        return '(%s, %s)' % (str(self.x), str(self.y))def main():    p1 = Point(3, 5)    p2 = Point()    print(p1)    print(p2)    p2.move_by(-1, 2)    print(p2)    print(p1.distance_to(p2))if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明：</strong> 本章中的插图来自于 Grady Booch 等著作的<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8yMDQ3NjU2MTkxOC5odG1s">《面向对象分析与设计》</span>一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串和常用数据结构</title>
      <link href="/computer-science/python/basic/07.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/computer-science/python/basic/07.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串和常用数据结构"><a class="anchor" href="#字符串和常用数据结构">#</a> 字符串和常用数据结构</h2><h3 id="使用字符串"><a class="anchor" href="#使用字符串">#</a> 使用字符串</h3><p>第二次世界大战促使了现代电子计算机的诞生，最初计算机被应用于导弹弹道的计算，而在计算机诞生后的很多年时间里，计算机处理的信息基本上都是数值型的信息。世界上的第一台电子计算机叫 ENIAC（电子数值积分计算机），诞生于美国的宾夕法尼亚大学，每秒钟能够完成约 5000 次浮点运算。随着时间的推移，虽然数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据可能都是以文本的方式存在的，如果我们希望通过 Python 程序操作这些文本信息，就必须要先了解字符串类型以及与它相关的知识。</p><p>所谓<strong>字符串</strong>，就是由零个或多个字符组成的有限序列，一般记为<img data-src="./res/formula_5.png" alt="$${\displaystyle s=a_{1}a_{2}\dots a_{n}(0\leq n \leq \infty)}$$" />。在 Python 程序中，如果我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。</p><pre><code class="language-Python">s1 = 'hello, world!'s2 = &quot;hello, world!&quot;# 以三个双引号或单引号开头的字符串可以折行s3 = &quot;&quot;&quot;hello, world!&quot;&quot;&quot;print(s1, s2, s3, end='')</code></pre><p>可以在字符串中使用 <code>\</code> （反斜杠）来表示转义，也就是说 <code>\</code>  后面的字符不再是它原来的意义，例如： <code>\n</code>  不是代表反斜杠和字符 n，而是表示换行；而 <code>\t</code>  也不是代表反斜杠和字符 t，而是表示制表符。所以如果想在字符串中表示 <code>'</code>  要写成 <code>\'</code> ，同理想表示 <code>\</code>  要写成 <code>\\</code> 。可以运行下面的代码看看会输出什么。</p><pre><code class="language-Python">s1 = '\'hello, world!\''s2 = '\n\\hello, world!\\\n'print(s1, s2, end='')</code></pre><p>在 <code>\</code>  后面还可以跟一个八进制或者十六进制数来表示字符，例如 <code>\141</code>  和 <code>\x61</code>  都代表小写字母 <code>a</code> ，前者是八进制的表示法，后者是十六进制的表示法。也可以在 <code>\</code>  后面跟 Unicode 字符编码来表示字符，例如 <code>\u9a86\u660a</code>  代表的是中文 “骆昊”。运行下面的代码，看看输出了什么。</p><pre><code class="language-Python">s1 = '\141\142\143\x61\x62\x63's2 = '\u9a86\u660a'print(s1, s2)</code></pre><p>如果不希望字符串中的 <code>\</code>  表示转义，我们可以通过在字符串的最前面加上字母 <code>r</code>  来加以说明，再看看下面的代码又会输出什么。</p><pre><code class="language-Python">s1 = r'\'hello, world!\''s2 = r'\n\\hello, world!\\\n'print(s1, s2, end='')</code></pre><p>Python 为字符串类型提供了非常丰富的运算符，我们可以使用 <code>+</code>  运算符来实现字符串的拼接，可以使用 <code>*</code>  运算符来重复一个字符串的内容，可以使用 <code>in</code>  和 <code>not in</code>  来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用 <code>[]</code>  和 <code>[:]</code>  运算符从字符串取出某个字符或某些字符（切片运算），代码如下所示。</p><pre><code class="language-Python">s1 = 'hello ' * 3print(s1) # hello hello hello s2 = 'world's1 += s2print(s1) # hello hello hello worldprint('ll' in s1) # Trueprint('good' in s1) # Falsestr2 = 'abc123456'# 从字符串中取出指定位置的字符(下标运算)print(str2[2]) # c# 字符串切片(从指定的开始索引到指定的结束索引)print(str2[2:5]) # c12print(str2[2:]) # c123456print(str2[2::2]) # c246print(str2[::2]) # ac246print(str2[::-1]) # 654321cbaprint(str2[-3:-1]) # 45</code></pre><p>在 Python 中，我们还可以通过一系列的方法来完成对字符串的处理，代码如下所示。</p><pre><code class="language-Python">str1 = 'hello, world!'# 通过内置函数len计算字符串的长度print(len(str1)) # 13# 获得字符串首字母大写的拷贝print(str1.capitalize()) # Hello, world!# 获得字符串每个单词首字母大写的拷贝print(str1.title()) # Hello, World!# 获得字符串变大写后的拷贝print(str1.upper()) # HELLO, WORLD!# 从字符串中查找子串所在位置print(str1.find('or')) # 8print(str1.find('shit')) # -1# 与find类似但找不到子串时会引发异常# print(str1.index('or'))# print(str1.index('shit'))# 检查字符串是否以指定的字符串开头print(str1.startswith('He')) # Falseprint(str1.startswith('hel')) # True# 检查字符串是否以指定的字符串结尾print(str1.endswith('!')) # True# 将字符串以指定的宽度居中并在两侧填充指定的字符print(str1.center(50, '*'))# 将字符串以指定的宽度靠右放置左侧填充指定的字符print(str1.rjust(50, ' '))str2 = 'abc123456'# 检查字符串是否由数字构成print(str2.isdigit())  # False# 检查字符串是否以字母构成print(str2.isalpha())  # False# 检查字符串是否以数字和字母构成print(str2.isalnum())  # Truestr3 = '  jackfrued@126.com 'print(str3)# 获得字符串修剪左右两侧空格之后的拷贝print(str3.strip())</code></pre><p>我们之前讲过，可以用下面的方式来格式化输出字符串。</p><pre><code class="language-Python">a, b = 5, 10print('%d * %d = %d' % (a, b, a * b))</code></pre><p>当然，我们也可以用字符串提供的方法来完成字符串的格式，代码如下所示。</p><pre><code class="language-Python">a, b = 5, 10print('&#123;0&#125; * &#123;1&#125; = &#123;2&#125;'.format(a, b, a * b))</code></pre><p>Python 3.6 以后，格式化字符串还有更为简洁的书写方式，就是在字符串前加上字母 <code>f</code> ，我们可以使用下面的语法糖来简化上面的代码。</p><pre><code class="language-Python">a, b = 5, 10print(f'&#123;a&#125; * &#123;b&#125; = &#123;a * b&#125;')</code></pre><p>除了字符串，Python 还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。</p><h3 id="使用列表"><a class="anchor" href="#使用列表">#</a> 使用列表</h3><p>不知道大家是否注意到，刚才我们讲到的字符串类型（ <code>str</code> ）和之前我们讲到的数值类型（ <code>int</code>  和 <code>float</code> ）有一些区别。数值类型是标量类型，也就是说这种类型的对象没有可以访问的内部结构；而字符串类型是一种结构化的、非标量类型，所以才会有一系列的属性和方法。接下来我们要介绍的列表（ <code>list</code> ），也是一种结构化的、非标量类型，它是值的有序序列，每个值都可以通过索引进行标识，定义列表可以将列表的元素放在 <code>[]</code>  中，多个元素用 <code>,</code>  进行分隔，可以使用 <code>for</code>  循环对列表元素进行遍历，也可以使用 <code>[]</code>  或 <code>[:]</code>  运算符取出列表中的一个或多个元素。</p><p>下面的代码演示了如何定义列表、如何遍历列表以及列表的下标运算。</p><pre><code class="language-Python">list1 = [1, 3, 5, 7, 100]print(list1) # [1, 3, 5, 7, 100]# 乘号表示列表元素的重复list2 = ['hello'] * 3print(list2) # ['hello', 'hello', 'hello']# 计算列表长度(元素个数)print(len(list1)) # 5# 下标(索引)运算print(list1[0]) # 1print(list1[4]) # 100# print(list1[5])  # IndexError: list index out of rangeprint(list1[-1]) # 100print(list1[-3]) # 5list1[2] = 300print(list1) # [1, 3, 300, 7, 100]# 通过循环用下标遍历列表元素for index in range(len(list1)):    print(list1[index])# 通过for循环遍历列表元素for elem in list1:    print(elem)# 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值for index, elem in enumerate(list1):    print(index, elem)</code></pre><p>下面的代码演示了如何向列表中添加元素以及如何从列表中移除元素。</p><pre><code class="language-Python">list1 = [1, 3, 5, 7, 100]# 添加元素list1.append(200)list1.insert(1, 400)# 合并两个列表# list1.extend([1000, 2000])list1 += [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]print(len(list1)) # 9# 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1:list1.remove(3)if 1234 in list1:    list1.remove(1234)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]# 从指定的位置删除元素list1.pop(0)list1.pop(len(list1) - 1)print(list1) # [400, 5, 7, 100, 200, 1000]# 清空列表元素list1.clear()print(list1) # []</code></pre><p>和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。</p><pre><code class="language-Python">fruits = ['grape', 'apple', 'strawberry', 'waxberry']fruits += ['pitaya', 'pear', 'mango']# 列表切片fruits2 = fruits[1:4]print(fruits2) # apple strawberry waxberry# 可以通过完整切片操作来复制列表fruits3 = fruits[:]print(fruits3) # ['grape', 'apple', 'strawberry', 'waxberry', 'pitaya', 'pear', 'mango']fruits4 = fruits[-3:-1]print(fruits4) # ['pitaya', 'pear']# 可以通过反向切片操作来获得倒转后的列表的拷贝fruits5 = fruits[::-1]print(fruits5) # ['mango', 'pear', 'pitaya', 'waxberry', 'strawberry', 'apple', 'grape']</code></pre><p>下面的代码实现了对列表的排序操作。</p><pre><code class="language-Python">list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry']list2 = sorted(list1)# sorted函数返回列表排序后的拷贝不会修改传入的列表# 函数的设计就应该像sorted函数一样尽可能不产生副作用list3 = sorted(list1, reverse=True)# 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序list4 = sorted(list1, key=len)print(list1)print(list2)print(list3)print(list4)# 给列表对象发出排序消息直接在列表对象上进行排序list1.sort(reverse=True)print(list1)</code></pre><h3 id="生成式和生成器"><a class="anchor" href="#生成式和生成器">#</a> 生成式和生成器</h3><p>我们还可以使用列表的生成式语法来创建列表，代码如下所示。</p><pre><code class="language-Python">f = [x for x in range(1, 10)]print(f)f = [x + y for x in 'ABCDE' for y in '1234567']print(f)# 用列表的生成表达式语法创建列表容器# 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间f = [x ** 2 for x in range(1, 1000)]print(sys.getsizeof(f))  # 查看对象占用内存的字节数print(f)# 请注意下面的代码创建的不是一个列表而是一个生成器对象# 通过生成器可以获取到数据但它不占用额外的空间存储数据# 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)f = (x ** 2 for x in range(1, 1000))print(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间print(f)for val in f:    print(val)</code></pre><p>除了上面提到的生成器语法，Python 中还有另外一种定义生成器的方式，就是通过 <code>yield</code>  关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk2JTkwJUU2JUIzJUEyJUU5JTgyJUEzJUU1JUE1JTkxJUU2JTk1JUIwJUU1JTg4JTk3">斐波拉切数列</span>的生成器。所谓斐波拉切数列可以通过下面<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgwJTkyJUU1JUJEJTky">递归</span>的方法来进行定义：</p><p><img data-src="./res/formula_6.png" alt="$${\displaystyle F_{0}=0}$$" /></p><p><img data-src="./res/formula_7.png" alt="$${\displaystyle F_{1}=1}$$" /></p><p><img data-src="./res/formula_8.png" alt="$${\displaystyle F_{n}=F_{n-1}+F_{n-2}}({n}\geq{2})$$" /></p><p><img data-src="./res/fibonacci-blocks.png" alt="" /></p><pre><code class="language-Python">def fib(n):    a, b = 0, 1    for _ in range(n):        a, b = b, a + b        yield adef main():    for val in fib(20):        print(val)if __name__ == '__main__':    main()</code></pre><h3 id="使用元组"><a class="anchor" href="#使用元组">#</a> 使用元组</h3><p>Python 中的元组与列表类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。</p><pre><code class="language-Python"># 定义元组t = ('骆昊', 38, True, '四川成都')print(t)# 获取元组中的元素print(t[0])print(t[3])# 遍历元组中的值for member in t:    print(member)# 重新给元组赋值# t[0] = '王大锤'  # TypeError# 变量t重新引用了新的元组原来的元组将被垃圾回收t = ('王大锤', 20, True, '云南昆明')print(t)# 将元组转换成列表person = list(t)print(person)# 列表是可以修改它的元素的person[0] = '李小龙'person[1] = 25print(person)# 将列表转换成元组fruits_list = ['apple', 'banana', 'orange']fruits_tuple = tuple(fruits_list)print(fruits_tuple)</code></pre><p>这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？</p><ol><li>元组中的元素是无法修改的，事实上我们在项目中尤其是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvJUU1JUE0JTlBJUU3JUJBJUJGJUU3JUE4JThC">多线程</span>环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。</li><li>元组在创建时间和占用的空间上面都优于列表。我们可以使用 sys 模块的 getsizeof 函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在 ipython 中使用魔法指令 % timeit 来分析创建同样内容的元组和列表所花费的时间，下图是我的 macOS 系统上测试的结果。</li></ol><p><img data-src="./res/ipython-timeit.png" alt="" /></p><h3 id="使用集合"><a class="anchor" href="#使用集合">#</a> 使用集合</h3><p>Python 中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。</p><p><img data-src="./res/python-set.png" alt="" /></p><p>可以按照下面代码所示的方式来创建和使用集合。</p><pre><code class="language-Python"># 创建集合的字面量语法set1 = &#123;1, 2, 3, 3, 3, 2&#125;print(set1)print('Length =', len(set1))# 创建集合的构造器语法(面向对象部分会进行详细讲解)set2 = set(range(1, 10))set3 = set((1, 2, 3, 3, 2, 1))print(set2, set3)# 创建集合的推导式语法(推导式也可以用于推导集合)set4 = &#123;num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0&#125;print(set4)</code></pre><p>向集合添加元素和从集合删除元素。</p><pre><code class="language-Python">set1.add(4)set1.add(5)set2.update([11, 12])set2.discard(5)if 4 in set2:    set2.remove(4)print(set1, set2)print(set3.pop())print(set3)</code></pre><p>集合的成员、交集、并集、差集等运算。</p><pre><code class="language-Python"># 集合的交集、并集、差集、对称差运算print(set1 &amp; set2)# print(set1.intersection(set2))print(set1 | set2)# print(set1.union(set2))print(set1 - set2)# print(set1.difference(set2))print(set1 ^ set2)# print(set1.symmetric_difference(set2))# 判断子集和超集print(set2 &lt;= set1)# print(set2.issubset(set1))print(set3 &lt;= set1)# print(set3.issubset(set1))print(set1 &gt;= set2)# print(set1.issuperset(set2))print(set1 &gt;= set3)# print(set1.issuperset(set3))</code></pre><blockquote><p><strong>说明：</strong> Python 中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如 <code>&amp;</code>  运算符跟 intersection 方法的作用就是一样的，但是使用运算符让代码更加直观。</p></blockquote><h3 id="使用字典"><a class="anchor" href="#使用字典">#</a> 使用字典</h3><p>字典是另一种可变容器模型，Python 中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的 “键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。</p><pre><code class="language-Python"># 创建字典的字面量语法scores = &#123;'骆昊': 95, '白元芳': 78, '狄仁杰': 82&#125;print(scores)# 创建字典的构造器语法items1 = dict(one=1, two=2, three=3, four=4)# 通过zip函数将两个序列压成字典items2 = dict(zip(['a', 'b', 'c'], '123'))# 创建字典的推导式语法items3 = &#123;num: num ** 2 for num in range(1, 10)&#125;print(items1, items2, items3)# 通过键可以获取字典中对应的值print(scores['骆昊'])print(scores['狄仁杰'])# 对字典中所有键值对进行遍历for key in scores:    print(f'&#123;key&#125;: &#123;scores[key]&#125;')# 更新字典中的元素scores['白元芳'] = 65scores['诸葛王朗'] = 71scores.update(冷面=67, 方启鹤=85)print(scores)if '武则天' in scores:    print(scores['武则天'])print(scores.get('武则天'))# get方法也是通过键获取对应的值但是可以设置默认值print(scores.get('武则天', 60))# 删除字典中的元素print(scores.popitem())print(scores.popitem())print(scores.pop('骆昊', 100))# 清空字典scores.clear()print(scores)</code></pre><h3 id="练习"><a class="anchor" href="#练习">#</a> 练习</h3><h4 id="练习1在屏幕上显示跑马灯文字"><a class="anchor" href="#练习1在屏幕上显示跑马灯文字">#</a> 练习 1：在屏幕上显示跑马灯文字。</h4><p>参考答案：</p><pre><code class="language-Python">import osimport timedef main():    content = '北京欢迎你为你开天辟地…………'    while True:        # 清理屏幕上的输出        os.system('cls')  # os.system('clear')        print(content)        # 休眠200毫秒        time.sleep(0.2)        content = content[1:] + content[0]if __name__ == '__main__':    main()</code></pre><h4 id="练习2设计一个函数产生指定长度的验证码验证码由大小写字母和数字构成"><a class="anchor" href="#练习2设计一个函数产生指定长度的验证码验证码由大小写字母和数字构成">#</a> 练习 2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。</h4><p>参考答案：</p><pre><code class="language-Python">import randomdef generate_code(code_len=4):    &quot;&quot;&quot;    生成指定长度的验证码    :param code_len: 验证码的长度(默认4个字符)    :return: 由大小写英文字母和数字构成的随机验证码    &quot;&quot;&quot;    all_chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'    last_pos = len(all_chars) - 1    code = ''    for _ in range(code_len):        index = random.randint(0, last_pos)        code += all_chars[index]    return code</code></pre><h4 id="练习3设计一个函数返回给定文件名的后缀名"><a class="anchor" href="#练习3设计一个函数返回给定文件名的后缀名">#</a> 练习 3：设计一个函数返回给定文件名的后缀名。</h4><p>参考答案：</p><pre><code class="language-Python">def get_suffix(filename, has_dot=False):    &quot;&quot;&quot;    获取文件名的后缀名    :param filename: 文件名    :param has_dot: 返回的后缀名是否需要带点    :return: 文件的后缀名    &quot;&quot;&quot;    pos = filename.rfind('.')    if 0 &lt; pos &lt; len(filename) - 1:        index = pos if has_dot else pos + 1        return filename[index:]    else:        return ''</code></pre><h4 id="练习4设计一个函数返回传入的列表中最大和第二大的元素的值"><a class="anchor" href="#练习4设计一个函数返回传入的列表中最大和第二大的元素的值">#</a> 练习 4：设计一个函数返回传入的列表中最大和第二大的元素的值。</h4><p>参考答案：</p><pre><code class="language-Python">def max2(x):    m1, m2 = (x[0], x[1]) if x[0] &gt; x[1] else (x[1], x[0])    for index in range(2, len(x)):        if x[index] &gt; m1:            m2 = m1            m1 = x[index]        elif x[index] &gt; m2:            m2 = x[index]    return m1, m2</code></pre><h4 id="练习5计算指定的年月日是这一年的第几天"><a class="anchor" href="#练习5计算指定的年月日是这一年的第几天">#</a> 练习 5：计算指定的年月日是这一年的第几天。</h4><p>参考答案：</p><pre><code class="language-Python">def is_leap_year(year):    &quot;&quot;&quot;    判断指定的年份是不是闰年    :param year: 年份    :return: 闰年返回True平年返回False    &quot;&quot;&quot;    return year % 4 == 0 and year % 100 != 0 or year % 400 == 0def which_day(year, month, date):    &quot;&quot;&quot;    计算传入的日期是这一年的第几天    :param year: 年    :param month: 月    :param date: 日    :return: 第几天    &quot;&quot;&quot;    days_of_month = [        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]    ][is_leap_year(year)]    total = 0    for index in range(month - 1):        total += days_of_month[index]    return total + datedef main():    print(which_day(1980, 11, 28))    print(which_day(1981, 12, 31))    print(which_day(2018, 1, 1))    print(which_day(2016, 3, 1))if __name__ == '__main__':    main()</code></pre><h4 id="练习6打印杨辉三角"><a class="anchor" href="#练习6打印杨辉三角">#</a> 练习 6：打印<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlEJUE4JUU4JUJFJTg5JUU0JUI4JTg5JUU4JUE3JTkyJUU1JUJEJUEy">杨辉三角</span>。</h4><p>参考答案：</p><pre><code class="language-Python">def main():    num = int(input('Number of rows: '))    yh = [[]] * num    for row in range(len(yh)):        yh[row] = [None] * (row + 1)        for col in range(len(yh[row])):            if col == 0 or col == row:                yh[row][col] = 1            else:                yh[row][col] = yh[row - 1][col] + yh[row - 1][col - 1]            print(yh[row][col], end='\t')        print()if __name__ == '__main__':    main()</code></pre><h3 id="综合案例"><a class="anchor" href="#综合案例">#</a> 综合案例</h3><h4 id="案例1双色球选号"><a class="anchor" href="#案例1双色球选号">#</a> 案例 1：双色球选号。</h4><pre><code class="language-Python">from random import randrange, randint, sampledef display(balls):    &quot;&quot;&quot;    输出列表中的双色球号码    &quot;&quot;&quot;    for index, ball in enumerate(balls):        if index == len(balls) - 1:            print('|', end=' ')        print('%02d' % ball, end=' ')    print()def random_select():    &quot;&quot;&quot;    随机选择一组号码    &quot;&quot;&quot;    red_balls = [x for x in range(1, 34)]    selected_balls = []    selected_balls = sample(red_balls, 6)    selected_balls.sort()    selected_balls.append(randint(1, 16))    return selected_ballsdef main():    n = int(input('机选几注: '))    for _ in range(n):        display(random_select())if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明：</strong> 上面使用 random 模块的 sample 函数来实现从列表中选择不重复的 n 个元素。</p></blockquote><h4 id="综合案例2约瑟夫环问题"><a class="anchor" href="#综合案例2约瑟夫环问题">#</a> 综合案例 2：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJBJUE2JUU3JTkxJTlGJUU1JUE0JUFCJUU2JTk2JUFGJUU5JTk3JUFFJUU5JUEyJTk4">约瑟夫环问题</span>。</h4><pre><code class="language-Python">&quot;&quot;&quot;《幸运的基督徒》有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。&quot;&quot;&quot;def main():    persons = [True] * 30    counter, index, number = 0, 0, 0    while counter &lt; 15:        if persons[index]:            number += 1            if number == 9:                persons[index] = False                counter += 1                number = 0        index += 1        index %= 30    for person in persons:        print('基' if person else '非', end='')if __name__ == '__main__':    main()</code></pre><h4 id="综合案例3井字棋游戏"><a class="anchor" href="#综合案例3井字棋游戏">#</a> 综合案例 3：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJTk1JUU1JUFEJTk3JUU2JUEzJThC">井字棋</span>游戏。</h4><pre><code class="language-Python">import osdef print_board(board):    print(board['TL'] + '|' + board['TM'] + '|' + board['TR'])    print('-+-+-')    print(board['ML'] + '|' + board['MM'] + '|' + board['MR'])    print('-+-+-')    print(board['BL'] + '|' + board['BM'] + '|' + board['BR'])def main():    init_board = &#123;        'TL': ' ', 'TM': ' ', 'TR': ' ',        'ML': ' ', 'MM': ' ', 'MR': ' ',        'BL': ' ', 'BM': ' ', 'BR': ' '    &#125;    begin = True    while begin:        curr_board = init_board.copy()        begin = False        turn = 'x'        counter = 0        os.system('clear')        print_board(curr_board)        while counter &lt; 9:            move = input('轮到%s走棋, 请输入位置: ' % turn)            if curr_board[move] == ' ':                counter += 1                curr_board[move] = turn                if turn == 'x':                    turn = 'o'                else:                    turn = 'x'            os.system('clear')            print_board(curr_board)        choice = input('再玩一局?(yes|no)')        begin = choice == 'yes'if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明：</strong> 最后这个案例来自<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMTk0Mzg1My5odG1s">《Python 编程快速上手：让繁琐工作自动化》</span>一书（这本书对有编程基础想迅速使用 Python 将日常工作自动化的人来说还是不错的选择），对代码做了一点点的调整。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数和模块的使用</title>
      <link href="/computer-science/python/basic/06.%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/computer-science/python/basic/06.%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="函数和模块的使用"><a class="anchor" href="#函数和模块的使用">#</a> 函数和模块的使用</h2><p>在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。</p><p><img data-src="./res/formula_3.png" alt="$$x_1 + x_2 + x_3 + x_4 = 8$$" /></p><p>事实上，上面的问题等同于将 8 个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。</p><p><img data-src="./res/formula_4.png" alt="$$C_M^N =\frac{M!}{N!(M-N)!}, \text{(M=7, N=3)} $$" /></p><p>可以用 Python 的程序来计算出这个值，代码如下所示。</p><pre><code class="language-Python">&quot;&quot;&quot;输入M和N计算C(M,N)Version: 0.1Author: 骆昊&quot;&quot;&quot;m = int(input('m = '))n = int(input('n = '))fm = 1for num in range(1, m + 1):    fm *= numfn = 1for num in range(1, n + 1):    fn *= numfm_n = 1for num in range(1, m - n + 1):    fm_n *= numprint(fm // fn // fm_n)</code></pre><h3 id="函数的作用"><a class="anchor" href="#函数的作用">#</a> 函数的作用</h3><p>不知道大家是否注意到，在上面的代码中，我们做了 3 次求阶乘，这样的代码实际上就是重复代码。编程大师<em> Martin Fowler</em> 先生曾经说过：“<strong>代码有很多种坏味道，重复是最坏的一种！</strong>”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为 “函数” 的功能模块中，在需要计算阶乘的地方，我们只需要 “调用” 这个 “函数” 就可以了。</p><h3 id="定义函数"><a class="anchor" href="#定义函数">#</a> 定义函数</h3><p>在 Python 中可以使用 <code>def</code>  关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过 <code>return</code>  关键字来返回一个值，这相当于数学上说的函数的因变量。</p><p>在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。</p><pre><code class="language-Python">&quot;&quot;&quot;输入M和N计算C(M,N)Version: 0.1Author: 骆昊&quot;&quot;&quot;def fac(num):    &quot;&quot;&quot;求阶乘&quot;&quot;&quot;    result = 1    for n in range(1, num + 1):        result *= n    return resultm = int(input('m = '))n = int(input('n = '))# 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数print(fac(m) // fac(n) // fac(m - n))</code></pre><blockquote><p><strong>说明：</strong> Python 的 <code>math</code>  模块中其实已经有一个名为 <code>factorial</code>  函数实现了阶乘运算，事实上求阶乘并不用自己定义函数。下面的例子中，我们讲的函数在 Python 标准库已经实现过了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，<strong>实际开发中并不建议做这种低级的重复劳动</strong>。</p></blockquote><h3 id="函数的参数"><a class="anchor" href="#函数的参数">#</a> 函数的参数</h3><p>函数是绝大多数编程语言中都支持的一个代码的 &quot;构建块&quot;，但是 Python 中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是 Python 对函数参数的处理。在 Python 中，函数的参数可以有默认值，也支持使用可变参数，所以 Python 并不需要像其他语言一样支持<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg3JUJEJUU2JTk1JUIwJUU5JTg3JThEJUU4JUJEJUJE">函数的重载</span>，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。</p><pre><code class="language-Python">from random import randintdef roll_dice(n=2):    &quot;&quot;&quot;摇色子&quot;&quot;&quot;    total = 0    for _ in range(n):        total += randint(1, 6)    return totaldef add(a=0, b=0, c=0):    &quot;&quot;&quot;三个数相加&quot;&quot;&quot;    return a + b + c# 如果没有指定参数那么使用默认值摇两颗色子print(roll_dice())# 摇三颗色子print(roll_dice(3))print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))# 传递参数时可以不按照设定的顺序进行传递print(add(c=50, a=100, b=200))</code></pre><p>我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用 <code>add</code>  函数，这跟其他很多语言中函数重载的效果是一致的。</p><p>其实上面的 <code>add</code>  函数还有更好的实现方案，因为我们可能会对 0 个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。</p><pre><code class="language-Python"># 在参数名前面的*表示args是一个可变参数def add(*args):    total = 0    for val in args:        total += val    return total# 在调用add函数时可以传入0个或多个参数print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9))</code></pre><h3 id="用模块管理函数"><a class="anchor" href="#用模块管理函数">#</a> 用模块管理函数</h3><p>对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py 文件中定义了两个同名函数，由于 Python 没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。</p><pre><code class="language-Python">def foo():    print('hello, world!')def foo():    print('goodbye, world!')# 下面的代码会输出什么呢？foo()</code></pre><p>当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为 <code>foo</code>  的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python 中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过 <code>import</code>  关键字导入指定的模块就可以区分到底要使用的是哪个模块中的 <code>foo</code>  函数，代码如下所示。</p><p><code>module1.py</code></p><pre><code class="language-Python">def foo():    print('hello, world!')</code></pre><p><code>module2.py</code></p><pre><code class="language-Python">def foo():    print('goodbye, world!')</code></pre><p><code>test.py</code></p><pre><code class="language-Python">from module1 import foo# 输出hello, world!foo()from module2 import foo# 输出goodbye, world!foo()</code></pre><p>也可以按照如下所示的方式来区分到底要使用哪一个 <code>foo</code>  函数。</p><p><code>test.py</code></p><pre><code class="language-Python">import module1 as m1import module2 as m2m1.foo()m2.foo()</code></pre><p>但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个 <code>foo</code> ，因为后导入的 foo 覆盖了之前导入的 <code>foo</code> 。</p><p><code>test.py</code></p><pre><code class="language-Python">from module1 import foofrom module2 import foo# 输出goodbye, world!foo()</code></pre><p><code>test.py</code></p><pre><code class="language-Python">from module2 import foofrom module1 import foo# 输出hello, world!foo()</code></pre><p>需要说明的是，如果我们导入的模块除了定义函数之外还有可以执行代码，那么 Python 解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if 条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是 &quot;__main__&quot;。</p><p><code>module3.py</code></p><pre><code class="language-Python">def foo():    passdef bar():    pass# __name__是Python中一个隐含的变量它代表了模块的名字# 只有被Python解释器直接执行的模块的名字才是__main__if __name__ == '__main__':    print('call foo()')    foo()    print('call bar()')    bar()</code></pre><p><code>test.py</code></p><pre><code class="language-Python">import module3# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__</code></pre><h3 id="练习"><a class="anchor" href="#练习">#</a> 练习</h3><h4 id="练习1实现计算求最大公约数和最小公倍数的函数"><a class="anchor" href="#练习1实现计算求最大公约数和最小公倍数的函数">#</a> 练习 1：实现计算求最大公约数和最小公倍数的函数。</h4><p>参考答案：</p><pre><code class="language-Python">def gcd(x, y):    &quot;&quot;&quot;求最大公约数&quot;&quot;&quot;    (x, y) = (y, x) if x &gt; y else (x, y)    for factor in range(x, 0, -1):        if x % factor == 0 and y % factor == 0:            return factordef lcm(x, y):    &quot;&quot;&quot;求最小公倍数&quot;&quot;&quot;    return x * y // gcd(x, y)</code></pre><h4 id="练习2实现判断一个数是不是回文数的函数"><a class="anchor" href="#练习2实现判断一个数是不是回文数的函数">#</a> 练习 2：实现判断一个数是不是回文数的函数。</h4><p>参考答案：</p><pre><code class="language-Python">def is_palindrome(num):    &quot;&quot;&quot;判断一个数是不是回文数&quot;&quot;&quot;    temp = num    total = 0    while temp &gt; 0:        total = total * 10 + temp % 10        temp //= 10    return total == num</code></pre><h4 id="练习3实现判断一个数是不是素数的函数"><a class="anchor" href="#练习3实现判断一个数是不是素数的函数">#</a> 练习 3：实现判断一个数是不是素数的函数。</h4><p>参考答案：</p><pre><code class="language-Python">def is_prime(num):    &quot;&quot;&quot;判断一个数是不是素数&quot;&quot;&quot;    for factor in range(2, int(num ** 0.5) + 1):        if num % factor == 0:            return False    return True if num != 1 else False</code></pre><h4 id="练习4写一个程序判断输入的正整数是不是回文素数"><a class="anchor" href="#练习4写一个程序判断输入的正整数是不是回文素数">#</a> 练习 4：写一个程序判断输入的正整数是不是回文素数。</h4><p>参考答案：</p><pre><code class="language-Python">if __name__ == '__main__':    num = int(input('请输入正整数: '))    if is_palindrome(num) and is_prime(num):        print('%d是回文素数' % num)</code></pre><blockquote><p><strong>注意</strong>：通过上面的程序可以看出，当我们<strong>将代码中重复出现的和相对独立的功能抽取成函数</strong>后，我们可以<strong>组合使用这些函数</strong>来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。</p></blockquote><h3 id="变量的作用域"><a class="anchor" href="#变量的作用域">#</a> 变量的作用域</h3><p>最后，我们来讨论一下 Python 中有关变量作用域的问题。</p><pre><code class="language-Python">def foo():    b = 'hello'    # Python中可以在函数内部再定义函数    def bar():        c = True        print(a)        print(b)        print(c)    bar()    # print(c)  # NameError: name 'c' is not definedif __name__ == '__main__':    a = 100    # print(b)  # NameError: name 'b' is not defined    foo()</code></pre><p>上面的代码能够顺利的执行并且打印出 100、hello 和 True，但我们注意到了，在 <code>bar</code>  函数的内部并没有定义 <code>a</code>  和 <code>b</code>  两个变量，那么 <code>a</code>  和 <code>b</code>  是从哪里来的。我们在上面代码的 <code>if</code>  分支中定义了一个变量 <code>a</code> ，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的 <code>foo</code>  函数中我们定义了变量 <code>b</code> ，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在 <code>foo</code>  函数的外部并不能访问到它；但对于 <code>foo</code>  函数内部的 <code>bar</code>  函数来说，变量 <code>b</code>  属于嵌套作用域，在 <code>bar</code>  函数中我们是可以访问到它的。 <code>bar</code>  函数中的变量 <code>c</code>  属于局部作用域，在 <code>bar</code>  函数之外是无法访问的。事实上，Python 查找一个变量时会按照 “局部作用域”、“嵌套作用域”、“全局作用域” 和 “内置作用域” 的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的 “内置作用域” 就是 Python 内置的那些标识符，我们之前用过的 <code>input</code> 、 <code>print</code> 、 <code>int</code>  等都属于内置作用域。</p><p>再看看下面这段代码，我们希望通过函数调用修改全局变量 <code>a</code>  的值，但实际上下面的代码是做不到的。</p><pre><code class="language-Python">def foo():    a = 200    print(a)  # 200if __name__ == '__main__':    a = 100    foo()    print(a)  # 100</code></pre><p>在调用 <code>foo</code>  函数后，我们发现 <code>a</code>  的值仍然是 100，这是因为当我们在函数 <code>foo</code>  中写 <code>a = 200</code>  的时候，是重新定义了一个名字为 <code>a</code>  的局部变量，它跟全局作用域的 <code>a</code>  并不是同一个变量，因为局部作用域中有了自己的变量 <code>a</code> ，因此 <code>foo</code>  函数不再搜索全局作用域中的 <code>a</code> 。如果我们希望在 <code>foo</code>  函数中修改全局作用域中的 <code>a</code> ，代码如下所示。</p><pre><code class="language-Python">def foo():    global a    a = 200    print(a)  # 200if __name__ == '__main__':    a = 100    foo()    print(a)  # 200</code></pre><p>我们可以使用 <code>global</code>  关键字来指示 <code>foo</code>  函数中的变量 <code>a</code>  来自于全局作用域，如果全局作用域中没有 <code>a</code> ，那么下面一行的代码就会定义变量 <code>a</code>  并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用 <code>nonlocal</code>  关键字来指示变量来自于嵌套作用域，请大家自行试验。</p><p>在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlFJTgzJUU1JTlDJUJFJUU1JTlCJTlFJUU2JTk0JUI2XyglRTglQTglODglRTclQUUlOTclRTYlQTklOUYlRTclQTclOTElRTUlQUQlQjgp">垃圾回收</span>。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvJUU1JUJFJTk3JUU1JUEyJUE4JUU1JUJGJTkyJUU4JTgwJUIzJUU1JUFFJTlBJUU1JUJFJThC">迪米特法则</span>的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以使用它的值，这时候就需要使用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTk3JUFEJUU1JThDJTg1XyglRTglQUUlQTElRTclQUUlOTclRTYlOUMlQkElRTclQTclOTElRTUlQUQlQTYp">闭包</span>，这个我们在后续的内容中进行讲解。</p><blockquote><p><strong>说明：</strong> 很多人经常会将 “闭包” 和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThDJUJGJUU1JTkwJThEJUU1JTg3JUJEJUU2JTk1JUIw"> “匿名函数”</span> 混为一谈，但实际上它们并不是一回事，如果想了解这个概念，可以看看<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv">维基百科</span>的解释或者<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tLw==">知乎</span>上对这个概念的讨论。</p></blockquote><p>说了那么多，其实结论很简单，从现在开始我们可以将 Python 代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。</p><pre><code class="language-Python">def main():    # Todo: Add your code here    passif __name__ == '__main__':    main()</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造程序逻辑</title>
      <link href="/computer-science/python/basic/05.%E6%9E%84%E9%80%A0%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91/"/>
      <url>/computer-science/python/basic/05.%E6%9E%84%E9%80%A0%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="构造程序逻辑"><a class="anchor" href="#构造程序逻辑">#</a> 构造程序逻辑</h2><p>学完前面的几个章节后，我觉得有必要在这里带大家做一些练习来巩固之前所学的知识，虽然迄今为止我们学习的内容只是 Python 的冰山一角，但是这些内容已经足够我们来构建程序中的逻辑。对于编程语言的初学者来说，在学习了 Python 的核心语言元素（变量、类型、运算符、表达式、分支结构、循环结构等）之后，必须做的一件事情就是尝试用所学知识去解决现实中的问题，换句话说就是锻炼自己把用人类自然语言描述的算法（解决问题的方法和步骤）翻译成 Python 代码的能力，而这件事情必须通过大量的练习才能达成。</p><p>我们在本章为大家整理了一些经典的案例和习题，希望通过这些例子，一方面帮助大家巩固之前所学的 Python 知识，另一方面帮助大家了解如何建立程序中的逻辑以及如何运用一些简单的算法解决现实中的问题。</p><h3 id="经典的例子"><a class="anchor" href="#经典的例子">#</a> 经典的例子</h3><ol><li><p>寻找<strong>水仙花数</strong>。</p><blockquote><p><strong>说明</strong>：水仙花数也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个 3 位数，该数字每个位上数字的立方之和正好等于它本身，例如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mn>3</mn></msup><mo>+</mo><msup><mn>5</mn><mn>3</mn></msup><mo>+</mo><msup><mn>3</mn><mn>3</mn></msup><mo>=</mo><mn>153</mn></mrow><annotation encoding="application/x-tex">1^3 + 5^3+ 3^3=153</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">3</span></span></span></span>。</p></blockquote><pre><code class="language-Python">&quot;&quot;&quot;找出所有水仙花数Version: 0.1Author: 骆昊&quot;&quot;&quot;for num in range(100, 1000):    low = num % 10    mid = num // 10 % 10    high = num // 100    if num == low ** 3 + mid ** 3 + high ** 3:        print(num)</code></pre><p>在上面的代码中，我们通过整除和求模运算分别找出了一个三位数的个位、十位和百位，这种小技巧在实际开发中还是常用的。用类似的方法，我们还可以实现将一个正整数反转，例如：将 12345 变成 54321，代码如下所示。</p><pre><code class="language-Python">&quot;&quot;&quot;正整数的反转Version: 0.1Author: 骆昊&quot;&quot;&quot;num = int(input('num = '))reversed_num = 0while num &gt; 0:    reversed_num = reversed_num * 10 + num % 10    num //= 10print(reversed_num)</code></pre></li><li><p><strong>百钱百鸡</strong>问题。</p><blockquote><p><strong>说明</strong>：百钱百鸡是我国古代数学家<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkMlQTAlRTQlQjglOTglRTUlQkIlQkEvMTAyNDYyMzg=">张丘建</span>在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：公鸡 5 元一只，母鸡 3 元一只，小鸡 1 元三只，用 100 块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？</p></blockquote><pre><code class="language-Python">&quot;&quot;&quot;《百钱百鸡》问题Version: 0.1Author: 骆昊&quot;&quot;&quot;for x in range(0, 20):    for y in range(0, 33):        z = 100 - x - y        if 5 * x + 3 * y + z / 3 == 100:            print('公鸡: %d只, 母鸡: %d只, 小鸡: %d只' % (x, y, z))</code></pre><p>上面使用的方法叫做<strong>穷举法</strong>，也称为<strong>暴力搜索法</strong>，这种方法通过一项一项的列举备选解决方案中所有可能的候选项并检查每个候选项是否符合问题的描述，最终得到问题的解。这种方法看起来比较笨拙，但对于运算能力非常强大的计算机来说，通常都是一个可行的甚至是不错的选择，而且问题的解如果存在，这种方法一定能够找到它。</p></li><li><p><strong>CRAPS 赌博游戏</strong>。</p><blockquote><p><strong>说明</strong>：CRAPS 又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简单的规则是：玩家第一次摇骰子如果摇出了 7 点或 11 点，玩家胜；玩家第一次如果摇出 2 点、3 点或 12 点，庄家胜；其他点数玩家继续摇骰子，如果玩家摇出了 7 点，庄家胜；如果玩家摇出了第一次摇的点数，玩家胜；其他点数，玩家继续要骰子，直到分出胜负。</p></blockquote><pre><code class="language-Python">&quot;&quot;&quot;Craps赌博游戏我们设定玩家开始游戏时有1000元的赌注游戏结束的条件是玩家输光所有的赌注Version: 0.1Author: 骆昊&quot;&quot;&quot;from random import randintmoney = 1000while money &gt; 0:    print('你的总资产为:', money)    needs_go_on = False    while True:        debt = int(input('请下注: '))        if 0 &lt; debt &lt;= money:            break    first = randint(1, 6) + randint(1, 6)    print('玩家摇出了%d点' % first)    if first == 7 or first == 11:        print('玩家胜!')        money += debt    elif first == 2 or first == 3 or first == 12:        print('庄家胜!')        money -= debt    else:        needs_go_on = True    while needs_go_on:        needs_go_on = False        current = randint(1, 6) + randint(1, 6)        print('玩家摇出了%d点' % current)        if current == 7:            print('庄家胜')            money -= debt        elif current == first:            print('玩家胜')            money += debt        else:            needs_go_on = Trueprint('你破产了, 游戏结束!')</code></pre></li></ol><p>### 有用的练习</p><ol><li><p>生成<strong>斐波那契数列</strong>的前 20 个数。</p><blockquote><p><strong>说明</strong>：斐波那契数列（Fibonacci sequence），又称黄金分割数列，是意大利数学家莱昂纳多・斐波那契（Leonardoda Fibonacci）在《计算之书》中提出一个在理想假设条件下兔子成长率的问题而引入的数列，所以这个数列也被戏称为 &quot;兔子数列&quot;。斐波那契数列的特点是数列的前两个数都是 1，从第三个数开始，每个数都是它前面两个数的和，形如：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...。斐波那契数列在现代物理、准晶体结构、化学等领域都有直接的应用。</p></blockquote></li><li><p>找出 10000 以内的<strong>完美数</strong>。</p><blockquote><p><strong>说明</strong>：完美数又称为完全数或完备数，它的所有的真因子（即除了自身以外的因子）的和（即因子函数）恰好等于它本身。例如：6（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">6=1+2+3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>）和 28（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>28</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">28=1+2+4+7+14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span>）就是完美数。完美数有很多神奇的特性，有兴趣的可以自行了解。</p></blockquote></li><li><p>输出<strong> 100 以内所有的素数</strong>。</p><blockquote><p><strong>说明</strong>：素数指的是只能被 1 和自身整除的正整数（不包括 1）。</p></blockquote></li></ol><p>上面练习的参考答案在本章对应的代码目录中，如果需要帮助请读者自行查看参考答案。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环结构</title>
      <link href="/computer-science/python/basic/04.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/computer-science/python/basic/04.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="循环结构"><a class="anchor" href="#循环结构">#</a> 循环结构</h2><h3 id="应用场景"><a class="anchor" href="#应用场景">#</a> 应用场景</h3><p>我们在写程序的时候，一定会遇到需要重复执行某条或某些指令的场景。例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向移动的指令。在这个场景中，让机器人向球门方向移动就是一个需要重复的动作，当然这里还会用到上一课讲的分支结构来判断机器人是否持球以及是否进入射门范围。再举一个简单的例子，如果要实现每隔 1 秒中在屏幕上打印一次 “hello, world” 并持续打印一个小时，我们肯定不能够直接把 <code>print('hello, world')</code>  这句代码写 3600 遍，这里同样需要循环结构。</p><p>循环结构就是程序中控制某条或某些指令重复执行的结构。在 Python 中构造循环结构有两种做法，一种是 <code>for-in</code>  循环，一种是 <code>while</code>  循环。</p><h3 id="for-in循环"><a class="anchor" href="#for-in循环">#</a> for-in 循环</h3><p>如果明确的知道循环执行的次数或者要对一个容器进行迭代（后面会讲到），那么我们推荐使用 <code>for-in</code>  循环，例如下面代码中计算 1~100 求和的结果（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mn>100</mn></munderover><mi>n</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \sum \limits_{n=1}^{100}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.068226em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>）。</p><pre><code class="language-Python">&quot;&quot;&quot;用for循环实现1~100求和Version: 0.1Author: 骆昊&quot;&quot;&quot;sum = 0for x in range(101):    sum += xprint(sum)</code></pre><p>需要说明的是上面代码中的 <code>range(1, 101)</code>  可以用来构造一个从 1 到 100 的范围，当我们把这样一个范围放到 <code>for-in</code>  循环中，就可以通过前面的循环变量 <code>x</code>  依次取出从 1 到 100 的整数。当然， <code>range</code>  的用法非常灵活，下面给出了一个例子：</p><ul><li><code>range(101)</code> ：可以用来产生 0 到 100 范围的整数，需要注意的是取不到 101。</li><li><code>range(1, 101)</code> ：可以用来产生 1 到 100 范围的整数，相当于前面是闭区间后面是开区间。</li><li><code>range(1, 101, 2)</code> ：可以用来产生 1 到 100 的奇数，其中 2 是步长，即每次数值递增的值。</li><li><code>range(100, 0, -2)</code> ：可以用来产生 100 到 1 的偶数，其中 - 2 是步长，即每次数字递减的值。</li></ul><p>知道了这一点，我们可以用下面的代码来实现 1~100 之间的偶数求和。</p><pre><code class="language-Python">&quot;&quot;&quot;用for循环实现1~100之间的偶数求和Version: 0.1Author: 骆昊&quot;&quot;&quot;sum = 0for x in range(2, 101, 2):    sum += xprint(sum)</code></pre><p>当然，也可以通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示。</p><pre><code class="language-Python">&quot;&quot;&quot;用for循环实现1~100之间的偶数求和Version: 0.1Author: 骆昊&quot;&quot;&quot;sum = 0for x in range(1, 101):    if x % 2 == 0:        sum += xprint(sum)</code></pre><blockquote><p><strong>说明</strong>：相较于上面直接跳过奇数的做法，下面这种做法很明显并不是很好的选择。</p></blockquote><h3 id="while循环"><a class="anchor" href="#while循环">#</a> while 循环</h3><p>如果要构造不知道具体循环次数的循环结构，我们推荐使用 <code>while</code>  循环。 <code>while</code>  循环通过一个能够产生或转换出 <code>bool</code>  值的表达式来控制循环，表达式的值为 <code>True</code>  则继续循环；表达式的值为 <code>False</code>  则结束循环。</p><p>下面我们通过一个 “猜数字” 的小游戏来看看如何使用 <code>while</code>  循环。猜数字游戏的规则是：计算机出一个 1 到 100 之间的随机数，玩家输入自己猜的数字，计算机给出对应的提示信息（大一点、小一点或猜对了），如果玩家猜中了数字，计算机提示用户一共猜了多少次，游戏结束，否则游戏继续。</p><pre><code class="language-Python">&quot;&quot;&quot;猜数字游戏Version: 0.1Author: 骆昊&quot;&quot;&quot;import randomanswer = random.randint(1, 100)counter = 0while True:    counter += 1    number = int(input('请输入: '))    if number &lt; answer:        print('大一点')    elif number &gt; answer:        print('小一点')    else:        print('恭喜你猜对了!')        breakprint('你总共猜了%d次' % counter)if counter &gt; 7:    print('你的智商余额明显不足')</code></pre><p>上面的代码中使用了 <code>break</code>  关键字来提前终止循环，需要注意的是 <code>break</code>  只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了 <code>break</code>  之外，还有另一个关键字是 <code>continue</code> ，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。</p><p>和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。</p><pre><code class="language-Python">&quot;&quot;&quot;输出乘法口诀表(九九表)Version: 0.1Author: 骆昊&quot;&quot;&quot;for i in range(1, 10):    for j in range(1, i + 1):        print('%d*%d=%d' % (i, j, i * j), end='\t')    print()</code></pre><h3 id="练习"><a class="anchor" href="#练习">#</a> 练习</h3><h4 id="练习1输入一个正整数判断是不是素数"><a class="anchor" href="#练习1输入一个正整数判断是不是素数">#</a> 练习 1：输入一个正整数判断是不是素数。</h4><blockquote><p><strong>提示</strong>：素数指的是只能被 1 和自身整除的大于 1 的整数。</p></blockquote><p>参考答案：</p><pre><code class="language-Python">&quot;&quot;&quot;输入一个正整数判断它是不是素数Version: 0.1Author: 骆昊Date: 2018-03-01&quot;&quot;&quot;from math import sqrtnum = int(input('请输入一个正整数: '))end = int(sqrt(num))is_prime = Truefor x in range(2, end + 1):    if num % x == 0:        is_prime = False        breakif is_prime and num != 1:    print('%d是素数' % num)else:    print('%d不是素数' % num)</code></pre><h4 id="练习2输入两个正整数计算它们的最大公约数和最小公倍数"><a class="anchor" href="#练习2输入两个正整数计算它们的最大公约数和最小公倍数">#</a> 练习 2：输入两个正整数，计算它们的最大公约数和最小公倍数。</h4><blockquote><p><strong>提示</strong>：两个数的最大公约数是两个数的公共因子中最大的那个数；两个数的最小公倍数则是能够同时被两个数整除的最小的那个数。</p></blockquote><p>参考答案：</p><pre><code class="language-Python">&quot;&quot;&quot;输入两个正整数计算它们的最大公约数和最小公倍数Version: 0.1Author: 骆昊Date: 2018-03-01&quot;&quot;&quot;x = int(input('x = '))y = int(input('y = '))# 如果x大于y就交换x和y的值if x &gt; y:    # 通过下面的操作将y的值赋给x, 将x的值赋给y    x, y = y, x# 从两个数中较小的数开始做递减的循环for factor in range(x, 0, -1):    if x % factor == 0 and y % factor == 0:        print('%d和%d的最大公约数是%d' % (x, y, factor))        print('%d和%d的最小公倍数是%d' % (x, y, x * y // factor))        break</code></pre><h4 id="练习3打印如下所示的三角形图案"><a class="anchor" href="#练习3打印如下所示的三角形图案">#</a> 练习 3：打印如下所示的三角形图案。</h4><pre><code>***************</code></pre><pre><code>    *   **  *** *********</code></pre><pre><code>    *   ***  ***** ****************</code></pre><p>参考答案：</p><pre><code class="language-Python">&quot;&quot;&quot;打印三角形图案Version: 0.1Author: 骆昊&quot;&quot;&quot;row = int(input('请输入行数: '))for i in range(row):    for _ in range(i + 1):        print('*', end='')    print()for i in range(row):    for j in range(row):        if j &lt; row - i - 1:            print(' ', end='')        else:            print('*', end='')    print()for i in range(row):    for _ in range(row - i - 1):        print(' ', end='')    for _ in range(2 * i + 1):        print('*', end='')    print()</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分支结构</title>
      <link href="/computer-science/python/basic/03.%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"/>
      <url>/computer-science/python/basic/03.%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="分支结构"><a class="anchor" href="#分支结构">#</a> 分支结构</h2><h3 id="应用场景"><a class="anchor" href="#应用场景">#</a> 应用场景</h3><p>迄今为止，我们写的 Python 代码都是一条一条语句顺序执行，这种代码结构通常称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得 1000 分，那么在完成本局游戏后，我们要根据玩家得到分数来决定究竟是进入第二关，还是告诉玩家 “Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行。类似的场景还有很多，我们将这种结构称之为 “分支结构” 或 “选择结构”。给大家一分钟的时间，你应该可以想到至少 5 个以上这样的例子，赶紧试一试。</p><h3 id="if语句的使用"><a class="anchor" href="#if语句的使用">#</a> if 语句的使用</h3><p>在 Python 中，要构造分支结构可以使用 <code>if</code> 、 <code>elif</code>  和 <code>else</code>  关键字。所谓<strong>关键字</strong>就是有特殊含义的单词，像 <code>if</code>  和 <code>else</code>  就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。</p><pre><code class="language-Python">&quot;&quot;&quot;用户身份验证Version: 0.1Author: 骆昊&quot;&quot;&quot;username = input('请输入用户名: ')password = input('请输入口令: ')# 用户名是admin且密码是123456则身份验证成功否则身份验证失败if username == 'admin' and password == '123456':    print('身份验证成功!')else:    print('身份验证失败!')</code></pre><p>需要说明的是和 C/C++、Java 等语言不同，Python 中没有用花括号来构造代码块而是<strong>使用了缩进的方式来表示代码的层次结构</strong>，如果 <code>if</code>  条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。换句话说<strong>连续的代码如果又保持了相同的缩进那么它们属于同一个代码块</strong>，相当于是一个执行的整体。<strong>缩进</strong>可以使用任意数量的空格，但<strong>通常使用 4 个空格</strong>，建议大家<strong>不要使用制表键</strong>或者<strong>设置你的代码编辑工具自动将制表键变成 4 个空格</strong>。</p><p>当然如果要构造出更多的分支，可以使用 <code>if...elif...else...</code>  结构或者嵌套的 <code>if...else...</code>  结构，下面的代码演示了如何利用多分支结构实现分段函数求值。</p><p><img data-src="./res/formula_1.png" alt="$$f(x)=\begin{cases} 3x-5&amp;\text{(x&gt;1)}\x+2&amp;\text{(-1}\leq\text{x}\leq\text{1)}\5x+3&amp;\text {(x&lt;-1)}\end{cases}$$" /></p><pre><code class="language-Python">&quot;&quot;&quot;分段函数求值        3x - 5  (x &gt; 1)f(x) =  x + 2   (-1 &lt;= x &lt;= 1)        5x + 3  (x &lt; -1)Version: 0.1Author: 骆昊&quot;&quot;&quot;x = float(input('x = '))if x &gt; 1:    y = 3 * x - 5elif x &gt;= -1:    y = x + 2else:    y = 5 * x + 3print('f(%.2f) = %.2f' % (x, y))</code></pre><p>当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在 <code>if</code>  的内部构造出一个新的分支结构，同理 <code>elif</code>  和 <code>else</code>  中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。</p><pre><code class="language-Python">&quot;&quot;&quot;分段函数求值3x - 5(x &gt; 1)f(x) =x + 2(-1 &lt;= x &lt;= 1)5x + 3(x &lt; -1)Version: 0.1Author: 骆昊&quot;&quot;&quot;x = float(input('x = '))if x &gt; 1:    y = 3 * x - 5else:    if x &gt;= -1:        y = x + 2    else:        y = 5 * x + 3print('f(%.2f) = %.2f' % (x, y))</code></pre><blockquote><p><strong>说明：</strong> 大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的 Python 之禅中有这么一句话 “Flat is better than nested.”，之所以提倡代码 “扁平化” 是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，所以能使用扁平化的结构时就不要使用嵌套。</p></blockquote><h3 id="练习"><a class="anchor" href="#练习">#</a> 练习</h3><h4 id="练习1英制单位英寸与公制单位厘米互换"><a class="anchor" href="#练习1英制单位英寸与公制单位厘米互换">#</a> 练习 1：英制单位英寸与公制单位厘米互换。</h4><p>参考答案：</p><pre><code class="language-Python">&quot;&quot;&quot;英制单位英寸和公制单位厘米互换Version: 0.1Author: 骆昊&quot;&quot;&quot;value = float(input('请输入长度: '))unit = input('请输入单位: ')if unit == 'in' or unit == '英寸':    print('%f英寸 = %f厘米' % (value, value * 2.54))elif unit == 'cm' or unit == '厘米':    print('%f厘米 = %f英寸' % (value, value / 2.54))else:    print('请输入有效的单位')</code></pre><h4 id="练习2百分制成绩转换为等级制成绩"><a class="anchor" href="#练习2百分制成绩转换为等级制成绩">#</a> 练习 2：百分制成绩转换为等级制成绩。</h4><blockquote><p><strong>要求</strong>：如果输入的成绩在 90 分以上（含 90 分）输出 A；80 分 - 90 分（不含 90 分）输出 B；70 分 - 80 分（不含 80 分）输出 C；60 分 - 70 分（不含 70 分）输出 D；60 分以下输出 E。</p></blockquote><p>参考答案：</p><pre><code class="language-Python">&quot;&quot;&quot;百分制成绩转换为等级制成绩Version: 0.1Author: 骆昊&quot;&quot;&quot;score = float(input('请输入成绩: '))if score &gt;= 90:    grade = 'A'elif score &gt;= 80:    grade = 'B'elif score &gt;= 70:    grade = 'C'elif score &gt;= 60:    grade = 'D'else:    grade = 'E'print('对应的等级是:', grade)</code></pre><h4 id="练习3输入三条边长如果能构成三角形就计算周长和面积"><a class="anchor" href="#练习3输入三条边长如果能构成三角形就计算周长和面积">#</a> 练习 3：输入三条边长，如果能构成三角形就计算周长和面积。</h4><p>参考答案：</p><pre><code class="language-Python">&quot;&quot;&quot;判断输入的边长能否构成三角形，如果能则计算出三角形的周长和面积Version: 0.1Author: 骆昊&quot;&quot;&quot;a = float(input('a = '))b = float(input('b = '))c = float(input('c = '))if a + b &gt; c and a + c &gt; b and b + c &gt; a:    print('周长: %f' % (a + b + c))    p = (a + b + c) / 2    area = (p * (p - a) * (p - b) * (p - c)) ** 0.5    print('面积: %f' % (area))else:    print('不能构成三角形')</code></pre><blockquote><p><strong>说明：</strong> 上面使用的通过边长计算三角形面积的公式叫做<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvJUU2JUI1JUI3JUU0JUJDJUE2JUU1JTg1JUFDJUU1JUJDJThG">海伦公式</span>。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL入门</title>
      <link href="/computer-science/python/basic/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"/>
      <url>/computer-science/python/basic/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="nosql入门"><a class="anchor" href="#nosql入门">#</a> NoSQL 入门</h2><h3 id="nosql概述"><a class="anchor" href="#nosql概述">#</a> NoSQL 概述</h3><p>如今，大多数的计算机系统（包括服务器、PC、移动设备等）都会产生庞大的数据量。其实，早在 2012 年的时候，全世界每天产生的数据量就达到了 2.5EB（艾字节，$$1EB\approx10^{18} B$$）。这些数据有很大一部分是由关系型数据库来存储和管理的。 早在 1970 年，E.F.Codd 发表了论述关系型数据库的著名论文 “<em>A relational model of data for large shared data banks</em>”，这篇文章奠定了关系型数据库的基础并在接下来的数十年时间内产生了深远的影响。实践证明，关系型数据库是实现数据持久化最为重要的方式，它也是大多数应用在选择持久化方案时的首选技术。</p><p>NoSQL 是一项全新的数据库革命性运动，虽然它的历史可以追溯到 1998 年，但是 NoSQL 真正深入人心并得到广泛的应用是在进入大数据时候以后，业界普遍认为 NoSQL 是更适合大数据存储的技术方案，这才使得 NoSQL 的发展达到了前所未有的高度。2012 年《纽约时报》的一篇专栏中写到，大数据时代已经降临，在商业、经济及其他领域中，决策将不再基于经验和直觉而是基于数据和分析而作出。事实上，在天文学、气象学、基因组学、生物学、社会学、互联网搜索引擎、金融、医疗、社交网络、电子商务等诸多领域，由于数据过于密集和庞大，在数据的分析和处理上也遇到了前所未有的限制和阻碍，这一切都使得对大数据处理技术的研究被提升到了新的高度，也使得各种 NoSQL 的技术方案进入到了公众的视野。</p><p>NoSQL 数据库按照其存储类型可以大致分为以下几类：</p><table><thead><tr><th>类型</th><th>部分代表</th><th>特点</th></tr></thead><tbody><tr><td>列族数据库</td><td>HBase&lt;br&gt;Cassandra&lt;br&gt;Hypertable</td><td>顾名思义是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的 I/O 优势，适合于批量数据处理和即时查询。</td></tr><tr><td>文档数据库</td><td>MongoDB&lt;br&gt;CouchDB&lt;br&gt;ElasticSearch</td><td>文档数据库一般用类 JSON 格式存储数据，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能，但不提供对参照完整性和分布事务的支持。</td></tr><tr><td>KV 数据库</td><td>DynamoDB&lt;br&gt;Redis&lt;br&gt;LevelDB</td><td>可以通过 key 快速查询到其 value，有基于内存和基于磁盘两种实现方案。</td></tr><tr><td>图数据库</td><td>Neo4J&lt;br&gt;FlockDB&lt;br&gt;JanusGraph</td><td>使用图结构进行语义查询的数据库，它使用节点、边和属性来表示和存储数据。图数据库从设计上，就可以简单快速的检索难以在关系系统中建模的复杂层次结构。</td></tr><tr><td>对象数据库</td><td>db4o&lt;br&gt;Versant</td><td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。</td></tr></tbody></table><blockquote><p><strong>说明</strong>：想了解更多的 NoSQL 数据库，可以访问<span class="exturl" data-url="aHR0cDovL25vc3FsLWRhdGFiYXNlLm9yZy8="> http://nosql-database.org/</span>。</p></blockquote><h3 id="redis概述"><a class="anchor" href="#redis概述">#</a> Redis 概述</h3><p>Redis 是一种基于键值对的 NoSQL 数据库，它提供了对多种数据类型（字符串、哈希、列表、集合、有序集合、位图等）的支持，能够满足很多应用场景的需求。Redis 将数据放在内存中，因此读写性能是非常惊人的。与此同时，Redis 也提供了持久化机制，能够将内存中的数据保存到硬盘上，在发生意外状况时数据也不会丢掉。此外，Redis 还支持键过期、地理信息运算、发布订阅、事务、管道、Lua 脚本扩展等功能，总而言之，Redis 的功能和性能都非常强大，如果项目中要实现高速缓存和消息队列这样的服务，直接交给 Redis 就可以了。目前，国内外很多著名的企业和商业项目都使用了 Redis，包括：Twitter、Github、StackOverflow、新浪微博、百度、优酷土豆、美团、小米、唯品会等。</p><h4 id="redis简介"><a class="anchor" href="#redis简介">#</a> Redis 简介</h4><p>2008 年，一个名为 Salvatore Sanfilippo 的程序员为他开发的 LLOOGG 项目定制了专属的数据库（因为之前他无论怎样优化 MySQL，系统性能已经无法再提升了），这项工作的成果就是 Redis 的初始版本。后来他将 Redis 的代码放到了全球最大的代码托管平台<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FudGlyZXovcmVkaXM="> Github</span>，从那以后，Redis 引发了大量开发者的好评和关注，继而有数百人参与了 Redis 的开发和维护，这使得 Redis 的功能越来越强大和性能越来越好。</p><p>Redis 是 REmote DIctionary Server 的缩写，它是一个用 ANSI C 编写的高性能的 key-value 存储系统，与其他的 key-value 存储系统相比，Redis 有以下一些特点（也是优点）：</p><ul><li>Redis 的读写性能极高，并且有丰富的特性（发布 / 订阅、事务、通知等）。</li><li>Redis 支持数据的持久化（RDB 和 AOF 两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis 支持多种数据类型，包括：string、hash、list、set，zset、bitmap、hyperloglog 等。</li><li>Redis 支持主从复制（实现读写分析）以及哨兵模式（监控 master 是否宕机并自动调整配置）。</li><li>Redis 支持分布式集群，可以很容易的通过水平扩展来提升系统的整体性能。</li><li>Redis 基于 TCP 提供的可靠传输服务进行通信，很多编程语言都提供了 Redis 客户端支持。</li></ul><h4 id="redis的应用场景"><a class="anchor" href="#redis的应用场景">#</a> Redis 的应用场景</h4><ol><li>高速缓存  - 将不常变化但又经常被访问的热点数据放到 Redis 数据库中，可以大大降低关系型数据库的压力，从而提升系统的响应性能。</li><li>排行榜 - 很多网站都有排行榜功能，利用 Redis 中的列表和有序集合可以非常方便的构造各种排行榜系统。</li><li>商品秒杀 / 投票点赞 - Redis 提供了对计数操作的支持，网站上常见的秒杀、点赞等功能都可以利用 Redis 的计数器通过 + 1 或 - 1 的操作来实现，从而避免了使用关系型数据的 <code>update</code>  操作。</li><li>分布式锁 - 利用 Redis 可以跨多台服务器实现分布式锁（类似于线程锁，但是能够被多台机器上的多个线程或进程共享）的功能，用于实现一个阻塞式操作。</li><li>消息队列 - 消息队列和高速缓存一样，是一个大型网站不可缺少的基础服务，可以实现业务解耦和非实时业务削峰等特性，这些我们都会在后面的项目中为大家展示。</li></ol><h4 id="redis的安装和配置"><a class="anchor" href="#redis的安装和配置">#</a> Redis 的安装和配置</h4><p>可以使用 Linux 系统的包管理工具（如 yum）来安装 Redis，也可以通过在 Redis 的<span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby8=">官方网站</span>下载 Redis 的源代码，解压缩解归档之后通过 make 工具对源代码进行构建并安装，在更新这篇文档时，Redis 官方提供的最新稳定版本是<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5yZWRpcy5pby9yZWxlYXNlcy9yZWRpcy01LjAuMTAudGFyLmd6"> Redis 5.0.10</span>。</p><p>下载：</p><pre><code class="language-Bash">wget https://download.redis.io/releases/redis-5.0.10.tar.gz</code></pre><p>解压缩和解归档：</p><pre><code class="language-Bash">tar -zxf redis-5.0.10.tar.gz</code></pre><p>进入 Redis 源代码目录：</p><pre><code class="language-Bash">cd redis-5.0.10</code></pre><p>构建和安装：</p><pre><code class="language-Bash">make &amp;&amp; make install</code></pre><p>在 redis 源代码目录下有一个名为 redis.conf 的配置文件，我们可以先查看一下该文件。</p><pre><code class="language-Bash">vim redis.conf</code></pre><p>下面我们对 Redis 的配置文件进行一个扼要的介绍。</p><p>配置 Redis 服务的 IP 地址和端口：</p><p><img data-src="./res/redis-bind-and-port.png" alt="" /></p><p>配置底层有多少个数据库：</p><p><img data-src="./res/redis-databases.png" alt="" /></p><p>配置 Redis 的持久化机制 - RDB。</p><p><img data-src="./res/redis-rdb-1.png" alt="" /></p><p><img data-src="./res/redis-rdb-3.png" alt="" /></p><p>配置 Redis 的持久化机制 - AOF：</p><p><img data-src="./res/redis-aof.png" alt="" /></p><p>配置访问 Redis 服务器的口令：</p><p><img data-src="./res/redis-security.png" alt="" /></p><p>配置 Redis 的主从复制（通过主从复制可以实现读写分离）：</p><p><img data-src="./res/redis-replication.png" alt="" /></p><p>配置慢查询：</p><p><img data-src="./res/redis-slow-logs.png" alt="" /></p><p>上面这些内容就是 Redis 的基本配置，如果你对上面的内容感到困惑也没有关系，先把 Redis 用起来再回头去推敲这些内容就行了。如果想找一些参考书，<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMjEyMTczMC5odG1s">《Redis 开发与运维》</span>是一本不错的入门读物，而<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMTc5MTYwNy5odG1s">《Redis 实战》</span>是不错的进阶读物。</p><h4 id="redis的服务器和客户端"><a class="anchor" href="#redis的服务器和客户端">#</a> Redis 的服务器和客户端</h4><p>接下来启动 Redis 服务器，下面的方式将以默认的配置启动 Redis 服务。</p><pre><code class="language-Bash">redis-server</code></pre><p>如果希望修改 Redis 的配置（如端口、认证口令、持久化方式等），可以通过下面两种方式。</p><p><strong>方式一</strong>：通过参数指定认证口令和 AOF 持久化方式。</p><pre><code class="language-Bash">redis-server --requirepass yourpass --appendonly yes</code></pre><p><strong>方式二</strong>：通过指定的配置文件来修改 Redis 的配置。</p><pre><code class="language-Bash">redis-server /root/redis-5.0.10/redis.conf</code></pre><p>下面我们使用第一种方式来启动 Redis 并将其置于后台运行，将 Redis 产生的输出重定向到名为 redis.log 的文件中。</p><pre><code class="language-Bash">redis-server --requirepass yourpass &gt; redis.log &amp;</code></pre><p>可以通过 <code>ps</code>  或者 <code>netstat</code>  来检查 Redis 服务器是否启动成功。</p><pre><code class="language-Bash">ps -ef | grep redis-servernetstat -nap | grep redis-server</code></pre><p>接下来，我们尝试用 Redis 命令行工具 <code>redis-cli</code>  去连接服务器，该工具默认连接本机的 <code>6379</code>  端口，如果需要指定 Redis 服务器和端口，可以使用 <code>-h</code>  和 <code>-p</code>  参数分别进行指定。</p><pre><code class="language-Bash">redis-cli</code></pre><p>进入命令行工具后，就可以通过 Redis 的命令来操作 Redis 服务器，如下所示。</p><pre><code class="language-Bash">127.0.0.1:6379&gt; auth yourpassOK127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt;</code></pre><p>Redis 有着非常丰富的数据类型，也有很多的命令来操作这些数据，具体的内容可以查看<span class="exturl" data-url="aHR0cDovL3JlZGlzZG9jLmNvbS8="> Redis 命令参考</span>，在这个网站上，除了 Redis 的命令参考，还有 Redis 的详细文档，其中包括了通知、事务、主从复制、持久化、哨兵、集群等内容。</p><p><img data-src="./res/redis-data-types.png" alt="" /></p><blockquote><p><strong>说明</strong>：上面的插图来自付磊和张益军编著的《Redis 开发与运维》一书。</p></blockquote><pre><code class="language-Bash">127.0.0.1:6379&gt; set username adminOK127.0.0.1:6379&gt; get username&quot;admin&quot;127.0.0.1:6379&gt; set password &quot;123456&quot; ex 300OK127.0.0.1:6379&gt; get password&quot;123456&quot;127.0.0.1:6379&gt; ttl username(integer) -1127.0.0.1:6379&gt; ttl password(integer) 286127.0.0.1:6379&gt; hset stu1 name hao(integer) 0127.0.0.1:6379&gt; hset stu1 age 38(integer) 1127.0.0.1:6379&gt; hset stu1 gender male(integer) 1127.0.0.1:6379&gt; hgetall stu11) &quot;name&quot;2) &quot;hao&quot;3) &quot;age&quot;4) &quot;38&quot;5) &quot;gender&quot;6) &quot;male&quot;127.0.0.1:6379&gt; hvals stu11) &quot;hao&quot;2) &quot;38&quot;3) &quot;male&quot;127.0.0.1:6379&gt; hmset stu2 name wang age 18 gender female tel 13566778899OK127.0.0.1:6379&gt; hgetall stu21) &quot;name&quot;2) &quot;wang&quot;3) &quot;age&quot;4) &quot;18&quot;5) &quot;gender&quot;6) &quot;female&quot;7) &quot;tel&quot;8) &quot;13566778899&quot;127.0.0.1:6379&gt; lpush nums 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; lrange nums 0 -11) &quot;5&quot;2) &quot;4&quot;3) &quot;3&quot;4) &quot;2&quot;5) &quot;1&quot;127.0.0.1:6379&gt; lpop nums&quot;5&quot;127.0.0.1:6379&gt; lpop nums&quot;4&quot;127.0.0.1:6379&gt; rpop nums&quot;1&quot;127.0.0.1:6379&gt; rpop nums&quot;2&quot;127.0.0.1:6379&gt; sadd fruits apple banana orange apple grape grape(integer) 4127.0.0.1:6379&gt; scard fruits(integer) 4127.0.0.1:6379&gt; smembers fruits1) &quot;grape&quot;2) &quot;orange&quot;3) &quot;banana&quot;4) &quot;apple&quot;127.0.0.1:6379&gt; sismember fruits apple(integer) 1127.0.0.1:6379&gt; sismember fruits durian(integer) 0127.0.0.1:6379&gt; sadd nums1 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; sadd nums2 2 4 6 8(integer) 4127.0.0.1:6379&gt; sinter nums1 nums21) &quot;2&quot;2) &quot;4&quot;127.0.0.1:6379&gt; sunion nums1 nums21) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;5) &quot;5&quot;6) &quot;6&quot;7) &quot;8&quot;127.0.0.1:6379&gt; sdiff nums1 nums21) &quot;1&quot;2) &quot;3&quot;3) &quot;5&quot;127.0.0.1:6379&gt; zadd topsinger 5234 zhangxy 1978 chenyx 2235 zhoujl 3520 xuezq(integer) 4127.0.0.1:6379&gt; zrange topsinger 0 -1 withscores1) &quot;chenyx&quot;2) &quot;1978&quot;3) &quot;zhoujl&quot;4) &quot;2235&quot;5) &quot;xuezq&quot;6) &quot;3520&quot;7) &quot;zhangxy&quot;8) &quot;5234&quot;127.0.0.1:6379&gt; zrevrange topsinger 0 -11) &quot;zhangxy&quot;2) &quot;xuezq&quot;3) &quot;zhoujl&quot;4) &quot;chenyx&quot;127.0.0.1:6379&gt; zrevrank topsinger zhoujl(integer) 2127.0.0.1:6379&gt; geoadd pois 116.39738549206541 39.90862689286386 tiananmen(integer) 1127.0.0.1:6379&gt; geoadd pois 116.27172936413572 39.99135172904494 yiheyuan(integer) 1127.0.0.1:6379&gt; geoadd pois 117.27766503308104 40.65332064313784 gubeishuizhen(integer) 1127.0.0.1:6379&gt; geodist pois tiananmen gubeishuizhen km&quot;111.5333&quot;127.0.0.1:6379&gt; geodist pois tiananmen yiheyuan km&quot;14.1230&quot;127.0.0.1:6379&gt; georadius pois 116.86499108288572 40.40149669363615 50 km withdist1) 1) &quot;gubeishuizhen&quot;   2) &quot;44.7408&quot;</code></pre><h4 id="在python程序中使用redis"><a class="anchor" href="#在python程序中使用redis">#</a> 在 Python 程序中使用 Redis</h4><p>可以使用 pip 安装名为 <code>redis</code>  的三方库，该三方库的核心是一个名为 <code>Redis</code>  的类， <code>Redis</code>  对象代表一个 Redis 客户端，通过该客户端可以向 Redis 服务器发送命令并获取执行的结果。上面我们在 Redis 客户端中使用的命令基本上就是 <code>Redis</code>  对象可以接收的消息，所以如果了解了 Redis 的命令就可以在 Python 中玩转 Redis。</p><pre><code class="language-Bash">pip3 install redis</code></pre><p>进入 Python 交互式环境，使用 <code>redis</code>  三方库来操作 Redis。</p><pre><code class="language-Bash">&gt;&gt;&gt; import redis&gt;&gt;&gt;&gt;&gt;&gt; client = redis.Redis(host='127.0.0.1', port=6379, password='yourpass')&gt;&gt;&gt;&gt;&gt;&gt; client.set('username', 'admin')True&gt;&gt;&gt; client.hset('student', 'name', 'luohao')1&gt;&gt;&gt; client.hset('student', 'age', 40)1&gt;&gt;&gt; client.keys('*')[b'username', b'student']&gt;&gt;&gt; client.get('username')b'admin'&gt;&gt;&gt; client.hgetall('student')&#123;b'name': b'luohao', b'age': b'40'&#125;</code></pre><h3 id="mongodb概述"><a class="anchor" href="#mongodb概述">#</a> MongoDB 概述</h3><h4 id="mongodb简介"><a class="anchor" href="#mongodb简介">#</a> MongoDB 简介</h4><p>MongoDB 是 2009 年问世的一个面向文档的数据库管理系统，由 C++ 语言编写，旨在为 Web 应用提供可扩展的高性能数据存储解决方案。虽然在划分类别的时候后，MongoDB 被认为是 NoSQL 的产品，但是它更像一个介于关系数据库和非关系数据库之间的产品，在非关系数据库中它功能最丰富，最像关系数据库。</p><p>MongoDB 将数据存储为一个文档，一个文档由一系列的 “键值对” 组成，其文档类似于 JSON 对象，但是 MongoDB 对 JSON 进行了二进制处理（能够更快的定位 key 和 value），因此其文档的存储格式称为 BSON。关于 JSON 和 BSON 的差别大家可以看看 MongoDB 官方网站的文章<span class="exturl" data-url="aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vanNvbi1hbmQtYnNvbg==">《JSON and BSON》</span>。</p><p>目前，MongoDB 已经提供了对 Windows、macOS、Linux、Solaris 等多个平台的支持，而且也提供了多种开发语言的驱动程序，Python 当然是其中之一。</p><h4 id="mongodb的安装和启动"><a class="anchor" href="#mongodb的安装和启动">#</a> MongoDB 的安装和启动</h4><p>可以从 MongoDB 的<span class="exturl" data-url="aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vdHJ5L2Rvd25sb2FkL2NvbW11bml0eQ==">官方下载链接</span>下载 MongoDB，官方提供了 Windows、macOS 和多种 Linux 版本的安装包。下面以 CentOS 为例，简单说一下如何安装和启动 MongoDB。</p><p>下载服务器和命令行的 RPM 安装包。</p><pre><code class="language-Bash">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.4/x86_64/RPMS/mongodb-org-server-4.4.2-1.el7.x86_64.rpmrpm -ivh mongodb-org-server-4.4.2-1.el7.x86_64.rpmwget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.4/x86_64/RPMS/mongodb-org-shell-4.4.2-1.el7.x86_64.rpmrpm -ivh mongodb-org-shell-4.4.2-1.el7.x86_64.rpm</code></pre><p>启动 MongoDB 服务器，需要先创建保存数据的文件夹。</p><pre><code class="language-Bash">mkdir -p /data/db</code></pre><p>修改 MongoDB 的配置文件，将其中 <code>bindIp</code>  选项的值修改为本机 IP 地址而不是默认的 <code>127.0.0.1</code> ，本机 IP 地址可以通过 <code>ifconfig</code>  命令进行查看。</p><pre><code class="language-Bash">vim /etc/mongod.conf</code></pre><p>使用 <code>systemctl</code>  命令启动服务。</p><pre><code class="language-Bash">systemctl start mongod</code></pre><h4 id="mongodb基本概念"><a class="anchor" href="#mongodb基本概念">#</a> MongoDB 基本概念</h4><p>我们通过与关系型数据库的比较来说明 MongoDB 中的一些概念。</p><table><thead><tr><th>SQL</th><th>MongoDB</th></tr></thead><tbody><tr><td>database</td><td>database</td></tr><tr><td>table（表）</td><td>collection（集合）</td></tr><tr><td>row（行）</td><td>document（文档）</td></tr><tr><td>column（列）</td><td>field（字段）</td></tr><tr><td>index</td><td>index</td></tr><tr><td>table joins（表连接）</td><td>（嵌套文档）</td></tr><tr><td>primary key</td><td>primary key</td></tr></tbody></table><h4 id="通过shell操作mongodb"><a class="anchor" href="#通过shell操作mongodb">#</a> 通过 Shell 操作 MongoDB</h4><ol start="0"><li><p>启动命令行工具，进入交互式环境。</p><pre><code class="language-Bash">mongo</code></pre><blockquote><p><strong>说明</strong>：</p></blockquote></li><li><p>查看、创建和删除数据库。</p><pre><code class="language-JavaScript">&gt; // 显示所有数据库&gt; show dbsadmin   0.000GBconfig  0.000GBlocal   0.000GB&gt; // 创建并切换到school数据库&gt; use schoolswitched to db school&gt; // 删除当前数据库&gt; db.dropDatabase()&#123; &quot;ok&quot; : 1 &#125;</code></pre></li><li><p>创建、删除和查看集合。</p><pre><code class="language-JavaScript">&gt; // 创建并切换到school数据库&gt; use schoolswitched to db school&gt; // 创建colleges集合&gt; db.createCollection('colleges')&#123; &quot;ok&quot; : 1 &#125;&gt; // 创建students集合&gt; db.createCollection('students')&#123; &quot;ok&quot; : 1 &#125;&gt; // 查看所有集合&gt; show collectionscollegesstudents&gt; // 删除colleges集合&gt; db.colleges.drop()true</code></pre><blockquote><p><strong>说明</strong>：在 MongoDB 中插入文档时如果集合不存在会自动创建集合，所以也可以按照下面的方式通过插入文档来创建集合。</p></blockquote></li><li><p>文档的 CRUD 操作。</p><pre><code class="language-JavaScript">&gt; // 向students集合插入文档&gt; db.students.insert(&#123;stuid: 1001, name: '骆昊', age: 40&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; // 向students集合插入文档&gt; db.students.save(&#123;stuid: 1002, name: '王大锤', tel: '13012345678', gender: '男'&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; // 查看所有文档&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5b13c72e006ad854460ee70b&quot;), &quot;stuid&quot; : 1001, &quot;name&quot; : &quot;骆昊&quot;, &quot;age&quot; : 38 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b13c790006ad854460ee70c&quot;), &quot;stuid&quot; : 1002, &quot;name&quot; : &quot;王大锤&quot;, &quot;tel&quot; : &quot;13012345678&quot;, &quot;gender&quot; : &quot;男&quot; &#125;&gt; // 更新stuid为1001的文档&gt; db.students.update(&#123;stuid: 1001&#125;, &#123;'$set': &#123;tel: '13566778899', gender: '男'&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; // 插入或更新stuid为1003的文档&gt; db.students.update(&#123;stuid: 1003&#125;, &#123;'$set': &#123;name: '白元芳', tel: '13022223333', gender: '男'&#125;&#125;,  upsert=true)WriteResult(&#123;        &quot;nMatched&quot; : 0,        &quot;nUpserted&quot; : 1,        &quot;nModified&quot; : 0,        &quot;_id&quot; : ObjectId(&quot;5b13c92dd185894d7283efab&quot;)&#125;)&gt; // 查询所有文档&gt; db.students.find().pretty()&#123;        &quot;_id&quot; : ObjectId(&quot;5b13c72e006ad854460ee70b&quot;),        &quot;stuid&quot; : 1001,        &quot;name&quot; : &quot;骆昊&quot;,        &quot;age&quot; : 38,        &quot;gender&quot; : &quot;男&quot;,        &quot;tel&quot; : &quot;13566778899&quot;&#125;&#123;        &quot;_id&quot; : ObjectId(&quot;5b13c790006ad854460ee70c&quot;),        &quot;stuid&quot; : 1002,        &quot;name&quot; : &quot;王大锤&quot;,        &quot;tel&quot; : &quot;13012345678&quot;,        &quot;gender&quot; : &quot;男&quot;&#125;&#123;        &quot;_id&quot; : ObjectId(&quot;5b13c92dd185894d7283efab&quot;),        &quot;stuid&quot; : 1003,        &quot;gender&quot; : &quot;男&quot;,        &quot;name&quot; : &quot;白元芳&quot;,        &quot;tel&quot; : &quot;13022223333&quot;&#125;&gt; // 查询stuid大于1001的文档&gt; db.students.find(&#123;stuid: &#123;'$gt': 1001&#125;&#125;).pretty()&#123;        &quot;_id&quot; : ObjectId(&quot;5b13c790006ad854460ee70c&quot;),        &quot;stuid&quot; : 1002,        &quot;name&quot; : &quot;王大锤&quot;,        &quot;tel&quot; : &quot;13012345678&quot;,        &quot;gender&quot; : &quot;男&quot;&#125;&#123;        &quot;_id&quot; : ObjectId(&quot;5b13c92dd185894d7283efab&quot;),        &quot;stuid&quot; : 1003,        &quot;gender&quot; : &quot;男&quot;,        &quot;name&quot; : &quot;白元芳&quot;,        &quot;tel&quot; : &quot;13022223333&quot;&#125;&gt; // 查询stuid大于1001的文档只显示name和tel字段&gt; db.students.find(&#123;stuid: &#123;'$gt': 1001&#125;&#125;, &#123;_id: 0, name: 1, tel: 1&#125;).pretty()&#123; &quot;name&quot; : &quot;王大锤&quot;, &quot;tel&quot; : &quot;13012345678&quot; &#125;&#123; &quot;name&quot; : &quot;白元芳&quot;, &quot;tel&quot; : &quot;13022223333&quot; &#125;&gt; // 查询name为“骆昊”或者tel为“13022223333”的文档&gt; db.students.find(&#123;'$or': [&#123;name: '骆昊'&#125;, &#123;tel: '13022223333'&#125;]&#125;, &#123;_id: 0, name: 1, tel: 1&#125;).pretty()&#123; &quot;name&quot; : &quot;骆昊&quot;, &quot;tel&quot; : &quot;13566778899&quot; &#125;&#123; &quot;name&quot; : &quot;白元芳&quot;, &quot;tel&quot; : &quot;13022223333&quot; &#125;&gt; // 查询学生文档跳过第1条文档只查1条文档&gt; db.students.find().skip(1).limit(1).pretty()&#123;        &quot;_id&quot; : ObjectId(&quot;5b13c790006ad854460ee70c&quot;),        &quot;stuid&quot; : 1002,        &quot;name&quot; : &quot;王大锤&quot;,        &quot;tel&quot; : &quot;13012345678&quot;,        &quot;gender&quot; : &quot;男&quot;&#125;&gt; // 对查询结果进行排序(1表示升序，-1表示降序)&gt; db.students.find(&#123;&#125;, &#123;_id: 0, stuid: 1, name: 1&#125;).sort(&#123;stuid: -1&#125;)&#123; &quot;stuid&quot; : 1003, &quot;name&quot; : &quot;白元芳&quot; &#125;&#123; &quot;stuid&quot; : 1002, &quot;name&quot; : &quot;王大锤&quot; &#125;&#123; &quot;stuid&quot; : 1001, &quot;name&quot; : &quot;骆昊&quot; &#125;&gt; // 在指定的一个或多个字段上创建索引&gt; db.students.ensureIndex(&#123;name: 1&#125;)&#123;        &quot;createdCollectionAutomatically&quot; : false,        &quot;numIndexesBefore&quot; : 1,        &quot;numIndexesAfter&quot; : 2,        &quot;ok&quot; : 1&#125;</code></pre></li></ol><p>使用 MongoDB 可以非常方便的配置数据复制，通过冗余数据来实现数据的高可用以及灾难恢复，也可以通过数据分片来应对数据量迅速增长的需求。关于 MongoDB 更多的操作可以查阅<span class="exturl" data-url="aHR0cHM6Ly9tb25nb2RiLWRvY3VtZW50YXRpb24ucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0Lw==">官方文档</span> ，同时推荐大家阅读 Kristina Chodorow 写的<span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9ib29rLzExNzI=">《MongoDB 权威指南》</span>。</p><h4 id="在python程序中操作mongodb"><a class="anchor" href="#在python程序中操作mongodb">#</a> 在 Python 程序中操作 MongoDB</h4><p>可以通过 pip 安装 <code>pymongo</code>  来实现对 MongoDB 的操作。</p><pre><code class="language-Shell">pip install pymongo</code></pre><p>进入 Python 交互式环境，就可以执行以下的操作。</p><pre><code class="language-Python">&gt;&gt;&gt; from pymongo import MongoClient&gt;&gt;&gt;&gt;&gt;&gt; client = MongoClient('mongodb://127.0.0.1:27017') &gt;&gt;&gt; db = client.school&gt;&gt;&gt; for student in db.students.find():...     print('学号:', student['stuid'])...     print('姓名:', student['name'])...     print('电话:', student['tel'])... 学号: 1001.0姓名: 骆昊电话: 13566778899学号: 1002.0姓名: 王大锤电话: 13012345678学号: 1003.0姓名: 白元芳电话: 13022223333&gt;&gt;&gt; db.students.find().count()3&gt;&gt;&gt; db.students.remove()&#123;'n': 3, 'ok': 1.0&#125;&gt;&gt;&gt; db.students.find().count()0&gt;&gt;&gt; from pymongo import ASCENDING&gt;&gt;&gt;&gt;&gt;&gt; coll = db.students&gt;&gt;&gt; coll.create_index([('name', ASCENDING)], unique=True)'name_1'&gt;&gt;&gt; coll.insert_one(&#123;'stuid': int(1001), 'name': '骆昊', 'gender': True&#125;)&lt;pymongo.results.InsertOneResult object at 0x1050cc6c8&gt;&gt;&gt;&gt; coll.insert_many([&#123;'stuid': int(1002), 'name': '王大锤', 'gender': False&#125;, &#123;'stuid': int(1003), 'name': '白元芳', 'gender': True&#125;])&lt;pymongo.results.InsertManyResult object at 0x1050cc8c8&gt;&gt;&gt;&gt; for student in coll.find(&#123;'gender': True&#125;):...     print('学号:', student['stuid'])...     print('姓名:', student['name'])...     print('性别:', '男' if student['gender'] else '女')... 学号: 1001姓名: 骆昊性别: 男学号: 1003姓名: 白元芳性别: 男</code></pre><p>关于<a href="https://api.mongodb.com/python/current/tutorial.html"> <code>pymongo</code> </a> 更多的知识可以通过它的官方文档进行了解，也可以使用<a href="https://pypi.org/project/mongoengine/"> <code>MongoEngine</code> </a> 这样的库来简化 Python 程序对 MongoDB 的操作，除此之外，还有以异步 I/O 方式访问 MongoDB 的三方库<a href="https://pypi.org/project/motor/"> <code>motor</code> </a> 都是不错的选择。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10月31日面试失败复盘</title>
      <link href="/computer-science/java/interview/10%E6%9C%8831%E6%97%A5%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/computer-science/java/interview/10%E6%9C%8831%E6%97%A5%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java开发面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10月30日面试失败复盘</title>
      <link href="/computer-science/java/interview/10%E6%9C%8830%E6%97%A5%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/computer-science/java/interview/10%E6%9C%8830%E6%97%A5%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="10月30日面试失败复盘"><a class="anchor" href="#10月30日面试失败复盘">#</a> 10 月 30 日面试失败复盘</h2><p>第一家：</p><ol><li>自我介绍一下</li><li>说一下刚说的这个项目？</li><li>说下 SpringBoot 中有哪些注解？</li><li>4 道 sql 题目？</li><li>详细说下你了解依赖包？</li><li>详细说下你经常使用到的工具？</li><li>Redis</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java开发面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10月27日面试失败复盘</title>
      <link href="/computer-science/java/interview/10%E6%9C%8827%E6%97%A5%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/computer-science/java/interview/10%E6%9C%8827%E6%97%A5%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java开发面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot面试题</title>
      <link href="/computer-science/java/interview/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/computer-science/java/interview/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot面试题"><a class="anchor" href="#springboot面试题">#</a> SpringBoot 面试题</h2><h3 id="1springboot的特性"><a class="anchor" href="#1springboot的特性">#</a> 1.SpringBoot 的特性</h3><ol><li>Spring 的独立应用；</li><li>SpringBoot 内置 Tomcat、Jetty 容器，不需要构建 war 文件；</li><li>SpringBoot 提供了各种 starter 即场景启动器，简化了构建配置；</li><li>当条件满足的时候自动地装配 Spring 或第三方类库；</li><li>提供运维特性，如指标信息、健康检查以及外部化配置；</li><li>绝无代码生成，并且不需要 XML 配置；</li></ol><h3 id="2springboot的原理"><a class="anchor" href="#2springboot的原理">#</a> 2.SpringBoot 的原理</h3><p>​Spring Boot 是一个用于简化 Spring 应用开发的框架，它基于 Spring 框架，提供了一种快速、方便的方式来创建基于生产级别的、可独立运行的 Spring 应用。以下是 Spring Boot 的一些核心原理：</p><ol><li><strong>自动配置（Auto-Configuration）</strong>：Spring Boot 使用自动配置来简化应用的配置过程。它会根据类路径下的依赖自动配置应用的行为，减少了开发者的配置工作。</li><li><strong>起步依赖（Starter Dependencies）</strong>：Spring Boot 提供了一系列预先配置好的依赖项，称为 “起步依赖”。开发者可以通过引入特定的起步依赖，快速地添加对数据库、消息队列、安全性等功能的支持，而不需要手动配置。</li><li><strong>嵌入式容器（Embedded Containers）</strong>：Spring Boot 包含了嵌入式的 Servlet 容器（如 Tomcat、Jetty 等），应用可以直接打包为一个可执行的 JAR 文件，不需要外部容器的支持。</li><li><strong>Actuator</strong>：Spring Boot Actuator 提供了对应用内部运行状况的监控和管理功能。通过暴露 RESTful 接口，开发者可以方便地查看应用的健康状况、性能指标等信息。</li><li><strong>外部化配置（Externalized Configuration）</strong>：Spring Boot 支持使用属性文件、YAML 文件、环境变量等多种方式来配置应用，这样可以使得应用的配置更加灵活。</li><li><strong>Spring Boot CLI</strong>：Spring Boot 提供了一个命令行工具（CLI），可以用 Groovy 语言编写简单的 Spring Boot 应用，进一步简化了开发流程。</li><li><strong>简化的 Maven 和 Gradle 插件</strong>：Spring Boot 提供了专门的 Maven 和 Gradle 插件，可以方便地构建和运行 Spring Boot 应用。</li></ol><p>总的来说，Spring Boot 的核心原理在于提供了一套约定大于配置的开发模式，通过默认的配置和约定，开发者可以更专注于业务逻辑的开发，而不需要过多地关心底层框架的配置和集成。</p><h3 id="3springboot的一些注解"><a class="anchor" href="#3springboot的一些注解">#</a> 3.SpringBoot 的一些注解</h3><p>​</p><h3 id="4springboot的场景启动器是什么"><a class="anchor" href="#4springboot的场景启动器是什么">#</a> 4.SpringBoot 的场景启动器是什么？</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java开发面试题 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试题</title>
      <link href="/computer-science/java/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/computer-science/java/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="spring面试题"><a class="anchor" href="#spring面试题">#</a> Spring 面试题</h2><h3 id="1spring原理"><a class="anchor" href="#1spring原理">#</a> 1.Spring 原理</h3><ol><li><strong>IoC（控制反转）和 DI（依赖注入）：</strong><ul><li><strong>IoC（Inversion of Control）</strong>：IoC 是一种设计思想，它将程序的控制权交给容器或框架，由容器来负责对象的创建和管理。Spring 的 IoC 容器，即 ApplicationContext，负责管理 Bean 的生命周期。</li><li><strong>DI（Dependency Injection）</strong>：DI 是 IoC 的一种实现方式，它通过注入的方式将一个对象的依赖关系交给容器管理，而不是在对象内部直接创建依赖对象。这样做提高了组件的可重用性和可测试性。</li></ul></li><li><strong>AOP（面向切面编程）：</strong><ul><li><strong>AOP（Aspect-Oriented Programming）</strong>：AOP 是一种编程范式，它允许将横切关注点（如日志、安全、事务管理等）从业务逻辑中剥离出来，使得系统关注点的变化不影响业务逻辑。在 Spring 中，AOP 通过代理机制实现，常见的代理方式有基于 JDK 动态代理和基于 CGLIB 的代理。</li></ul></li><li><strong>Bean 的生命周期和作用域：</strong><ul><li><strong>Bean 的生命周期</strong>：Bean 的生命周期包括实例化、初始化、使用和销毁四个阶段。Spring 容器负责 Bean 的实例化和初始化，而销毁阶段则由容器负责。你可以提及 <code>InitializingBean</code>  和 <code>DisposableBean</code>  接口以及 <code>@PostConstruct</code>  和 <code>@PreDestroy</code>  注解来控制 Bean 的初始化和销毁操作。</li><li><strong>Bean 的作用域</strong>：Spring 定义了多种 Bean 的作用域，包括 singleton（单例，默认）、prototype（原型）、request（每个 HTTP 请求一个实例）、session（每个 HTTP Session 一个实例）和 global session（全局 HTTP Session 一个实例）等。</li></ul></li><li><strong>Spring 的事务管理：</strong><ul><li><strong>声明式事务管理</strong>：通过使用 <code>@Transactional</code>  注解或 XML 配置来声明事务，使得事务的控制更加方便。Spring 提供了对编程式事务管理的支持，可以通过 <code>PlatformTransactionManager</code>  接口进行编程式事务控制。</li></ul></li><li><strong>Spring 的数据访问与集成：</strong><ul><li><strong>数据访问</strong>：Spring 提供了 JdbcTemplate 等模板类，简化了 JDBC 的操作，同时支持 ORM 框架（如 Hibernate、MyBatis）的集成，提供了对持久层的支持。</li><li><strong>集成其他技术</strong>：Spring 能够与其他技术（如消息队列、缓存、搜索引擎等）进行集成，提供了丰富的集成方案。</li></ul></li><li><strong>Spring 框架的核心组件：</strong><ul><li><strong>ApplicationContext</strong>：Spring 的 IoC 容器，负责管理 Bean 的生命周期。</li><li><strong>BeanFactory</strong>：是 IoC 容器的基础接口，提供了基本的 IoC 功能。</li><li><strong>BeanPostProcessor</strong>：在 Bean 初始化前后执行一些操作。</li><li><strong>BeanDefinition</strong>：定义了 Bean 的配置信息。</li></ul></li></ol><h3 id="2什么是控制反转什么是依赖注入"><a class="anchor" href="#2什么是控制反转什么是依赖注入">#</a> 2. 什么是控制反转？什么是依赖注入</h3><p>​控制反转（IoC，Inversion of Control）和依赖注入（DI，Dependency Injection）是面向对象编程中两个重要的概念，它们是实现松耦合（Loose Coupling）的关键。</p><h3 id="控制反转ioc"><a class="anchor" href="#控制反转ioc">#</a> 控制反转（IoC）：</h3><p>控制反转是一种设计原则，它将程序的控制权从程序代码本身转移到了外部容器或框架。在传统的程序设计中，程序代码通常负责对象的创建、依赖关系的管理以及资源的释放。而在 IoC 中，这些职责被反转，由外部容器负责。IoC 使得系统更加灵活，易于扩展和维护。</p><p>在 IoC 中，对象的创建和管理由 IoC 容器负责。Spring 的 ApplicationContext 就是一个经典的 IoC 容器。它负责实例化 Bean、注入 Bean 之间的依赖关系、管理 Bean 的生命周期等。开发者只需定义好 Bean 和它们之间的关系，由容器负责具体的实例化和管理。</p><h3 id="依赖注入di"><a class="anchor" href="#依赖注入di">#</a> 依赖注入（DI）：</h3><p>依赖注入是 IoC 的一种具体实现方式。在依赖注入中，组件的依赖关系由外部容器在组件被创建时注入。依赖关系通常以构造函数、Setter 方法或接口注入的方式实现。</p><p>假设有一个类 <code>UserService</code>  依赖于 <code>UserRepository</code> ，传统的做法是在 <code>UserService</code>  类内部创建 <code>UserRepository</code>  的实例。但在依赖注入中， <code>UserService</code>  不再负责创建 <code>UserRepository</code> ，而是通过构造函数或 Setter 方法接受一个 <code>UserRepository</code>  的实例。容器在创建 <code>UserService</code>  时，将 <code>UserRepository</code>  的实例注入到 <code>UserService</code>  中。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 通过构造函数注入依赖</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>userRepository <span class="token operator">=</span> userRepository<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 或者通过 Setter 方法注入依赖</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// public void setUserRepository(UserRepository userRepository) &#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">//     this.userRepository = userRepository;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// &#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>依赖注入使得对象之间的关系更加灵活，容易被替换和测试。Spring 框架提供了多种依赖注入的方式，包括构造函数注入、Setter 方法注入、接口注入等。</p><h3 id="3spring的生命周期"><a class="anchor" href="#3spring的生命周期">#</a> 3.Spring 的生命周期</h3><p>​Spring 框架中的 Bean（Java 对象）的生命周期由 Spring 容器来管理，包括 Bean 的创建、初始化、使用和销毁等阶段。以下是 Spring Bean 的生命周期：</p><ol><li><strong>实例化（Instantiation）</strong>： 当 Spring 容器接收到 Bean 的定义后，它会通过构造函数或工厂方法来实例化 Bean 对象。</li><li><strong>设定 Bean 的属性（Population of Properties）</strong>： Spring 容器将配置文件或注解中定义的属性值或引用注入到 Bean 中。</li><li><strong>Bean 的初始化（Bean Initialization）</strong>： 如果 Bean 实现了 <code>InitializingBean</code>  接口，Spring 将调用其 <code>afterPropertiesSet</code>  方法进行初始化。另外，如果在配置文件中使用了 <code>init-method</code>  属性，指定了初始化方法，Spring 容器会在属性设置完成后调用这个指定的方法。</li><li><strong>Bean 的使用（Bean is ready to use）</strong>： 此时，Bean 已经可以被应用程序使用了。</li><li><strong>Bean 的销毁（Bean Destruction）</strong>： 如果 Bean 实现了 <code>DisposableBean</code>  接口，Spring 容器在 Bean 不再需要时调用其 <code>destroy</code>  方法进行销毁。或者，如果在配置文件中使用了 <code>destroy-method</code>  属性，指定了销毁方法，Spring 容器在需要销毁 Bean 时调用这个指定的方法。</li></ol><p>在整个生命周期中，Spring 容器负责管理 Bean 的创建、依赖注入、初始化和销毁等工作，确保 Bean 在应用程序中的正确运作。</p><h3 id="4spring事务"><a class="anchor" href="#4spring事务">#</a> 4.Spring 事务</h3><p>​Spring 框架提供了丰富的事务管理功能，支持编程式事务和声明式事务两种方式。事务是用来保持数据库的一致性和完整性的机制，当一组相关的操作要么全部成功，要么全部失败。</p><p>在 Spring 中，你可以使用注解或 XML 配置来声明式地管理事务。以下是一些关于 Spring 事务的关键概念：</p><ol><li><p><strong>事务管理器（Transaction Manager）</strong>： 事务管理器负责实际管理事务。Spring 支持各种事务管理器，如 <code>DataSourceTransactionManager</code> （针对关系型数据库）、 <code>JtaTransactionManager</code> （用于分布式事务）等。</p></li><li><p><strong>事务定义（Transaction Definition）</strong>： 事务定义定义了事务的隔离级别、传播行为、超时等属性。Spring 使用 <code>org.springframework.transaction.TransactionDefinition</code>  接口来表示事务定义。</p></li><li><p><strong>事务传播行为（Transaction Propagation）</strong>： 事务传播行为定义了在方法调用中的事务如何传播。例如，一个方法 A 调用另一个方法 B，B 是否应该加入 A 的事务。Spring 定义了多种传播行为，例如 <code>REQUIRED</code> 、 <code>REQUIRES_NEW</code> 、 <code>NESTED</code>  等。</p></li><li><p><strong>隔离级别（Isolation Level）</strong>： 隔离级别定义了多个事务并发执行时，彼此之间的可见性。Spring 支持不同的隔离级别，包括 <code>DEFAULT</code> （使用数据库默认隔离级别）、 <code>READ_UNCOMMITTED</code> （允许读取未提交的数据）、 <code>READ_COMMITTED</code> （只能读取已提交的数据）、 <code>REPEATABLE_READ</code> （可重复读取）、 <code>SERIALIZABLE</code> （串行化）等。</p></li><li><p><strong>声明式事务管理</strong>： 通过注解或 XML 配置，你可以在方法上声明事务的属性。例如，使用 <code>@Transactional</code>  注解来标识一个方法应该在事务中执行。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">,</span> isolation <span class="token operator">=</span> <span class="token class-name">Isolation</span><span class="token punctuation">.</span><span class="token constant">READ_COMMITTED</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someTransactionalMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 事务性操作</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>编程式事务管理</strong>： 在代码中通过编程的方式控制事务。Spring 提供了 <code>TransactionTemplate</code>  来简化编程式事务管理。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallbackWithoutResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doInTransactionWithoutResult</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 事务性操作</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><p>通过合适的配置，Spring 事务管理器可以确保事务的正确性和一致性，保障了数据操作的可靠性。</p><h3 id="5aop是什么aop代理方式有哪些"><a class="anchor" href="#5aop是什么aop代理方式有哪些">#</a> 5.AOP 是什么？AOP 代理方式有哪些？</h3><p>​AOP（Aspect-Oriented Programming）是一种编程范式，它允许你定义横切关注点（cross-cutting concerns），如日志记录、性能监控、事务管理等，并将这些关注点模块化，然后将它们自动应用到应用程序的特定部分，而无需修改这些部分的代码。AOP 的目的是提高代码的模块性，降低耦合度，使代码更易于维护和扩展。</p><p>在 AOP 中，关注点（Aspect）是一个模块化的、可重用的模块，它包含了通知（Advice）和切点（Pointcut）两个主要概念。通知是关注点的具体行为，例如在方法执行前后执行的操作，而切点是指在何处应用通知的定义。</p><p>AOP 代理方式主要有两种：</p><ol><li><strong>基于代理的 AOP（Proxy-Based AOP）</strong>： 这是最常见的 AOP 代理方式。在基于代理的 AOP 中，AOP 框架创建一个目标对象（被代理的对象）的代理对象，并将通知织入到代理对象的方法调用中。Spring 的 AOP 默认采用基于代理的 AOP 实现。基于代理的 AOP 主要有两种代理方式：<ul><li><strong>JDK 动态代理</strong>：如果目标对象实现了接口，Spring 将使用 JDK 动态代理来创建代理对象。</li><li><strong>CGLIB 代理</strong>：如果目标对象没有实现接口，Spring 将使用 CGLIB 库来创建代理对象。</li></ul></li><li><strong>基于字节码的 AOP（AspectJ AOP）</strong>： 基于字节码的 AOP 通过直接在类的字节码上织入切面，因此不需要代理对象。这种方式更为强大和灵活，但也更复杂，通常需要使用特定的编译器或者在运行时进行字节码操纵。AspectJ 是一个常用的基于字节码的 AOP 框架。</li></ol><h3 id="6spring的bean有哪些创建方式"><a class="anchor" href="#6spring的bean有哪些创建方式">#</a> 6.Spring 的 Bean 有哪些创建方式？</h3><p>​在 Spring 框架中，有多种方式可以创建 Bean：</p><ol><li><p><strong>XML 配置方式</strong>：在 XML 配置文件中使用 <code>&lt;bean&gt;</code>  标签定义 Bean 的配置信息。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.MyBean<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure></li><li><p><strong>注解方式</strong>：使用注解标记类，然后在配置类中使用 <code>@ComponentScan</code>  或者 <code>@Component</code>  等注解进行扫描和定义 Bean。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Component</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBean</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>Java 配置方式</strong>：通过 Java 类配置 Bean，使用 <code>@Configuration</code>  和 <code>@Bean</code>  注解。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MyBean</span> <span class="token function">myBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>工厂方法方式</strong>：使用工厂方法创建 Bean，即在 XML 配置文件或者 Java 配置类中定义工厂方法。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.MyBeanFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>createInstance<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">MyBean</span> <span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>实例工厂方法方式</strong>：使用实例工厂方法创建 Bean，需要定义一个实例工厂，然后在 XML 配置文件或 Java 配置类中引用该工厂。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBeanFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>createInstance<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MyBean</span> <span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><p>以上是常见的 Spring Bean 创建方式，选择适合项目需求的方式可以提高代码的灵活性和可维护性。</p><h3 id="7spring的bean作用域有哪些"><a class="anchor" href="#7spring的bean作用域有哪些">#</a> 7.Spring 的 Bean 作用域有哪些？</h3><p>在 Spring 框架中，Bean 的作用域（Scope）定义了 Bean 实例的生命周期范围。Spring 支持以下几种 Bean 的作用域：</p><ol><li><p><strong>Singleton（单例）</strong>：在整个 Spring 容器中，只存在一个 Bean 实例。无论有多少个 Bean 的定义，Spring 容器都只会创建一个 Bean 实例，并在需要时返回给每个请求。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.MyBean<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure></li><li><p><strong>Prototype（原型）</strong>：每次请求 Bean 时，容器都会创建一个新的 Bean 实例。每个请求都会得到一个全新的 Bean 对象。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.MyBean<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prototype<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure></li><li><p><strong>Request（请求）</strong>：在一次 HTTP 请求中，容器会返回同一个 Bean 实例。该作用域仅在使用 Spring Web 应用时有效。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.MyBean<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>request<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure></li><li><p><strong>Session（会话）</strong>：在一个 HTTP 会话中，容器会返回同一个 Bean 实例。该作用域同样只在 Spring Web 应用时有效。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.MyBean<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>session<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure></li><li><p><strong>Global Session（全局会话）</strong>：在一个全局 HTTP 会话中，容器会返回同一个 Bean 实例。该作用域通常用于 Portlet 应用环境。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.MyBean<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>globalSession<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure></li><li><p><strong>Application（应用）</strong>：在整个 Web 应用中，容器会返回同一个 Bean 实例。</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.MyBean<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>application<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr></table></figure></li></ol><p>这些作用域允许你控制 Bean 实例的生命周期和共享程度，根据需求选择合适的作用域可以提高系统的性能和资源利用率。</p><h3 id="8spring如何解决bean循环依赖问题"><a class="anchor" href="#8spring如何解决bean循环依赖问题">#</a> 8.Spring 如何解决 Bean 循环依赖问题？</h3><p>​在 Spring 中，Bean 的循环依赖是指两个或多个 Bean 相互依赖，形成一个循环引用的关系。Spring 容器默认是不支持循环依赖的，但是它提供了一种机制来处理部分循环依赖情况。</p><p>Spring 使用了三级缓存解决 Bean 的循环依赖问题：</p><ol><li><strong>SingletonObjects 缓存</strong>：Spring 容器创建 Bean 时，会将正在创建的 Bean 放入 SingletonObjects 缓存中，标记为正在创建中。</li><li><strong>EarlySingletonObjects 缓存</strong>：当发现循环依赖时，Spring 会将早期暴露的 Bean 放入 EarlySingletonObjects 缓存中，标记为早期暴露的 Bean。</li><li><strong>SingletonFactories 缓存</strong>：当 Bean 创建完成后，会放入 SingletonFactories 缓存中，表示该 Bean 可以被其他 Bean 引用。</li></ol><p>Spring 容器在创建 Bean 时，会先从 SingletonObjects 缓存中查找是否存在 Bean 的实例。如果存在，直接返回。如果不存在，会先创建一个 ObjectFactory，用于生成 Bean 的实例。然后，将该 ObjectFactory 放入 SingletonFactories 缓存中。接着，Spring 会递归地创建 Bean 的依赖关系。如果在创建依赖关系的过程中，发现了循环依赖，Spring 会从 EarlySingletonObjects 缓存中获取早期暴露的 Bean，而不是直接创建新的实例。这样，就避免了循环依赖的问题。</p><p>需要注意的是，虽然 Spring 提供了这种机制来处理部分循环依赖情况，但是过多的循环依赖可能会导致系统设计存在问题，因此在设计时，尽量避免复杂的循环依赖关系。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java开发面试题 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题常问回答</title>
      <link href="/computer-science/java/interview/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B8%B8%E9%97%AE%E5%9B%9E%E7%AD%94/"/>
      <url>/computer-science/java/interview/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B8%B8%E9%97%AE%E5%9B%9E%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题常问回答"><a class="anchor" href="#面试题常问回答">#</a> 面试题常问回答</h2><ol><li><p>上份工作离职理由</p><p>由于公司组织结构调整，需要从我所在原来的部门调到其他岗位，同事有接受调岗，也有在观望，但我不想偏离自己的职业方向，所以只好离职。</p></li><li><p>空窗期在干什么？或者空窗期找工作的情况？</p><p>上份工作离职后，在找工作的过程中，发现我在开发技术方面很多地方需要提升，所以自学了一些符合就业市场中需求的技术课程，趁此机会提升自己的能力，以便能够更好地胜任工作。</p></li><li><p>当前你的找工作情况，目前手上有 offer 吗？</p><p>说实话，我最近才开始陆续参加一些面试，有几个公司已经到了最后环节，offer 还在洽谈中。<br />我自己也是偶然看到贵公司的岗位，觉得自己与该岗位十分合适，另外过往的工作经历和贵岗位非常匹配，也很喜欢这个平台和氛围，尤其是今天和您聊了之后，对公司 XX 方面很佩服，真心期待有这样一个机会。</p></li><li><p>你能接受加班吗？</p><p>我会努力地避免因为个人低效等原因造成的加班问题。</p></li><li><p>自我介绍一下？</p><p>面试官您好，我叫罗涛，从 2022 年开始进行 java 开发的工作，到目前为止，已经有了 1 年左右的工作经验，我在一家公司工作过，参与过一些应用的二次开发，比如说，机构服务平台。在工作期间呢，也做出来了一些成绩，比如说在机构服务平台这个系统中，我为公司重构了登录和安全认证模块相关的功能，包含了用户管理、权限管理、角色管理、验证码认证、密码加密等等功能，为公司将老系统基础模块二次开发后，提供了更加方便且易扩展的程序。用到的技术栈主要以 SpringBoot 为主，对于其他的技术也有一定的了解，如 Redis、SpringSecurity、Mybatis。好了，我的介绍完毕。</p></li><li><p>你还有什么问题需要问我的吗？</p><p>我想请问一下，如果确认录用的话，我需要准备什么可以快速融入到贵司的工作当中？</p><p>刚才的面试当中，你觉得我的技术存在什么问题？下一步应该怎么学习？</p><p>你觉得我刚才面试当中哪个方面回答的不好？</p><p>咱们公司的技术栈是什么？</p><p>咱们公司内部有没有什么培训或者分享</p></li><li><p>如果录用你的话，需要多久能入职？</p><p>如果贵公司录用了我的话，我会在一周内给出准确的答复。</p></li><li><p>介绍一下你的缺点？</p><p>由于我是刚毕业出来 1 年多，所以我的社会经验不足，可能在一些场景下沟通技巧和职场经验上不足，但是我会努力学习，尝试改变这种境况。</p></li><li><p>介绍一下你的优点？</p></li><li></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java开发面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10月9日面试失败复盘</title>
      <link href="/computer-science/java/interview/10%E6%9C%889%E6%97%A5%E9%9D%A2%E8%AF%95%E5%A4%B1%E8%B4%A5%E5%A4%8D%E7%9B%98/"/>
      <url>/computer-science/java/interview/10%E6%9C%889%E6%97%A5%E9%9D%A2%E8%AF%95%E5%A4%B1%E8%B4%A5%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>面试题：</p><ol><li><p>先自我介绍一下？</p></li><li><p>说说数据库左连接和右连接的区别？</p><p>在 MySQL 数据库中，左连接（LEFT JOIN）和右连接（RIGHT JOIN）是两种常用的连接类型，用于联接两个或多个表的数据。这两种连接的主要区别在于连接的顺序和结果集中包含的数据。</p><ol><li><strong>左连接（LEFT JOIN）</strong>：</li></ol><p>左连接从左表中选择所有的行，并与右表中匹配的行进行连接。如果右表中没有匹配的行，那么结果集中右表的字段将显示为 NULL。左连接会返回左表中所有的记录，无论右表中是否有匹配的记录。</p><p><strong>语法</strong>：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> 左表</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> 右表</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">ON</span> 左表<span class="token punctuation">.</span>字段 <span class="token operator">=</span> 右表<span class="token punctuation">.</span>字段<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在左连接中，左表中所有的行都会被包含在结果集中，而右表中没有匹配的行将以 NULL 填充。</p><ol><li><strong>右连接（RIGHT JOIN）</strong>：</li></ol><p>右连接与左连接相反，它从右表中选择所有的行，并与左表中匹配的行进行连接。如果左表中没有匹配的行，那么结果集中左表的字段将显示为 NULL。右连接会返回右表中所有的记录，无论左表中是否有匹配的记录。</p><p><strong>语法</strong>：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">FROM</span> 左表</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> 右表</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">ON</span> 左表<span class="token punctuation">.</span>字段 <span class="token operator">=</span> 右表<span class="token punctuation">.</span>字段<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在右连接中，右表中所有的行都会被包含在结果集中，而左表中没有匹配的行将以 NULL 填充。</p><p>需要注意的是，MySQL 中的右连接通常用左连接来替代，因为它们的结果是相同的，只是左右表的顺序不同。所以，实际应用中，常用左连接（LEFT JOIN）来处理连接操作。</p></li><li><p>mysql 的事务说一下？</p><p>MySQL 事务是一系列 SQL 语句的集合，它们被当作一个单独的工作单元执行，要么全部执行，要么全部不执行。事务是保证数据库完整性和一致性的重要机制。MySQL 中的事务具备以下四个特性，通常被称为 ACID 特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务是一个原子操作单元，事务中的所有操作要么全部执行，要么全部不执行。如果事务中的任何一个操作失败，整个事务将被回滚（Rollback），数据库状态会恢复到事务执行前的状态。</li><li><strong>一致性（Consistency）</strong>：事务执行的结果必须使数据库从一个一致性状态变到另一个一致性状态。这意味着事务在执行前后，数据库必须处于一致性状态。</li><li><strong>隔离性（Isolation）</strong>：事务的执行不能被其他事务干扰。即一个事务的执行不能被其他事务看到，直到它提交。这样可以避免多个事务并发执行时产生的不一致性问题。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，它对数据库的改变就是永久性的，即使系统崩溃，事务的结果也不会丢失。</li></ol><p>在 MySQL 中，可以使用以下语句控制事务：</p><ul><li><p><strong>开始事务（Start Transaction）</strong>：BEGIN 或 START TRANSACTION 语句用于显式地开始一个新的事务。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">-- 或者</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>提交事务（Commit）</strong>：COMMIT 语句用于将事务的操作永久保存到数据库中。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>回滚事务（Rollback）</strong>：ROLLBACK 语句用于撤销自上次 COMMIT 以来的所有事务。</p><pre><code>ROLLBACK;</code></pre></li><li><p><strong>设置保存点（Savepoint）</strong>：SAVEPOINT 语句可以在事务中设置保存点，以便在需要时进行部分回滚。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SAVEPOINT</span> savepoint_name<span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>回滚到保存点（Rollback to Savepoint）</strong>：ROLLBACK TO 语句可以将事务回滚到指定的保存点。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> savepoint_name<span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>释放保存点（Release Savepoint）</strong>：RELEASE SAVEPOINT 语句标志着一个保存点之前的操作都已经成功，可以释放该保存点。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">RELEASE</span> <span class="token keyword">SAVEPOINT</span> savepoint_name<span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul><p>以上是 MySQL 中事务的基本操作，通过合理使用事务，可以确保数据库操作的安全性和一致性。</p></li><li><p>Spring 原理？</p><ol><li><strong>IoC（控制反转）和 DI（依赖注入）：</strong><ul><li><strong>IoC（Inversion of Control）</strong>：IoC 是一种设计思想，它将程序的控制权交给容器或框架，由容器来负责对象的创建和管理。Spring 的 IoC 容器，即 ApplicationContext，负责管理 Bean 的生命周期。</li><li><strong>DI（Dependency Injection）</strong>：DI 是 IoC 的一种实现方式，它通过注入的方式将一个对象的依赖关系交给容器管理，而不是在对象内部直接创建依赖对象。这样做提高了组件的可重用性和可测试性。</li></ul></li><li><strong>AOP（面向切面编程）：</strong><ul><li><strong>AOP（Aspect-Oriented Programming）</strong>：AOP 是一种编程范式，它允许将横切关注点（如日志、安全、事务管理等）从业务逻辑中剥离出来，使得系统关注点的变化不影响业务逻辑。在 Spring 中，AOP 通过代理机制实现，常见的代理方式有基于 JDK 动态代理和基于 CGLIB 的代理。</li></ul></li><li><strong>Bean 的生命周期和作用域：</strong><ul><li><strong>Bean 的生命周期</strong>：Bean 的生命周期包括实例化、初始化、使用和销毁四个阶段。Spring 容器负责 Bean 的实例化和初始化，而销毁阶段则由容器负责。你可以提及 <code>InitializingBean</code>  和 <code>DisposableBean</code>  接口以及 <code>@PostConstruct</code>  和 <code>@PreDestroy</code>  注解来控制 Bean 的初始化和销毁操作。</li><li><strong>Bean 的作用域</strong>：Spring 定义了多种 Bean 的作用域，包括 singleton（单例，默认）、prototype（原型）、request（每个 HTTP 请求一个实例）、session（每个 HTTP Session 一个实例）和 global session（全局 HTTP Session 一个实例）等。</li></ul></li><li><strong>Spring 的事务管理：</strong><ul><li><strong>声明式事务管理</strong>：通过使用 <code>@Transactional</code>  注解或 XML 配置来声明事务，使得事务的控制更加方便。Spring 提供了对编程式事务管理的支持，可以通过 <code>PlatformTransactionManager</code>  接口进行编程式事务控制。</li></ul></li><li><strong>Spring 的数据访问与集成：</strong><ul><li><strong>数据访问</strong>：Spring 提供了 JdbcTemplate 等模板类，简化了 JDBC 的操作，同时支持 ORM 框架（如 Hibernate、MyBatis）的集成，提供了对持久层的支持。</li><li><strong>集成其他技术</strong>：Spring 能够与其他技术（如消息队列、缓存、搜索引擎等）进行集成，提供了丰富的集成方案。</li></ul></li><li><strong>Spring 框架的核心组件：</strong><ul><li><strong>ApplicationContext</strong>：Spring 的 IoC 容器，负责管理 Bean 的生命周期。</li><li><strong>BeanFactory</strong>：是 IoC 容器的基础接口，提供了基本的 IoC 功能。</li><li><strong>BeanPostProcessor</strong>：在 Bean 初始化前后执行一些操作。</li><li><strong>BeanDefinition</strong>：定义了 Bean 的配置信息。</li></ul></li></ol></li><li><p>Rest 的请求有哪些？</p><p>在 Web 开发中，REST（Representational State Transfer）是一种基于 HTTP 协议的软件架构风格，它使用标准的 HTTP 请求方法（GET、POST、PUT、DELETE 等）进行通信。RESTful API 是一种遵循 REST 架构风格的 Web API。</p><p>以下是常见的 REST 请求方法及它们传递数据的方式：</p><ol><li><strong>GET</strong>：使用 GET 请求从服务器获取数据。数据通常通过 URL 的查询参数传递，例如： <code>/api/resource?id=1</code> 。</li><li><strong>POST</strong>：使用 POST 请求向服务器提交数据，通常用于创建新资源。数据可以通过请求体（Request Body）以 JSON、XML 等格式传递。</li><li><strong>PUT</strong>：使用 PUT 请求向服务器更新或创建资源。与 POST 不同，PUT 请求通常用于更新已有资源。数据可以通过请求体传递。</li><li><strong>DELETE</strong>：使用 DELETE 请求从服务器删除资源。通常不传递数据，删除的资源由 URL 指定。</li><li><strong>PATCH</strong>：使用 PATCH 请求局部更新服务器上的资源。与 PUT 不同，PATCH 请求只更新资源的部分属性。数据可以通过请求体传递。</li><li><strong>OPTIONS</strong>：使用 OPTIONS 请求获取目标资源所支持的通信选项，用于 CORS（跨域资源共享）等场景。</li><li><strong>HEAD</strong>：与 GET 类似，但是服务器只返回响应头信息，不返回实体主体。通常用于获取资源的元信息，而不需要实际的资源内容。</li></ol><p>REST 请求的数据传递通常使用 JSON（JavaScript Object Notation）格式，因为它具有简洁、易读、易解析的特点。数据也可以使用 XML 等其他格式，但 JSON 是目前应用最广泛的数据传递格式之一。在请求的 Header 中，还可以设置 Content-Type 字段来指定数据传递的格式。例如， <code>Content-Type: application/json</code>  表示请求体中的数据是 JSON 格式。</p><p>RESTful API 的设计原则包括资源（Resources）、统一接口（Uniform Interface）、状态无关（Statelessness）、表示层（Representation）、超媒体驱动（Hypermedia as the Engine of Application State，HATEOAS）等。遵循这些原则，可以设计出清晰、易用、可扩展的 API。</p></li><li><p>空窗期的安排？</p></li></ol><p>失败原因：</p><ol><li>准备不充足</li><li>嘴笨，下意识逃避</li><li>没有吸取教训，依然把自己劣势暴露出来。</li><li>压根不重视面试。</li><li>坏习惯依旧不改。</li></ol><p>解决方案：</p><ol><li>空出时间在面试前准备模拟面试</li><li>提前准备好自我介绍</li><li>适当改正回答时的下意识逃避行为（这点尤为重要）</li><li>需要调整好作息，不能再休息不好去面试。</li></ol><p>初级考察范围：</p><ol><li>Java 基础。</li><li>SQL 语句</li><li>MySql 索引、事务</li><li>框架原理</li><li>项目？</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java开发面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我介绍</title>
      <link href="/computer-science/java/interview/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
      <url>/computer-science/java/interview/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="自我介绍"><a class="anchor" href="#自我介绍">#</a> 自我介绍</h3><p>面试官您好，</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java开发面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣算法题-5-最长回文子串</title>
      <link href="/computer-science/java/arithmetic/5-%E5%8A%9B%E6%89%A3-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E4%B8%AD%E7%AD%89/"/>
      <url>/computer-science/java/arithmetic/5-%E5%8A%9B%E6%89%A3-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E4%B8%AD%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h2 id="最长回文子串"><a class="anchor" href="#最长回文子串">#</a> 最长回文子串</h2><p>给你一个字符串  <code>s</code> ，找到  <code>s</code>  中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;cbbd&quot;输出：&quot;bb&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code>  仅由数字和英文字母组成</li></ul><p><strong>思路</strong>：</p><ol><li><p>动态规划</p><p>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。</p><p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 P (i,j) 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成 s [i:j]）是否为回文串：</p><p><img data-src="https://pic.imgdb.cn/item/651051c1c458853aefb341e4.jpg" alt="image-20230924225747002" /></p><p>是回文串其它情况这里的「其它情况」包含两种可能性：</p><ul><li>s [i,j] 本身不是一个回文串；</li><li>i&gt;ji &gt; j<em>i</em>&gt;<em>j</em>，此时 s [i,j] 本身不合法。</li></ul><p>那么我们就可以写出动态规划的状态转移方程：</p><p><img data-src="https://pic.imgdb.cn/item/651051d4c458853aefb35cd0.jpg" alt="image-20230924225631034" /><br /> 也就是说，只有 s [i+1:j−1] 是回文串，并且 s 的第 i 和 j 个字母相同时，s [i:j] 才会是回文串。</p><p>上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：</p><p><img data-src="https://pic.imgdb.cn/item/651051e3c458853aefb37420.jpg" alt="image-20230924225644678" /></p><p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 P (i,j)=true 中 j−i+1（即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</p><p><strong>代码</strong>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">//dp [i][j] 表示 s [i..j] 是否是回文串</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 初始化：所有长度为 1 的子串都是回文串</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charArray <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 递推开始</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 先枚举子串长度</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token class-name">L</span> <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> <span class="token class-name">L</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token class-name">L</span> <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token comment">// 如果右边界越界，就可以退出当前循环</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>charArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> charArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre>                <span class="token comment">// 只要 dp [i][L] == true 成立，就表示子串 s [i..L] 是回文，此时记录回文长度和起始位置</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> maxLen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                    maxLen <span class="token operator">=</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                    begin <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> begin <span class="token operator">+</span> maxLen<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>复杂度分析</strong>:</p><p>时间复杂度：O (n2)，其中 n 是字符串的长度。</p><p>动态规划的状态总数为 O (n2)，对于每个状态，我们需要转移的时间为 O (1)。</p><p>空间复杂度：O (n2)，即存储动态规划状态需要的空间。</p></li><li><p>中心扩散</p></li></ol><p>​我们仔细观察一下方法一中的状态转移方程：</p><p><img data-src="https://pic.imgdb.cn/item/651051f4c458853aefb37907.jpg" alt="image-20230924230359318" /></p><p>​ 找出其中的状态转移链：</p><p>​ <img data-src="https://pic.imgdb.cn/item/65105201c458853aefb37a8f.jpg" alt="image-20230924230425562" /></p><p>​</p><p>​ 可以发现，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。</p><p>​ 边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P (i+1,j−1) 扩展到 P (i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</p><p>​ 聪明的读者此时应该可以发现，「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。</p><p>​ <strong>代码</strong>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                end <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">expandAroundCenter</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token operator">--</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token operator">++</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> right <span class="token operator">-</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣算法题 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣算法题-4-整数反转</title>
      <link href="/computer-science/java/arithmetic/4-%E5%8A%9B%E6%89%A3-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-%E4%B8%AD%E7%AD%89/"/>
      <url>/computer-science/java/arithmetic/4-%E5%8A%9B%E6%89%A3-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-%E4%B8%AD%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h2 id="整数反转"><a class="anchor" href="#整数反转">#</a> 整数反转</h2><p>给你一个 32 位的有符号整数  <code>x</code>  ，返回将  <code>x</code>  中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围  <code>[−231, 231 − 1]</code>  ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><p><strong>示例 1：</strong></p><pre><code>输入：x = 123输出：321</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：x = -123输出：-321</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：x = 120输出：21</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：x = 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><p><strong>思路</strong>：<br />首先我们想一下，怎么去反转一个整数？<br />用栈？<br />或者把整数变成字符串，再去反转这个字符串？<br />这两种方式是可以，但并不好。实际上我们只要能拿到这个整数的 末尾数字 就可以了。<br />以 12345 为例，先拿到 5，再拿到 4，之后是 3，2，1，我们按这样的顺序就可以反向拼接处一个数字了，也就能达到 反转 的效果。<br />怎么拿末尾数字呢？好办，用取模运算就可以了</p><p><img data-src="https://pic.leetcode-cn.com/be35cb60bec9a9ae794abad671e6618abb5664780bc7ee30ca93ca423884a666-1.jpg" alt="1.jpg" /></p><p>1、将 12345 % 10 得到 5，之后将 12345 / 10<br />2、将 1234 % 10 得到 4，再将 1234 / 10<br />3、将 123 % 10 得到 3，再将 123 / 10<br />4、将 12 % 10 得到 2，再将 12 / 10<br />5、将 1 % 10 得到 1，再将 1 / 10</p><p>这么看起来，一个循环就搞定了，循环的判断条件是 x&gt;0<br /> 但这样不对，因为忽略了 负数<br />循环的判断条件应该是 while (x!=0)，无论正数还是负数，按照上面不断的 / 10 这样的操作，最后都会变成 0，所以判断终止条件就是！=0<br /> 有了取模和除法操作，对于像 12300 这样的数字，也可以完美的解决掉了。</p><p>看起来这道题就这么解决了，但请注意，题目上还有这么一句</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。</p><p>也就是说我们不能用 long 存储最终结果，而且有些数字可能是合法范围内的数字，但是反转过来就超过范围了。<br />假设有 1147483649 这个数字，它是小于最大的 32 位整数 2147483647 的，但是将这个数字反转过来后就变成了 9463847411，这就比最大的 32 位整数还要大了，这样的数字是没法存到 int 里面的，所以肯定要返回 0 (溢出了)。 甚至，我们还需要提前判断</p><p><img data-src="https://pic.leetcode-cn.com/42c736510f4914af169907d61b22d1a39bd5a16bbd7eca0466d90350e2763164-2.jpg" alt="2.jpg" /></p><p>上图中，绿色的是最大 32 位整数<br />第二排数字中，橘子的是 5，它是大于上面同位置的 4，这就意味着 5 后跟任何数字，都会比最大 32 为整数都大。<br />所以，我们到【最大数的 1/10】时，就要开始判断了<br />如果某个数字大于 214748364 那后面就不用再判断了，肯定溢出了。<br />如果某个数字等于 214748364 呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的末尾数字比较，如果这个数字比 7 还大，说明溢出了。</p><p>对于负数也是一样的</p><p><img data-src="https://pic.leetcode-cn.com/525aa75c19702e57b780c91a7ebb990359b14e96acc09b6327d9e1f0a5b3a16a-3.jpg" alt="3.jpg" /></p><p>上图中绿色部分是最小的 32 位整数，同样是在【最小数的 1/10】时开始判断<br />如果某个数字小于 -214748364 说明溢出了<br />如果某个数字等于 -214748364，还需要跟最小数的末尾比较，即看它是否小于 8</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 每次取末尾数字</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> x<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 判断是否 大于 最大 32 位整数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token operator">></span><span class="token number">214748364</span> <span class="token operator">||</span> <span class="token punctuation">(</span>res<span class="token operator">==</span><span class="token number">214748364</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token operator">></span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// 判断是否 小于 最小 32 位整数</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">214748364</span> <span class="token operator">||</span> <span class="token punctuation">(</span>res<span class="token operator">==</span><span class="token operator">-</span><span class="token number">214748364</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            res <span class="token operator">=</span> res<span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣算法题 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/computer-science/java/arithmetic/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/computer-science/java/arithmetic/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找法"><a class="anchor" href="#二分查找法">#</a> 二分查找法</h3><p><code>思路：</code> 先将列表中间的元素与要查找的元素比较，如果相等直接返回，如果大了，将中间元素后面的列表元素排除，再在列表开始到列表中间元素之间进行相同操作，直到查找到匹配的元素。</p><p>时间复杂度：O (log2 n)</p><p><code>代码：</code></p><p>java:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 方法一：递归</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">return</span> low<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> high<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>target<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>target<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 方法二：循环</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">int</span> high <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">return</span> low<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token keyword">return</span> high<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 二分查找中，数组必须是有序的</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 方法一：采用递归的方式</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment"># 如果 start 索引下的元素就是目标元素，直接返回</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> start</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment"># 如果 end 索引下的元素就是目标元素，直接返回</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> end</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment"># 取中间的元素 为什么是 (end + start) / 2？因为当 start>0 时，中间的索引必须是 (end - start) / 2 + start = (end + start) / 2，必须要加上 start, 否则递归会溢出，无限递归下去。</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    mid <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">+</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment"># 如果中间的元素是目标元素则直接返回</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> mid</pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment"># 如果中间元素大于目标元素，则递归调用，将 end 设置成中间索引减 1，即 mid - 1</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> binary_search<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment"># 如果中间元素小于目标元素，则递归调用，将 start 设置成中间索引加 1，即 mid+ 1</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> binary_search<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">None</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment"># 方法二：采用循环的方式</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">def</span> <span class="token function">binary_search_2</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    low <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    high <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">return</span> low</pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token keyword">return</span> high</pre></td></tr><tr><td data-num="32"></td><td><pre>        mid <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        guess <span class="token operator">=</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">if</span> guess <span class="token operator">==</span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token keyword">return</span> mid</pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">if</span> guess <span class="token operator">></span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            low <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token keyword">if</span> guess <span class="token operator">&lt;</span> target<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            high <span class="token operator">=</span> high <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">None</span></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣算法题-3-无重复字符的最长子串</title>
      <link href="/computer-science/java/arithmetic/3-%E5%8A%9B%E6%89%A3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E4%B8%AD%E7%AD%89/"/>
      <url>/computer-science/java/arithmetic/3-%E5%8A%9B%E6%89%A3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E4%B8%AD%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h2 id="无重复字符的最长子串"><a class="anchor" href="#无重复字符的最长子串">#</a> 无重复字符的最长子串</h2><p>给定一个字符串  <code>s</code>  ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code>  由英文字母、数字、符号和空格组成</li></ul><p><strong>解法</strong></p><p><strong>思路：</strong><br />这道题主要用到思路是：滑动窗口</p><p>什么是滑动窗口？</p><p>其实就是一个队列，比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p>时间复杂度：O (n)</p><h2 id="代码"><a class="anchor" href="#代码">#</a> 代码：</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                left <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>i<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣算法题-2-两数相加</title>
      <link href="/computer-science/java/arithmetic/2-%E5%8A%9B%E6%89%A3-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E4%B8%AD%E7%AD%89/"/>
      <url>/computer-science/java/arithmetic/2-%E5%8A%9B%E6%89%A3-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E4%B8%AD%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h2 id="力扣算法题-2-两数相加"><a class="anchor" href="#力扣算法题-2-两数相加">#</a> 力扣算法题 - 2 - 两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img" /></p><pre><code>输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：l1 = [0], l2 = [0]输出：[0]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围  <code>[1, 100]</code>  内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><p>解法：</p><p><strong>思路</strong></p><ul><li>标签：链表</li><li>将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 000，比如 987 + 23 = 987 + 023 = 1010</li><li>每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值<br />如果两个链表全部遍历完毕后，进位值为 111，则在新链表最前方添加节点 1</li><li>小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点 head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="2"></td><td><pre> * Definition for singly-linked list.</pre></td></tr><tr><td data-num="3"></td><td><pre> * public class ListNode &#123;</pre></td></tr><tr><td data-num="4"></td><td><pre> *     int val;</pre></td></tr><tr><td data-num="5"></td><td><pre> *     ListNode next;</pre></td></tr><tr><td data-num="6"></td><td><pre> *     ListNode(int x) &#123; val = x; &#125;</pre></td></tr><tr><td data-num="7"></td><td><pre> * &#125;</pre></td></tr><tr><td data-num="8"></td><td><pre> */</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> l1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> l2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">int</span> x <span class="token operator">=</span> l1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l1<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">int</span> y <span class="token operator">=</span> l2 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            </pre></td></tr><tr><td data-num="19"></td><td><pre>            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            sum <span class="token operator">=</span> sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>l2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>carry <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣算法题-1-两数之和</title>
      <link href="/computer-science/java/arithmetic/1-%E5%8A%9B%E6%89%A3-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E7%AE%80%E5%8D%95/"/>
      <url>/computer-science/java/arithmetic/1-%E5%8A%9B%E6%89%A3-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E7%AE%80%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="两数之和"><a class="anchor" href="#两数之和">#</a> 两数之和</h2><h3 id="两数之和-2"><a class="anchor" href="#两数之和-2">#</a> 两数之和</h3><p>给定一个整数数组  <code>nums</code>  和一个整数目标值  <code>target</code> ，请你在该数组中找出 <strong>和为目标值</strong> <em> <code>target</code> </em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,4], target = 6输出：[1,2]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [3,3], target = 6输出：[0,1]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>** 进阶：** 你可以想出一个时间复杂度小于  <code>O(n2)</code>  的算法吗？</p><p><strong>解法：</strong></p><p>方法一：暴力枚举<br />思路及算法</p><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><p>代码</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O (N²)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p><p>空间复杂度：O (1)。</p><p>方法二：哈希表<br />思路及算法</p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O (N) 降低到 O (1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><p>代码</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>hashtable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O (N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O (1) 地寻找 target - x。</p><p>空间复杂度：O (N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坏习惯</title>
      <link href="/introduction/%E5%9D%8F%E4%B9%A0%E6%83%AF/"/>
      <url>/introduction/%E5%9D%8F%E4%B9%A0%E6%83%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="九种弱者习惯"><a class="anchor" href="#九种弱者习惯">#</a> 九种弱者习惯</h3><p>一、九种弱者习惯，包括爱找借口、缺乏胆识、犹豫不决等，提醒读者要养成优秀的习惯，不断成长进步。</p><ul><li>习惯不好消耗生命，好习惯塑造自己</li><li>摒弃消极的念头，主动调整一个个微小的行为</li><li>去爱、攀山、追梦，去尝试，去尝试，去尝试</li></ul><p>二、犹豫、学习、拖延等现代职场中的常见问题，并给出了解决方案，鼓励人们积极行动，终身学习，克服拖延症。</p><ul><li>犹豫不决，害怕失败，浪费时间</li><li>不懂得学习，抛弃旧技能，容易被取代</li><li>拖延症会侵蚀人生，尝试 5 分钟定律</li></ul><p>三、避免生活和工作中的七种常见问题，如拖延症、缺乏恒心、害怕拒绝等，提出了解决方案，帮助人们更好地面对生活中的挑战。</p><ul><li>拖延会消耗生命，提前投入做事</li><li>成功的人有恒心，不要半途而废</li><li>人生的目标由自己定，不要习惯待在舒适区</li></ul><p>四、九种弱者习惯，包括懒惰、逃避现实等，并强调了积极面对生活的重要性，只有戒掉这些习惯才能迈向更好的未来。</p><ul><li>逃避现实会导致内心脆弱，生活也会加倍的报复回来</li><li>不断拥抱新的挑战，熬过一次次痛苦的蜕变，才能向更好的生活靠近</li><li>主动调整微小行为，改写自己的命运，把每一天过得充实而有意义</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUtrNHkxUDdzby8/c3BtX2lkX2Zyb209MzMzLjEwMDcudGlhbm1hLjEtMS0xLmNsaWNrJmFtcDt2ZF9zb3VyY2U9ZjllZWRmOTgzNzhhYTc3ZWIzNTZkMzM0M2JiYmU2MDE=">原文视频来源地址</span></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 生活习惯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人分享 </tag>
            
            <tag> 坏习惯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Nacos</title>
      <link href="/computer-science/java/springcloud/%E5%88%9D%E8%AF%86Nacos/"/>
      <url>/computer-science/java/springcloud/%E5%88%9D%E8%AF%86Nacos/</url>
      
        <content type="html"><![CDATA[<h2 id="初识nacos"><a class="anchor" href="#初识nacos">#</a> 初识 Nacos</h2><h3 id="nacos安装"><a class="anchor" href="#nacos安装">#</a> Nacos 安装</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/computer-science/java/arithmetic/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/computer-science/java/arithmetic/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法"><a class="anchor" href="#排序算法">#</a> 排序算法</h2><h3 id="冒泡排序法"><a class="anchor" href="#冒泡排序法">#</a> 冒泡排序法</h3><h3 id="选择排序法"><a class="anchor" href="#选择排序法">#</a> 选择排序法</h3><p><code>思路：</code> 选择一个元素作为最小元素（一般是第一个），然后将这个元素与数组其他元素进行比较，如果比它还小则将其最小元素赋值给它，比较完一轮后，将这个最小元素放入到新数组（排序好的数组）并从原数组剔除出去，如此反复操作 n 轮</p><p>** 时间复杂度:**O (n²)</p><p><code>代码：</code></p><p><code>java</code> :</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="2"></td><td><pre>     * 寻找最小元素</pre></td></tr><tr><td data-num="3"></td><td><pre>     * @param arr 数组</pre></td></tr><tr><td data-num="4"></td><td><pre>     * @return 最小元素索引</pre></td></tr><tr><td data-num="5"></td><td><pre>     */</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findSmallest</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> smallest <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> smallest_index <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> smallest<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                smallest <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                smallest_index <span class="token operator">=</span> i <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> smallest_index<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">/**</pre></td></tr><tr><td data-num="19"></td><td><pre>     * 返回去除元素的新数组</pre></td></tr><tr><td data-num="20"></td><td><pre>     * @param arr 原数组</pre></td></tr><tr><td data-num="21"></td><td><pre>     * @param element_index 最小元素索引</pre></td></tr><tr><td data-num="22"></td><td><pre>     * @return 新数组</pre></td></tr><tr><td data-num="23"></td><td><pre>     */</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> element_index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span>j <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span>element_index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                array<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> array<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token comment">/**</pre></td></tr><tr><td data-num="35"></td><td><pre>     * 选择排序算法</pre></td></tr><tr><td data-num="36"></td><td><pre>     * @param arr 原数组</pre></td></tr><tr><td data-num="37"></td><td><pre>     * @return 排序好的新数组</pre></td></tr><tr><td data-num="38"></td><td><pre>     */</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">chooseSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>newArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token keyword">int</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>            <span class="token keyword">int</span> smallest_index <span class="token operator">=</span> <span class="token function">findSmallest</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            newArr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>smallest_index<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            arr <span class="token operator">=</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>smallest_index<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token keyword">return</span> newArr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>python</code> :</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 寻找最小元素，并返回最小元素索引</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">def</span> <span class="token function">find_smallest</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    smallest <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    smallest_index <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> smallest<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            smallest <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            smallest_index <span class="token operator">=</span> i</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> smallest_index</pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 选择排序法</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">def</span> <span class="token function">choose_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    sort_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        smallest_index <span class="token operator">=</span> find_smallest<span class="token punctuation">(</span>arr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        sort_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>arr<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>smallest_index<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> sort_list</pre></td></tr></table></figure><h3 id="快速排序法"><a class="anchor" href="#快速排序法">#</a> 快速排序法</h3><p>** 思路:** 选择数组中的一个元素作为基准元素，然后将其他元素与其比较，如果小的放入左边一个数组，如果大的放入右边的数组，反复操作，直至子数组只有 0 个或者 1 个元素为止。</p><p><strong>时间复杂度</strong>：O (nlogn)</p><p><code>python</code> :</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 快速排序法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 思路：选择数组中的一个元素作为基准元素，然后将其他元素与其比较，如果小的放入左边一个数组，如果大的放入右边的数组，反复操作，直至子数组只有 0 个或者 1 个元素为止</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 这种思路可以使用递归的方式来做，将数组只有 0 个或者 1 个元素作为递归终止条件，后面再做归纳 --- 选择基准元素和子数组递归。</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 快速排序法</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment"># 如果数组长度小于 2，则直接返回数组</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">return</span> arr</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment"># 将数组第一个元素作为基准元素</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment"># 生成小于等于基准元素的子数组</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    less <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i <span class="token operator">&lt;=</span> pivot<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment"># 生成大于基准元素的子数组</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    right <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i <span class="token operator">></span> pivot<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment"># 合并数组</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> quick_sort<span class="token punctuation">(</span>less<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">+</span> quick_sort<span class="token punctuation">(</span>right<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>quick_sort<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>java:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="2"></td><td><pre>     * 快速排序法</pre></td></tr><tr><td data-num="3"></td><td><pre>     * @param arr 原数组</pre></td></tr><tr><td data-num="4"></td><td><pre>     * @return</pre></td></tr><tr><td data-num="5"></td><td><pre>     */</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 如果数组长度小于等于 1，直接返回 基准条件</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 取第一个元素作为基准元素</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span> privot <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 获取比基准元素小和比基准元素大的数组</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> less <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> greater <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> privot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                greater<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                less<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 递归上述行为，直至获取到两个数组排序好的数组</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lessArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>less<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> greaterArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>greater<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token comment">// 将其复制到新数组中</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>lessArr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>lessArr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>greaterArr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>array<span class="token punctuation">,</span>lessArr<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>greaterArr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        array<span class="token punctuation">[</span>lessArr<span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> privot <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> array <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon负载均衡</title>
      <link href="/computer-science/java/springcloud/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/computer-science/java/springcloud/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="ribbon负载均衡"><a class="anchor" href="#ribbon负载均衡">#</a> Ribbon 负载均衡</h2><h3 id="负载均衡原理"><a class="anchor" href="#负载均衡原理">#</a> 负载均衡原理</h3><p>规则接口是<strong> IRule</strong><br /> 默认实现是<strong> ZoneAvoidanceRule</strong>，根据<strong> zone</strong> 选择服务列表，然后轮询</p><h3 id="负载均衡策略"><a class="anchor" href="#负载均衡策略">#</a> 负载均衡策略</h3><p>代码方式：配置灵活，但修改时需要重新打包布<br />配置方式：直观，方便，无需重新打包发布但是无法做全局配置</p><h3 id="懒加载"><a class="anchor" href="#懒加载">#</a> 懒加载</h3><p>开启饥饿加载<br />指定饥饿加载的微服务名称</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka注册中心</title>
      <link href="/computer-science/java/springcloud/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/computer-science/java/springcloud/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="eureka注册中心"><a class="anchor" href="#eureka注册中心">#</a> Eureka 注册中心</h2><h3 id="服务调用出现的问题"><a class="anchor" href="#服务调用出现的问题">#</a> 服务调用出现的问题</h3><ul><li>服务消费者该如何获取服务提供这的地址信息？</li><li>如果有多个服务提供者，消费者该如何选择？</li><li>消费者如何得知服务提供这的健康状态？</li></ul><h3 id="eureka的作用"><a class="anchor" href="#eureka的作用">#</a> Eureka 的作用</h3><ul><li>消费者该如何获取服务提供者的具体信息？<ul><li>服务提供者启动时向 Eureka 注册自己的信息</li><li>eureka 保存这些信息</li><li>消费者根据服务名称向 eureka 拉取提供者信息</li></ul></li><li>如果有多个服务提供者，消费者该如何选择？<ul><li>服务消费者利用负载均衡算法，从服务列表中挑选一个</li></ul></li><li>消费者该如何感知服务提供者健康状态？<ul><li>服务提供者会每 30 秒向 EurekaServer 发送心跳请求，报告健康状态</li><li>eureka 会更新服务列表信息，心跳不正常会被剔除</li><li>消费者就可以拉取到最新的信息</li></ul></li></ul><h3 id="搭建eureka服务注册中心"><a class="anchor" href="#搭建eureka服务注册中心">#</a> 搭建 Eureka 服务注册中心</h3><ol><li><p>引入依赖</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>starter<span class="token operator">-</span>netflix<span class="token operator">-</span>eureka<span class="token operator">-</span>server<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></pre></td></tr></table></figure></li><li><p>编写启动类，并在启动类添加 **@EnableEurekaServer** 注解</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@SpringBootApplication</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@EnableEurekaServer</span> <span class="token comment">// 添加注解</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>配置文件上添加 eureka 服务器地址信息</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">eureka</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">client</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka <span class="token comment">#注册中心地址</span></pre></td></tr></table></figure></li></ol><h3 id="搭建eureka客户端中心"><a class="anchor" href="#搭建eureka客户端中心">#</a> 搭建 Eureka 客户端中心</h3><ol><li><p>引入依赖</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>       <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre>       <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>starter<span class="token operator">-</span>netflix<span class="token operator">-</span>eureka<span class="token operator">-</span>client<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></pre></td></tr></table></figure></li><li><p>编写启动类，并在启动类上添加 **@EnableEurekaClient** 注解</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.user.mapper"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@SpringBootApplication</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token annotation punctuation">@EnableEurekaClient</span> <span class="token comment">// 添加注解开启服务注册</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserApplication</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">UserApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>配置文件上写明 Eureka 服务端的地址信息</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spring</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token key atrule">application</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice <span class="token comment"># user 服务的名称</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">## eureka 服务中心</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token key atrule">eureka</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token key atrule">client</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka</pre></td></tr></table></figure></li></ol><h3 id="eureka服务发现拉取"><a class="anchor" href="#eureka服务发现拉取">#</a> Eureka 服务发现 / 拉取</h3><ol><li><p>前提：完成 Eureka 服务端和 Eureka 客户端的搭建，并且服务中心可以看到这些注册到 Eureka 的服务</p></li><li><p>在原来<strong> RestTemplate</strong> 上加入 **@LoadBalanced** 注解</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@LoadBalanced</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>将原来使用 RestTemplate 发送 http 请求时写入的 ip 地址替换成 eureka 服务端中的服务名，即 spring.application.name 字段的名称</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 2. 利用 restTemplate 发起 http 请求，查询用户 这里原来是 ip 地址，替换成服务名称</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://userservice/user/"</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">User</span> user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识微服务</title>
      <link href="/computer-science/java/springcloud/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/computer-science/java/springcloud/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="认识微服务"><a class="anchor" href="#认识微服务">#</a> 认识微服务</h2><p>微服务是一种经过良好架构设计的<strong>分布式</strong>架构方案，微服务架构特征：</p><ul><li>单一职责：微服务拆分力度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发。</li><li>面向服务：微服务对外暴露业务接口。</li><li>自治：团队独立、技术独立、数据独立、部署独立。</li><li>隔离性强：服务调用做好隔离、容错、降级、避免级联现象。</li></ul><h3 id="面试题"><a class="anchor" href="#面试题">#</a> 面试题：</h3><p>单体架构与分布式架构的区别？</p><ul><li>单体架构特点：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</li><li>分布式架构特点：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东，淘宝。</li></ul><p>微服务：一种良好的分布式架构</p><ul><li>优点：拆分力度更小、服务更独立、耦合度更低</li><li>缺点：架构非常复杂，运维、监控、部署难度提高</li></ul><h3 id="微服务结构"><a class="anchor" href="#微服务结构">#</a> 微服务结构</h3><p>微服务这种方案需要技术框架来落地，全球的互联网公司都在积极尝试自己的微服务落地技术。在国内最知名的就是 SpringCloud 和阿里巴巴的 Dubbo。</p><p><img data-src="https://pic.imgdb.cn/item/64ee8d49661c6c8e54729987.jpg" alt="image-20230830082645810" /></p><h3 id="微服务技术对比"><a class="anchor" href="#微服务技术对比">#</a> 微服务技术对比</h3><p><img data-src="https://pic.imgdb.cn/item/64ee8ec5661c6c8e547347d2.jpg%5B" alt="" /></p><h3 id="企业需求"><a class="anchor" href="#企业需求">#</a> 企业需求</h3><p><img data-src="https://pic.imgdb.cn/item/64ee8f18661c6c8e5473504b.jpg" alt="" /></p><h3 id="springcloud"><a class="anchor" href="#springcloud">#</a> SpringCloud</h3><ul><li><strong>SpringCloud</strong> 是目前国内使用最广泛的微服务架构。官网地址：<span class="exturl" data-url="aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWNsb3Vk">Spring Cloud</span></li><li><strong>SpringCloud</strong> 集成了各种微服务功能组件，并基于<strong> SpringBoot</strong> 实现了这些组件的自动装配，从而提供了良好的开箱即用体验：</li></ul><p><img data-src="https://pic.imgdb.cn/item/64ee90d0661c6c8e54740733.jpg" alt="微服务技术体系" /></p><h3 id="服务拆分与远程调用"><a class="anchor" href="#服务拆分与远程调用">#</a> 服务拆分与远程调用</h3><p><strong>服务拆分注意事项</strong></p><ol><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其他微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其他微服务调用</li></ol><h3 id="微服务远程调用"><a class="anchor" href="#微服务远程调用">#</a> 微服务远程调用</h3><p><strong>提供者与消费者</strong></p><ul><li><p>服务提供者：一次业务中，被其他为服务调用的服务。（提供接口给其他微服务）</p></li><li><p>服务消费者：一次业务中，调用其他为服务的服务。（调用其他微服务提供的接口）</p></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操纵性理学</title>
      <link href="/psychology/%E6%93%8D%E7%BA%B5%E5%BF%83%E7%90%86%E5%AD%A6/%E6%93%8D%E7%BA%B5%E6%80%A7%E7%90%86%E5%AD%A6/"/>
      <url>/psychology/%E6%93%8D%E7%BA%B5%E5%BF%83%E7%90%86%E5%AD%A6/%E6%93%8D%E7%BA%B5%E6%80%A7%E7%90%86%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="操纵心理学"><a class="anchor" href="#操纵心理学">#</a> 操纵心理学</h2><p><strong>不要相信” 都是为你好 “，拒绝做软柿子</strong></p><p><strong>修炼你的心，懂得爱人，也要懂得爱自己</strong></p><p><strong>你的人生应该永远由你来选择</strong></p><h3 id=""><a class="anchor" href="#">#</a> </h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 心理学 </category>
          
          <category> 操纵心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人原则</title>
      <link href="/introduction/%E5%8E%9F%E5%88%99/"/>
      <url>/introduction/%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="原则"><a class="anchor" href="#原则">#</a> 原则</h3><ul><li><p>生活态度</p><ul><li><p>身体健康</p><p><strong>身体健康乃是第一要素，所有的原则都要建立在身体健康上。</strong></p><ol><li>平时熬夜不得超过两点，保证睡眠充足。</li><li>早上起床工作日在 8 点左右起来，休息日要在 10 点之前起来。</li><li>平时加强锻炼，平时锻炼需要控制在 1 个小时左右，室内室外就行。</li><li>饭菜不能过于重，需要合理膳食，荤素搭配，而且每天需要补充水果。</li></ol></li><li><p>心理健康</p><p><strong>基于我经常内耗的情况，我需要适当性地进行心理上的培养</strong></p><ol><li>休息日必须要画上 2 个小时进行心理书籍阅读。</li><li>工作日晚上睡觉时可以进行心理书籍阅读。</li><li>内耗时必须要寻找事情做，听音乐和看视频。</li><li>以正常合适的心态面对自己的各种情绪，不能因为某种情绪影响自己的状态就直接一刀切的忽视。</li></ol></li></ul></li><li><p>人际关系</p><ul><li><p>朋友关系</p><p><strong>朋友关系是我一直以来十分重视的关系，但是自己却经常把它搞砸，来自于内心深处那喜欢责怪他人的怪异心理。</strong></p><ol><li>建立朋友关系前，需要了解他人的脾性，如果经常性对你沉默，忽略，必须要收住热情，不能再进行主动行为。</li><li>由于建立的朋友关系大多是人走茶凉，所以，无论是对你多好的朋友，如果走后没有主动寻找过，都一律当做普通朋友，并以待之。</li><li>当与朋友相处时，如果遇到三观不合的情况下，不可直接指出，一定要远离，但不可操之过急，需不引起注意远离。</li><li>当与朋友相处时，如果遇到想做的事情可能遭受他的厌恶时，即当面骂人，无视风险，非他人所求就强行帮助（这点尤其注意），鉴于我的性格，我很容易在感到不适时，喜欢无视他人感受，无视所有风险，以个人感受为主要驱动来行动，我必须要改掉无视他人感受和风险，如果有这种想法，一定要旁敲侧击来询问他人建议，并非直接询问我的行为，而是表达情绪，即适当性抱怨他人忽略或者无视我的行为，适当表达出自己的不满，如果他人还是不管，3 次就可直接远离，切记不可摊牌翻脸，要循序渐进。</li><li>与朋友相处时，遇到朋友嘲讽时，如果非常生气，不可以直接无视，将自己之前喜欢辩解，喜欢对喷的行为改为话语：烦死了、闭嘴、我想安静点。切勿真正动气来报复。</li><li>不要主动窥探他人的生活，这点尤为重要，无论我多么寂寞，多么孤独，都不能主动地去窥探别人生活，或者主动性地进入别人生活。</li><li>朋友心情低落时，如果自己想要帮助他人，将自己的行为看成普通帮助，不能将其当做自己的好，而且一定得面对面交流，即在尊重他人的情况下，再进行适当帮助。</li></ol></li><li><p>亲情关系</p><ul><li><p>直系血缘关系（家人）</p><ol><li>关心家人必须建立在自己的状态良好的情况下，不能再将父母当做无话不说的对象，控制自己在父母面前抱怨的样子，收起自己遇到父母说话不符合自己三观的情况下驳斥，放下反驳的心态去面对家人，家人相处不是来辩论的，一切顺着他们来就行，听而不从，可以解决大部分问题。</li><li>父亲是个十分强硬，执拗的人，一旦认定的观念就不可能改变，所以他说的话全可以当做他个人不得志的倾述，我只需要当个附和的旁人即可，无需去跟他辩解，反驳他的话，改变别人不是我的人生课题，一定要原谅别人的无知，别人的愚蠢，别人的冒犯，因为为别人的问题生气和纠正别人不是自己的课题。</li><li>母亲是一个个性软弱，喜欢隐忍自己感受的人，她的性别十分恶劣，某种程度上，我的母亲带给我的影响大于父亲，所以遇到母亲在我面前歇斯底里地骂我不孝的情况，一定不要慌张，也不要辩解，如果可以的话，尽量避免这种情况即可。</li><li>妹妹被我伤害的最多，所以我需要做的是做好哥哥该干的事，不要再用之前的脾气面对她，也不能在他面前与父母对峙，吵架，平时有时间就联系一下她也可以。</li></ol></li><li><p>嫡系血缘关系（亲戚）</p><ol><li>好好对待自己的亲戚，但是不能以自己为第一个大学生的身份来教导别人，记住，永远不要轻易地去教导别人，千万不要轻易地去扶别人，这是我这 20 多年来犯的最大的一个错，我必须要纠正自己好为人师的性格，觉得自己比别人更懂某些道理，其实懂不懂从当前的境遇就可以看出来一个人是否是强人，那种别人口中厉害的人，我没有必要去强行地倾述自己的见解。只要不是自己悟出来的，别人强行灌输的道理我都不认，这辈子我只认我自己亲身悟出来的道理。</li><li>我并不是一个孝顺的好孩子，但是很多情况下，我不能得势并不是因为别人给我的个个理由，而是由于我自己的心境不如别人，我看了太多的人生大道，经历了很多低谷期，也抑郁过，自己也堕落过，但我还是那个我，我并不是希望别人来拯救的人，所以，我不会允许也不会求助于别人，尤其是亲戚，我不会抖露出自己的志向，也不会向任何人倾述我的烦恼和自己的计划。言多必失，这是我十分惨重的教训。</li></ol></li></ul></li><li><p>爱情关系</p><ol><li>我不确定自己是否需要爱情，但是如若真的遇到了自己喜爱的女孩，我一定会尽力地去爱她，不主动寻找是我对爱情的谨慎，因为有我父母娃娃亲的教训，我出生在一个并不和睦的家庭，这一切都是由于父母之间长期的内斗，窝里横让我对于爱情有了恐惧，这种恐惧是刻在骨子里的，我并不排斥这种情感，就像父母之间的矛盾一样，我只是对爱情有了更高的要求，我更倾向于寻找一个各方面都符合自己的，更愿意与我一同的爱情关系，而不是那种喜欢窝里斗，时常吵架的家庭。</li></ol></li><li><p>同事关系</p><ol><li>同事永远不是朋友，之前的我可以为任何人做任何事，现在的我以为，职场中我这种人首要做的就是藏拙，并且示弱，并请教别人，这是我第一段事业的教训，由于我的傲慢和好为人师，喜欢关注别人的成长，让我一直以来其实都是没有成长。我必须竭尽所能地关注自己的成长，我必须要以自己的事情为主，别人发生了什么事，我都无需去主动指教，我真的，这种喜欢教导别人的性格真的是十分阻碍我。</li><li>同事可以亲近，但是不能过度亲近，永远不能给自己的同事暴露自己的家事，自己的状态，自己的私事，这点尤为重要，别人的微信，别人的消息，不能恶心地去留意，上级的要求，要主动跟上级交代和沟通好细节，否则不要轻易地动手。</li><li>自己的事情不能让别人做，别人的事情，自己不轻易地做，如果上级再次要求自己的一些无理的要求，需要明确自己的态度，就算妥协也要表现出自己是被胁迫且是非我意愿的，这样其实就可以让我在其他事情上有更多的发语权，在职场上，没有朋友，没有知遇之恩的老板和上级，只有自己的利益，一定要在职场中保护好自己，不要成为顺从的羊，也不要成为过于尖锐的出头鸟。</li></ol></li></ul></li><li><p>责任</p><ul><li><p>个人责任</p><ol><li>我的责任是爱自己，首要就是爱自己，不再依靠别人的安慰，不再依靠别人的帮助，我要成为一个情感独立，生存独立的人，前 20 年都是掌握在我父母中，父母利用赡养我的理由一直以来都是采取打压来让我顺从他们，我到现在我甚至可以肯定他们可能还更喜欢看到我现在的样子，不要看他们对我的样子十分唾弃，其实内心都是在甩锅，底层的人其实就是那么一些人，喜欢落井下石，好为人师，喜欢打压别人，不知道如何爱自己，更不知道怎么爱别人。</li><li>我的责任其实首要是对要对自己的未来做准备，我要做什么，我想做什么，我必须要在有生之年在一些事中做出自己的功绩，我知道这很难，因为我个人天马行空，喜欢做一些不符实际的幻想，喜欢做白日梦，但是我对于这个世界，这个世界有什么组成，我们又是因为什么诞生在这个世界，我想要寻求答案，但是我知道，这并不是我这个普通人能做到的，但我会努力地去做，去做给自己看，有些事情，并不是一时没有能力就不能做的，我可以时时刻刻地去努力。</li></ol></li><li><p>家庭责任</p><ol><li>家庭责任书首要是孝敬父母，我知道我现在并无能力，也经常让父母担心，顶撞父母，当然，我会慢慢改，在我稳定好我自己后，我也会慢慢地回敬自己的父母，我并不想再去纠正自己的父母了，我决定要以当面顺从父母，背后应以自己来做，不能将父母的看法，父母的态度，父母的干预来影响自己，从此以后，我必须要谨慎对待各种观点，各种人对我的看法，我要做到表面无动于衷，背后分析利害并及时改正，司马懿的那句话说的好，这辈子走来，没有敌人，只有朋友，无论是谁，敌人也好，朋友也罢，都是能够让自己更加能够了解自己的人，不能对他们产生一些诸如怨恨、嫉妒、报复等等负面的情感来看别人，需要以礼待之，记住，自己的心态永远是自己最好的风水，不能让情绪，尤其是负面情绪击溃自己。</li><li>家庭责任第二点则是重建自己的影响力，不能让父母或者某些亲戚来干涉自己的事情，至于某些事情需要自己的时候，必须要有自己的确认，否则我不会将任何诸如钱财、信息、等等给父母许诺的任何人，我要逐渐找到自己信任的人，自己的父母生于底层，他们这一生都活在底层的环境，喜欢胡乱地结交别人，喜欢让我也去结交，哪怕别人和自己根本没有任何意愿，强行地撮合是最不能持久的，父亲一直以来都喜欢结交别人，然而忽略了自己，从不想着自己能怎么去帮助别人，一昧地想着如何从自己的关系中获益，这是十分不明智的做法，这世界上真的有人会因为一场谈话，一个谈不上很好的过去的缘分就去帮助一个根本不熟悉的人的孩子吗，我觉得这是不太可能的，所以，我一直坚信着，如果自己不强大，自己没有别人看中的特点和利益，是永远都不可能找到那所谓的贵人相助的，我觉得很多情况下，如果是别人强行塞给我的来帮助我的人，我反而不会去回报他，反而是那些在我真正遇到难处，自己主动或者被人发现并给予帮助的人，那种感恩，那种感情才是真挚的，总而言之，雪中送炭是真挚而且难得的。强塞给我，不是我想要的，我会觉得并不是我想，却与我父母来强行干预我的因果的人是无论如何都是无法让我产生好感的。</li></ol></li><li><p>岗位责任</p></li></ul></li><li><p>能力</p><ul><li><p>工作能力</p></li><li><p>生活能力</p></li><li><p>学习能力</p></li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 个人简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原则 </tag>
            
            <tag> 个人详情 </tag>
            
            <tag> 个人分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础面试题</title>
      <link href="/computer-science/java/interview/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/computer-science/java/interview/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="java基础面试题"><a class="anchor" href="#java基础面试题">#</a> Java 基础面试题</h2><ol><li><p><strong>什么是 Java？它有哪些特点？</strong></p><p>Java 是一种广泛应用于软件开发的高级编程语言。它具有以下特点：</p><ol><li><strong>跨平台性（Platform Independence）</strong>：Java 代码可以在不同操作系统上运行，这是通过将 Java 源代码编译成字节码（Bytecode），然后在 Java 虚拟机（JVM）上执行的方式实现的。这使得 Java 成为一个跨平台的编程语言，只需要编写一次代码，就可以在多个平台上运行。</li><li><strong>面向对象（Object-Oriented）</strong>：Java 是一种面向对象的编程语言，它支持面向对象编程的特性，如封装、继承和多态。这有助于组织和管理复杂的代码和数据。</li><li><strong>简单性（Simplicity）</strong>：Java 的语法设计相对简单明了，易于学习和使用。它删除了许多容易引起错误的复杂功能，同时提供了强大的标准库。</li><li><strong>健壮性（Robustness）</strong>：Java 提供了内置的错误检查和异常处理机制，有助于编写健壮的代码。它还通过垃圾回收机制管理内存，减少了内存泄漏的风险。</li><li><strong>安全性（Security）</strong>：Java 在安全性方面有很多内置特性。例如，它可以防止未经授权的访问和执行，提供了安全的网络通信和文件访问机制。</li><li><strong>多线程支持（Multithreading）</strong>：Java 内置了多线程支持，使得开发多线程应用程序变得相对容易。多线程可以提高程序的并发性能。</li><li><strong>高性能（High Performance）</strong>：虽然 Java 是解释性语言，但它通过即时编译器（Just-In-Time Compiler，JIT Compiler）将字节码转化为本机机器代码，提高了执行速度。此外，Java 的运行时环境（JRE）经过优化，具有高效的垃圾回收机制和内存管理。</li><li><strong>大型标准库（Rich Standard Library）</strong>：Java 提供了丰富的标准库，包含了各种类和方法，用于执行各种任务，从文件操作到网络通信，从数据库访问到用户界面开发。</li><li><strong>开源社区支持（Open Source Community）</strong>：Java 拥有庞大的开源社区，这意味着有大量的开源库和框架可供使用，能够加速应用程序的开发。</li></ol><p>总之，Java 是一种强大且多用途的编程语言，适用于各种不同类型的应用程序，从移动应用到企业级应用都有广泛的应用。其跨平台性、可靠性、安全性和性能等特点使其成为一种流行的编程语言。</p></li><li><p><strong>Java 中的四种访问修饰符是什么？</strong></p><p>在 Java 中，有四种主要的访问修饰符，用于控制类、方法、变量和其他类成员的访问权限。这些修饰符包括：</p><ol><li><strong>public（公共）</strong>：public 是最宽松的访问修饰符。使用 public 修饰的类、方法或变量可以被任何其他类访问，无论这些类是否在同一包内，甚至是否在不同的包内。public 成员对外部代码是可见的。</li><li><strong>private（私有）</strong>：private 是最严格的访问修饰符。使用 private 修饰的类成员只能在包含该成员的类内部访问，其他类无法访问它。这种封装性有助于隐藏类的内部实现细节。</li><li><strong>protected（受保护的）</strong>：protected 修饰符用于限制成员的访问范围，但相对于 private，它更宽松一些。protected 成员可以被定义在同一包内的类访问，也可以被继承自该类的子类访问，即使这些子类位于不同的包中。</li><li><strong>默认（不加修饰符）</strong>：如果一个成员没有显式地使用 public、private 或 protected 进行修饰，它就具有默认的访问权限，也被称为包访问权限。默认访问权限仅限于同一包内的类可以访问该成员，而其他包中的类无法访问。</li></ol><p>这些访问修饰符允许程序员控制类成员的可见性和访问权限，从而实现封装、继承和多态等面向对象编程的特性。通过选择适当的访问修饰符，可以确保代码的安全性和可维护性。</p></li><li><p><strong>什么是面向对象编程（OOP）？</strong></p><p>面向对象编程（Object-Oriented Programming，简称 OOP）是一种常用于软件开发的编程范式或方法论。它的核心思想是将现实世界中的事物抽象为对象，然后通过对象之间的交互来实现程序的设计和编码。面向对象编程的主要概念包括以下几个方面：</p><ol><li><strong>对象（Object）</strong>：对象是面向对象编程的基本单元，它代表了现实世界中的某个具体事物或抽象概念。每个对象都有状态（属性或数据）和行为（方法或函数）。</li><li><strong>类（Class）</strong>：类是对象的模板或蓝图，它定义了对象的共同属性和行为。类可以看作是一种用户自定义的数据类型。</li><li><strong>封装（Encapsulation）</strong>：封装是将数据和方法打包到一个类中，并将类的内部细节隐藏起来，只暴露必要的接口给外部。这有助于数据的安全性和代码的模块化。</li><li><strong>继承（Inheritance）</strong>：继承允许一个类从另一个类继承属性和方法。子类（派生类）可以继承父类（基类）的特性，并可以在其基础上添加新的属性和行为。</li><li><strong>多态（Polymorphism）</strong>：多态允许不同类的对象对相同的方法做出不同的响应。这使得程序可以根据实际对象的类型来动态选择方法的调用，提高了代码的灵活性。</li></ol><p>面向对象编程的优点包括：</p><ul><li>模块化：将代码划分为独立的类和对象，便于管理和维护。</li><li>可重用性：可以通过继承和多态实现代码的重用。</li><li>扩展性：可以通过添加新的类和对象来扩展程序的功能。</li><li>抽象性：可以将现实世界中的复杂问题抽象为简单的对象和类。</li><li>面向对象编程语言如 Java、C++、Python 等广泛应用于软件开发领域，它们提供了丰富的工具和特性，支持面向对象编程的实践。</li></ul></li><li><p><strong>什么是多态性（Polymorphism）？</strong></p><p>多态性（Polymorphism）是面向对象编程中的一个重要概念，它指的是对象可以根据其实际类型表现出多种不同的行为或形态的能力。多态性允许不同类的对象对相同的方法或操作做出不同的响应，这样可以提高代码的灵活性和可扩展性。</p><p>多态性主要有两种实现方式：</p><ol><li><p><strong>编译时多态性（Compile-time Polymorphism）</strong>：也称为静态多态性。它发生在编译阶段，通常与函数重载（方法重载）相关。在编译时，编译器会根据方法的名称、参数列表或参数类型来确定调用哪个方法。编译时多态性是静态的，因为在编译时就能够确定调用哪个方法。</p><p>例如，Java 中的方法重载就是一种编译时多态性的体现。</p></li><li><p><strong>运行时多态性（Runtime Polymorphism）</strong>：也称为动态多态性。它发生在程序运行时，通常与方法的重写（覆盖）和继承相关。在运行时，根据实际对象的类型来决定调用哪个方法。运行时多态性是动态的，因为它需要在程序运行时才能够确定。</p><p>例如，Java 中的方法重写（覆盖）和接口的实现就是一种运行时多态性的体现。在运行时，子类对象可以替代父类对象，以一种更具体的方式来实现相同的方法。</p></li></ol><p>多态性的优点包括：</p><ul><li>灵活性：允许使用通用的代码来处理不同类型的对象。</li><li>可扩展性：可以轻松添加新的子类或扩展现有类的功能。</li><li>代码重用：通过接口和抽象类可以实现代码的重用。</li></ul><p>多态性是面向对象编程的一个重要特性，它有助于提高代码的可维护性和可扩展性，同时使代码更加通用和灵活。</p></li><li><p><strong>Java 中的异常处理机制是什么？</strong></p><p>Java 中的异常处理机制是一种用于处理程序执行期间可能出现的错误或异常情况的机制。异常是指程序在执行过程中遇到的不正常或错误的情况，例如除以零、空指针引用等。Java 提供了强大的异常处理机制，使程序员能够更好地管理和处理这些异常情况，以避免程序崩溃或产生不可预测的结果。</p><p>以下是 Java 中异常处理机制的关键要点：</p><ol><li><p><strong>异常类（Exception Class）</strong>：Java 中的异常是用类表示的，每种异常情况都有对应的异常类。异常类是 Throwable 类的子类，分为两种类型：受检查异常（Checked Exception）和非受检查异常（Unchecked Exception）。</p><ul><li>受检查异常：必须在代码中显式地捕获或声明，否则无法通过编译。通常表示一些可预测的错误，如文件不存在或网络连接中断。</li><li>非受检查异常：不要求显式捕获或声明，通常是 RuntimeException 及其子类。表示一些编程错误，如空指针异常或数组越界异常。</li></ul></li><li><p><strong>try-catch 语句块</strong>：用于捕获和处理异常的关键结构。在 try 块中编写可能引发异常的代码，然后在 catch 块中指定处理异常的代码。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 可能引发异常的代码</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionType</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 处理异常的代码</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>finally 块</strong>：可选的 finally 块用于指定无论是否发生异常都会执行的代码。通常用于资源清理，如关闭文件或释放资源。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 可能引发异常的代码</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionType</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 处理异常的代码</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 无论是否发生异常，都会执行的代码</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>抛出异常</strong>：使用 <code>throw</code>  关键字手动抛出异常。可以创建自定义异常类，并在需要时抛出。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CustomException</span><span class="token punctuation">(</span><span class="token string">"This is a custom exception."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>自定义异常</strong>：除了 Java 提供的异常类，程序员可以创建自定义异常类来表示特定的异常情况。自定义异常类通常继承自 <code>Exception</code>  或其子类。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 构造函数和其他方法</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><p>Java 的异常处理机制使程序员能够更好地识别、处理和记录异常情况，从而提高了程序的稳定性和可维护性。通过合理地使用 try-catch 块、自定义异常和 finally 块，可以更好地管理和处理各种异常情况。</p></li><li><p><strong>什么是 Java 的自动装箱和拆箱？</strong></p><p>Java 的自动装箱（Autoboxing）和拆箱（Unboxing）是 Java 语言的一项特性，用于在基本数据类型（如 int、double）和对应的包装类（如 Integer、Double）之间进行转换。这个特性使得编程更加方便，不再需要手动进行类型转换。</p><p>下面分别解释自动装箱和拆箱：</p><ol><li><p><strong>自动装箱（Autoboxing）</strong>：自动装箱是指将基本数据类型转换为对应的包装类对象，这个过程是自动进行的。例如，将 int 类型的值赋给 Integer 对象，编译器会自动进行装箱。</p><pre><code>javaCopy codeint primitiveInt = 42;Integer boxedInt = primitiveInt; // 自动装箱</code></pre><p>在这个例子中， <code>primitiveInt</code>  是基本的 int 类型，但它可以自动装箱为 <code>boxedInt</code> ，变成了 Integer 对象。</p></li><li><p><strong>自动拆箱（Unboxing）</strong>：自动拆箱是指将包装类对象转换为基本数据类型，也是自动进行的。例如，将 Integer 对象的值赋给 int 类型的变量，编译器会自动进行拆箱。</p><pre><code>javaCopy codeInteger boxedInt = 42;int primitiveInt = boxedInt; // 自动拆箱</code></pre><p>在这个例子中， <code>boxedInt</code>  是 Integer 对象，但它可以自动拆箱为 <code>primitiveInt</code> ，变成了 int 类型的值。</p></li></ol><p>自动装箱和拆箱提高了 Java 代码的可读性和简洁性，不需要显式地调用 <code>intValue()</code> 、 <code>doubleValue()</code>  等方法来进行类型转换。这个特性在集合类（如 ArrayList）中尤其有用，因为集合类通常要求存储的是对象而不是基本数据类型。在 Java 5 及以后的版本中引入了自动装箱和拆箱功能。</p></li><li><p><strong>什么是 Java 的集合框架？</strong><br />Java 的集合框架（Collection Framework）是一组用于存储和操作对象的类和接口。它提供了一种统一的方式来管理和操作各种数据集合，如列表、集合、映射等。Java 集合框架的主要目标是提供高性能、高可扩展性、高可用性和类型安全的数据结构。</p><p>Java 集合框架的主要特点包括：</p><ol><li><strong>接口和实现类</strong>：集合框架定义了一组接口，包括 <code>List</code> 、 <code>Set</code> 、 <code>Map</code>  等，以及许多具体的实现类，如 <code>ArrayList</code> 、 <code>HashSet</code> 、 <code>HashMap</code>  等。这种分离的设计允许开发人员根据需求选择适当的数据结构。</li><li><strong>通用性</strong>：Java 集合框架支持泛型，允许您在集合中存储特定类型的对象，提高了类型安全性。</li><li><strong>高性能</strong>：集合框架中的数据结构经过精心设计和优化，以提供高性能的数据访问和操作。</li><li><strong>多线程支持</strong>：集合框架包括线程安全的集合类，可以在多线程环境中使用，如 <code>ConcurrentHashMap</code> 。</li><li><strong>可扩展性</strong>：集合框架支持可扩展的接口和类，允许开发人员创建自定义的集合类型。</li><li><strong>算法</strong>：集合框架提供了各种算法和方法，如排序、搜索和遍历，使数据操作更加方便。</li><li><strong>互操作性</strong>：集合框架允许不同实现的集合之间进行互操作，以及与数组之间的互操作。</li><li><strong>异常处理</strong>：集合框架定义了一些异常，如 <code>NullPointerException</code>  和 <code>ConcurrentModificationException</code> ，以帮助开发人员识别和处理常见的问题。</li></ol><p>Java 集合框架是 Java 编程中非常重要的一部分，几乎每个 Java 程序都会用到它，无论是开发桌面应用程序、Web 应用程序还是后端服务。通过选择适当的集合类型，开发人员可以更轻松地实现各种数据操作和算法，并提高代码的可维护性和可读性。</p></li><li><p><strong>什么是 Java 线程？如何创建和启动线程？</strong></p><p>Java 线程是 Java 编程语言中用于实现多任务并发执行的基本单元。线程是程序的执行路径，每个线程都是独立运行的，可以同时执行不同的任务。Java 的多线程编程允许程序在同一进程中创建多个线程，这些线程可以并发执行，提高程序的性能和响应能力。</p><p>要创建和启动线程，可以使用 Java 的两种方法：</p><ol><li><p><strong>继承 Thread 类</strong>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义一个继承自 Thread 类的新类</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 线程执行的代码</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程运行中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 在主程序中创建并启动线程</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token class-name">MyThread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建线程对象</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动线程</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>实现 Runnable 接口</strong>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义一个实现 Runnable 接口的类</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 线程执行的代码</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程运行中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 在主程序中创建并启动线程</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token class-name">MyRunnable</span> myRunnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 Runnable 对象</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>myRunnable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建线程，将 Runnable 对象传递给线程</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动线程</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><p>以上两种方式都可以创建并启动线程，但一般来说，推荐使用第二种方式，实现 Runnable 接口，因为这种方式更加灵活，允许多个线程共享同一个 Runnable 对象，降低了资源消耗。</p><p>线程一旦启动，它会执行 <code>run()</code>  方法中的代码，您可以在 <code>run()</code>  方法中编写线程的主要逻辑。线程的执行是异步的，多个线程可以同时运行，因此要小心处理多线程之间的共享数据和同步问题，以避免竞态条件和数据不一致性的问题。在 Java 中，可以使用 <code>synchronized</code>  关键字和其他同步工具来实现线程之间的同步。</p></li><li><p><strong>什么是 Java 的同步机制？</strong></p></li><li><p><strong>Java 中的 final 关键字有什么用途？</strong></p></li><li><p><strong>Java 中如何实现多线程？</strong></p></li><li><p><strong>什么是 Java 的垃圾回收机制？</strong></p></li><li><p><strong>Java 中的静态方法和实例方法有何区别？</strong></p></li><li><p><strong>什么是 Java 的反射（Reflection）？</strong></p></li><li><p><strong>Java 中的抽象类和接口有何区别？</strong></p></li><li><p><strong>Java 中的 equals () 和 hashCode () 方法有何作用？</strong></p></li><li><p><strong>什么是 Java 的异常处理机制？</strong></p></li><li><p><strong>Java 中的序列化是什么？如何实现对象的序列化和反序列化？</strong></p></li><li><p><strong>Java 中的泛型（Generics）是什么？有什么作用？</strong></p></li><li><p><strong>Java 中的 Lambda 表达式是什么？有什么作用？</strong></p></li><li><p><strong>Java 中的重载和重写有何区别？</strong></p></li><li><p><strong>Java 中的 String 和 StringBuffer（或 StringBuilder）有何区别？</strong></p></li><li><p><strong>Java 中的静态块（static block）有何作用？</strong></p></li><li><p><strong>Java 中的异常分类及继承关系是什么？</strong></p></li><li><p><strong>Java 中的装箱和拆箱是什么？</strong></p></li><li><p><strong>Java 中的枚举（Enum）是什么？有什么用途？</strong></p></li><li><p><strong>Java 中的 finalize () 方法有何作用？</strong></p></li><li><p><strong>Java 中的注解是什么？有哪些内置注解？</strong></p></li><li><p><strong>Java 中的内部类有哪些类型？</strong></p></li><li><p><strong>Java 中的 ClassLoader 是什么？有哪些类加载器？</strong></p></li><li><p><strong>什么是 Java 中的泛型（Generics）？</strong></p></li><li><p><strong>Java 中的多态（Polymorphism）是什么？如何实现多态？</strong></p></li><li><p><strong>Java 中的集合框架（Collections Framework）包括哪些主要接口和类？</strong></p></li><li><p><strong>Java 中的序列化（Serialization）是什么？如何实现对象的序列化和反序列化？</strong></p></li><li><p><strong>Java 中的异常处理机制是怎样的？</strong></p></li><li><p><strong>Java 中的线程安全是什么？如何实现线程安全？</strong></p></li><li><p><strong>Java 中的反射（Reflection）是什么？如何使用反射获取类的信息和调用方法？</strong></p></li><li><p><strong>Java 中的 JVM（Java 虚拟机）是什么？它的作用是什么？</strong></p></li><li><p><strong>Java 中的 Lambda 表达式是什么？它的作用是什么？</strong></p></li><li><p><strong>Java 中的数据类型有哪些？基本数据类型和引用数据类型有什么区别？</strong></p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java开发面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口限流</title>
      <link href="/computer-science/java/notice/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/"/>
      <url>/computer-science/java/notice/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="接口限流"><a class="anchor" href="#接口限流">#</a> 接口限流</h2><p>​接口限流是一种常见的应用程序设计模式，它的目的是为了防止系统超载，保持系统的可用性。在应用程序中，特别是在大规模分布式系统中，限制流量可以有效地控制系统负载，并避免由于高负载而导致的系统崩溃。</p><p>​限流通常是通过对请求进行计数并根据规则拒绝过多的请求来实现的。一些常见的限流策略包括： <code>固定窗口限流</code> 、 <code>滑动窗口限流</code> 、 <code>令牌桶限流</code> 、 <code>漏桶限流</code> 等。这些策略可以根据应用程序的实际需求和性能要求进行调整和组合使用。</p><p>​在实现接口限流时，需要考虑一些因素，如：最大请求速率、平均请求速率、请求处理时间、负载均衡等。一些常见的限流工具和框架，如 <code>Guava RateLimiter</code> 、 <code>Redis</code> 、 <code>Nginx</code>  等可以帮助实现接口限流。</p><p>​当我们的应用程序需要处理大量请求时，为了保证系统的稳定性和性能，我们可以使用接口限流技术来控制请求的流量，避免系统过载。以下是一些接口限流的解决方案：</p><ol><li><code>计数器算法</code> ：计数器算法是一种简单的限流算法，它基于一个计数器，每当有一个请求进来时就增加计数器的值。当计数器的值超过了设定的阈值时，就拒绝请求。这种算法的优点是简单易懂，但是不适合处理突发流量。</li><li><code>漏桶算法</code> ：漏桶算法是一种经典的限流算法，它模拟了一个水桶，请求就像水流一样，流进漏桶中，当漏桶已经满了时，就拒绝请求。漏桶算法可以有效地平滑请求的流量，避免系统过载。</li><li><code>令牌桶算法</code> ：令牌桶算法也是一种流量控制算法，它基于一个令牌桶，每当有一个请求进来时就从令牌桶中获取一个令牌，如果令牌桶中没有令牌了，就拒绝请求。令牌桶算法可以平滑处理请求的流量，适用于高峰期的流量控制。</li><li><code>基于时间窗口的限流</code> ：基于时间窗口的限流算法是一种常用的限流算法，它将时间分为多个窗口，每个窗口都有一个固定的限制值。当一个请求进来时，就检查当前时间窗口的请求数是否超过了限制值，如果超过了就拒绝请求。这种算法适用于处理大量请求的场景，可以有效地保护系统。</li><li><code>基于并发数的限流</code> ：基于并发数的限流算法是一种简单的限流算法，它通过监控系统中的并发请求数来控制请求的流量，当并发请求数达到一定阈值时就拒绝请求。这种算法适用于处理大量并发请求的场景，可以有效地保护系统。</li></ol><p>​这些都是常见的接口限流解决方案，我们可以根据实际业务场景选择合适的算法来保证系统的稳定性和性能。</p><h3 id="接口限流实现示例"><a class="anchor" href="#接口限流实现示例">#</a> 接口限流实现示例</h3><h4 id="1计数器算法"><a class="anchor" href="#1计数器算法">#</a> 1. 计数器算法</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">long</span> lastResetTime<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxRequestsPerSecond<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> requestCount<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxRequestsPerSecond<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>lastResetTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>maxRequestsPerSecond <span class="token operator">=</span> maxRequestsPerSecond<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>requestCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">allowRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">long</span> currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTime <span class="token operator">></span> lastResetTime <span class="token operator">+</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 1 second has passed since last reset</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            lastResetTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            requestCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>requestCount <span class="token operator">>=</span> maxRequestsPerSecond<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// limit reached</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            requestCount<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// request allowed</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个  <code>Counter</code>  类使用了一个  <code>lastResetTime</code>  变量来记录最后一次计数器清零的时间，以及一个  <code>requestCount</code>  变量来记录在这个时间段内已经发出的请求数量。在  <code>allowRequest()</code>  方法中，先判断是否已经过了 1 秒钟，如果是，则将计数器清零；然后再判断当前请求是否超过了每秒最大请求量，如果是，则返回  <code>false</code> ，否则将计数器加一，并返回  <code>true</code> 。可以根据实际需求来调整每秒最大请求量。</p><h4 id="2漏桶算法"><a class="anchor" href="#2漏桶算法">#</a> 2. 漏桶算法</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeakyBucket</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxBucketSize<span class="token punctuation">;</span>  <span class="token comment">// 漏桶容量</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> flowRate<span class="token punctuation">;</span>       <span class="token comment">// 水流出速度</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> currentSize<span class="token punctuation">;</span>    <span class="token comment">// 当前桶内水量</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">long</span> lastLeakTime<span class="token punctuation">;</span>  <span class="token comment">// 上次漏水时间</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">LeakyBucket</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxBucketSize<span class="token punctuation">,</span> <span class="token keyword">int</span> flowRate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>maxBucketSize <span class="token operator">=</span> maxBucketSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>flowRate <span class="token operator">=</span> flowRate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>currentSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>lastLeakTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">allowRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 计算桶内水量</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        currentSize <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> currentSize <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> lastLeakTime<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">*</span> flowRate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        lastLeakTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 如果桶未满，且本次请求能被放入桶中，则放行</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentSize <span class="token operator">+</span> tokens <span class="token operator">&lt;=</span> maxBucketSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            currentSize <span class="token operator">+=</span> tokens<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">// 否则拒绝请求</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的示例中，我们通过  <code>maxBucketSize</code>  定义了漏桶的容量， <code>flowRate</code>  定义了漏桶的出水速度，也就是漏水的速度。 <code>currentSize</code>  记录当前漏桶中的水量， <code>lastLeakTime</code>  记录上次漏水时间。在  <code>allowRequest</code>  方法中，首先计算当前漏桶中的水量，然后判断本次请求是否能被放入漏桶中，如果能，则将请求放入漏桶中，并返回  <code>true</code> ，否则返回  <code>false</code> ，拒绝请求。</p><h4 id="3令牌桶算法"><a class="anchor" href="#3令牌桶算法">#</a> 3. 令牌桶算法</h4><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TokenBucket</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 桶的容量</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 当前桶内令牌数量</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> tokens <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 每秒增加的令牌数量</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> rate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 上一次令牌添加的时间戳</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">long</span> lastAddTime<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TokenBucket</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">int</span> rate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>rate <span class="token operator">=</span> rate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>lastAddTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 添加令牌</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token function">addTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 判断桶内令牌数量是否足够</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tokens<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>tokens<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token operator">-</span>tokens<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// 计算当前时间和上一次添加令牌的时间之间应该添加的令牌数量</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">int</span> addTokens <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> lastAddTime<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000.0</span> <span class="token operator">*</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token comment">// 如果添加的令牌数量不足一个，则不添加</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>addTokens <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token comment">// 添加令牌</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>tokens<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>addTokens<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token comment">// 更新上一次添加令牌的时间</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>lastAddTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>以上代码中， <code>TokenBucket </code> 类实现了令牌桶算法，使用了 <code> AtomicInteger</code>  类型的 tokens 属性保存桶内令牌数量。通过  <code>acquire(int tokens)</code>  方法尝试获取指定数量的令牌，如果令牌数量足够，则从桶内移除令牌，并返回 true；否则返回 false。同时，该类的 <code> addTokens()</code>  方法会根据当前时间和上一次添加令牌的时间计算出应该添加的令牌数量，并添加到桶内。</p><h4 id="4基于时间窗口的限流"><a class="anchor" href="#4基于时间窗口的限流">#</a> 4. 基于时间窗口的限流</h4><p>当我们使用基于时间窗口的限流时，我们可以使用一个固定大小的数组来存储每个时间窗口内的请求数量。我们可以定义一个时间窗口的长度，例如每秒钟或每分钟一个时间窗口，然后根据这个时间窗口内的请求数量来判断是否允许该请求通过。</p><p>下面是一个使用基于时间窗口的限流的 Java 代码示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimeWindowRateLimiter</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span> <span class="token comment">// 限流阈值</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> windowSize<span class="token punctuation">;</span> <span class="token comment">// 时间窗口大小，单位为毫秒</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicIntegerArray</span> counters<span class="token punctuation">;</span> <span class="token comment">// 存储每个时间窗口内的请求数量</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ScheduledExecutorService</span> scheduler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">TimeWindowRateLimiter</span><span class="token punctuation">(</span><span class="token keyword">int</span> limit<span class="token punctuation">,</span> <span class="token keyword">long</span> windowSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">=</span> limit<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>windowSize <span class="token operator">=</span> windowSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        counters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicIntegerArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>windowSize <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据时间窗口大小计算数组长度</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        scheduler <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        scheduler<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">resetCounter</span><span class="token punctuation">,</span> windowSize<span class="token punctuation">,</span> windowSize<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定期清空计数器</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">allowRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">long</span> currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">int</span> currentCounterIndex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>currentTime <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">%</span> counters<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 计算当前时间窗口所在的数组下标</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">int</span> currentCount <span class="token operator">=</span> counters<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span>currentCounterIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计数器加一</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentCount <span class="token operator">></span> limit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断请求数量是否超过限流阈值</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            counters<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span>currentCounterIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计数器减一</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resetCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> counters<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            counters<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空计数器</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>​在上面的代码中，我们使用  <code>AtomicIntegerArray</code>  数组来存储每个时间窗口内的请求数量。每次有请求进来时，我们先获取当前时间并计算出当前时间所在的时间窗口所在的数组下标。然后将该数组下标对应的计数器加一，判断是否超过限流阈值，如果超过则将计数器减一并拒绝该请求。定期清空计数器以开始新的时间窗口。</p><p>​基于并发数的限流一般采用信号量（ <code>Semaphore</code> ）实现，以下是一个简单的 Java 代码示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Semaphore</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLimit</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Semaphore</span> semaphore<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ConcurrentLimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>        semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>limit<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取信号量</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放信号量</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>​在上面的代码中，我们通过  <code>Semaphore </code> 来实现并发数的限制。在构造方法中传入限制的并发数，每次执行任务时先调用  <code>semaphore.acquire()</code>  来获取一个信号量，如果已经达到限制的并发数，就会被阻塞直到有一个信号量被释放。任务执行完后再调用  <code>semaphore.release()</code>  来释放信号量。</p><p>​你可以在需要进行限流的地方使用  <code>ConcurrentLimit</code>  对象来包装需要执行的任务，以实现并发数限制。</p><h3 id="接口防刷各算法运用场景"><a class="anchor" href="#接口防刷各算法运用场景">#</a> 接口防刷各算法运用场景</h3><p>接口防刷是指限制同一用户在短时间内对接口的访问次数，以保证系统的稳定和安全。下面是几种常见的接口防刷算法及其运用场景：</p><ol><li><code>计数器算法</code> ：适用于对 <code>API</code>  调用频率的轻量级限制。例如在小型应用中使用，当同一个用户在指定时间内达到一定请求次数时会返回错误信息，可以用于防止恶意刷接口行为。</li><li><code>漏桶算法</code> ：适用于平滑请求流量，对突发流量进行限制。例如在 <code> CDN</code>  服务中可以利用漏桶算法对网络带宽进行限流，防止网络瘫痪。</li><li><code>令牌桶算法</code> ：适用于在短时间内处理请求数量比较少的场景，可以平滑地处理请求流量。例如在 <code>Web</code>  应用中限制用户的请求数量，可以保护系统不被恶意攻击。</li><li><code>基于时间窗口的限流</code> ：适用于对接口并发访问数的限制。例如在高并发访问场景下，使用时间窗口限制访问频率，避免了瞬时流量过大导致服务不可用的情况。</li><li><code>基于并发数的限流</code> ：适用于对服务能力的控制，避免服务过载。例如在分布式系统中，使用基于并发数的限流算法，可以控制分布式服务间的调用数量，避免服务调用链条过长，导致服务过载。</li></ol><p>需要注意的是，不同的算法适用于不同的场景，选择适合自己的算法是非常重要的。同时，防刷算法只是防止恶意访问的一种手段，还需要通过其他安全措施来保证系统的安全性。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> 接口开发 </tag>
            
            <tag> 开发注意事项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口防刷</title>
      <link href="/computer-science/java/notice/%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7/"/>
      <url>/computer-science/java/notice/%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="接口防刷"><a class="anchor" href="#接口防刷">#</a> 接口防刷</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> 接口开发 </tag>
            
            <tag> 开发注意事项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口实现幂等性</title>
      <link href="/computer-science/java/notice/%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/computer-science/java/notice/%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="接口实现幂等性"><a class="anchor" href="#接口实现幂等性">#</a> 接口实现幂等性</h2><p>实现接口的幂等性是为了确保多次调用同一个接口请求不会对系统产生不一致的影响，即使请求被重复发送或执行多次，也应该具有相同的效果。在设计和实现接口时，可以采用以下一些方法来确保接口的幂等性：</p><ol><li><strong>唯一请求标识符（Request Identifier）</strong>：每个请求都应该携带一个唯一的标识符，服务器端可以使用这个标识符来识别请求是否已经被处理。如果已经处理过的请求再次到达，服务器可以忽略它，或者返回相同的响应。常见的方式是在请求头或请求参数中包含一个唯一的标识符。</li><li><strong>幂等性检测</strong>：在服务器端，可以对每个请求进行幂等性检测。这通常需要记录已经处理的请求标识符，并在接收到请求时检查该标识符是否已经存在于记录中。如果存在，表示请求已经被处理，可以返回相同的响应。</li><li><strong>使用 HTTP 方法</strong>：HTTP 方法本身具有幂等性。例如，GET、PUT、DELETE 等 HTTP 方法都是幂等的，因此在 RESTful API 设计中，可以合理地使用这些方法来实现接口的幂等性。</li><li><strong>幂等性响应处理</strong>：客户端在接收到服务器的响应后，应该能够处理重复的响应。这意味着客户端需要能够处理重复请求的情况，例如，不重复执行同一个操作或合理地处理响应数据。</li><li><strong>使用事务</strong>：如果接口涉及到数据库操作或其他需要事务支持的操作，可以使用数据库事务或分布式事务来确保幂等性。事务可以保证一系列操作的原子性和幂等性。</li><li><strong>版本控制</strong>：在接口中引入版本控制，使得不同版本的接口可以共存。这样，即使客户端使用旧版本接口发送请求，新版本接口仍然能够正确处理请求，保证幂等性。</li><li><strong>幂等性测试</strong>：在接口开发阶段，需要进行幂等性测试，模拟多次请求，检查接口的行为是否满足幂等性要求。</li><li><strong>接口文档和规范</strong>：在接口文档中明确指出接口的幂等性行为，以便客户端开发者正确使用接口。</li></ol><p>综上所述，实现接口的幂等性需要在接口设计和开发阶段采取一系列策略和措施，以确保不同请求对系统的影响是可预测和一致的。这对于构建可靠的分布式系统和 API 非常重要。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> 接口开发 </tag>
            
            <tag> 开发注意事项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/computer-science/java/javase/Java%E9%9B%86%E5%90%88/"/>
      <url>/computer-science/java/javase/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="java集合"><a class="anchor" href="#java集合">#</a> Java 集合</h2><h3 id="arraylist"><a class="anchor" href="#arraylist">#</a> ArrayList</h3><h3 id="linkedlist"><a class="anchor" href="#linkedlist">#</a> LinkedList</h3><h3 id="vector"><a class="anchor" href="#vector">#</a> Vector</h3><h3 id="set"><a class="anchor" href="#set">#</a> Set</h3><h3 id="hashmap"><a class="anchor" href="#hashmap">#</a> HashMap</h3><h3 id="hashset"><a class="anchor" href="#hashset">#</a> HashSet</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序言</title>
      <link href="/psychology/%E8%87%AA%E5%8D%91%E4%B8%8E%E8%B6%85%E8%B6%8A/%E5%BA%8F%E8%A8%80/"/>
      <url>/psychology/%E8%87%AA%E5%8D%91%E4%B8%8E%E8%B6%85%E8%B6%8A/%E5%BA%8F%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="自卑与超越"><a class="anchor" href="#自卑与超越">#</a> 自卑与超越</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 心理学 </category>
          
          <category> 自卑与超越 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学知识 </tag>
            
            <tag> 阿德勒心理学 </tag>
            
            <tag> 自卑与超越 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言元素</title>
      <link href="/computer-science/python/basic/02.%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/"/>
      <url>/computer-science/python/basic/02.%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="语言元素"><a class="anchor" href="#语言元素">#</a> 语言元素</h2><h4 id="指令和程序"><a class="anchor" href="#指令和程序">#</a> 指令和程序</h4><p>计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们大多数时候使用的计算机，虽然它们的元器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg2JUFGJUMyJUI3JUU4JUFGJUJBJUU0JUJDJThBJUU2JTlCJUJDJUU3JUJCJTkzJUU2JTlFJTg0"> “冯・诺依曼结构”</span> 的计算机。“冯・诺依曼结构” 有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种 “逢二进一” 的计数法，跟我们人类使用的 “逢十进一” 的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012 年是上一个所谓的 “太阳纪” 的最后一年，而 2013 年则是新的 “太阳纪” 的开始，后来这件事情被以讹传讹的方式误传为”2012 年是玛雅人预言的世界末日 “这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示 1，低电压表示 0），于是在 “冯・诺依曼结构” 的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJThDJUU4JUJGJTlCJUU1JTg4JUI2">维基百科</span>或者<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20=">百度百科</span>科普一下。</p><blockquote><p><strong>说明</strong>：近期关于<strong>量子计算机</strong>的研究已经被推倒了风口浪尖，量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息。2018 年 6 月，Intel 宣布开发出新款量子芯片并通过了在接近绝对零度环境下的测试；2019 年，IBM 和 Google 都推出了自己的量子计算机。</p></blockquote><h3 id="变量和类型"><a class="anchor" href="#变量和类型">#</a> 变量和类型</h3><p>在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python 中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。</p><ul><li>整型：Python 中可以处理任意大小的整数（Python 2.x 中有 <code>int</code>  和 <code>long</code>  两种类型的整数，但这种区分对 Python 来说意义不大，因此在 Python 3.x 中整数只有 int 这一种了），而且支持二进制（如 <code>0b100</code> ，换算成十进制是 4）、八进制（如 <code>0o100</code> ，换算成十进制是 64）、十进制（ <code>100</code> ）和十六进制（ <code>0x100</code> ，换算成十进制是 256）的表示法。</li><li>浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如 <code>123.456</code> ）之外还支持科学计数法（如 <code>1.23456e2</code> ）。</li><li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如 <code>'hello'</code>  和 <code>&quot;hello&quot;</code> , 字符串还有原始字符串表示法、字节字符串表示法、Unicode 字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。</li><li>布尔型：布尔值只有 <code>True</code> 、 <code>False</code>  两种值，要么是 <code>True</code> ，要么是 <code>False</code> ，在 Python 中，可以直接用 <code>True</code> 、 <code>False</code>  表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如 <code>3 &lt; 5</code>  会产生布尔值 <code>True</code> ，而 <code>2 == 1</code>  会产生布尔值 <code>False</code> ）。</li><li>复数型：形如 <code>3+5j</code> ，跟数学上的复数表示一样，唯一不同的是虚部的 <code>i</code>  换成了 <code>j</code> 。实际上，这个类型并不常用，大家了解一下就可以了。</li></ul><h4 id="变量命名"><a class="anchor" href="#变量命名">#</a> 变量命名</h4><p>对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在 Python 中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。</p><ul><li>硬性规则：<ul><li>变量名由字母（广义的 Unicode 字符，不包括特殊字符）、数字和下划线构成，数字不能开头。</li><li>大小写敏感（大写的 <code>a</code>  和小写的 <code>A</code>  是两个不同的变量）。</li><li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。</li></ul></li><li>PEP 8 要求：<ul><li>用小写字母拼写，多个单词用下划线连接。</li><li>受保护的实例属性用单个下划线开头（后面会讲到）。</li><li>私有的实例属性用两个下划线开头（后面会讲到）。</li></ul></li></ul><p>当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到见名知意也是非常重要的。</p><h4 id="变量的使用"><a class="anchor" href="#变量的使用">#</a> 变量的使用</h4><p>下面通过几个例子来说明变量的类型和变量使用。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>使用变量保存数据并进行加减乘除运算</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="5"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="6"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="7"></td><td><pre>a <span class="token operator">=</span> <span class="token number">321</span></pre></td></tr><tr><td data-num="8"></td><td><pre>b <span class="token operator">=</span> <span class="token number">12</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>    <span class="token comment"># 333</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span>    <span class="token comment"># 309</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span>    <span class="token comment"># 3852</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span>    <span class="token comment"># 26.75</span></pre></td></tr></table></figure><p>在 Python 中可以使用 <code>type</code>  函数对变量的类型进行检查。程序设计中函数的概念跟数学上函数的概念是一致的，数学上的函数相信大家并不陌生，它包括了函数名、自变量和因变量。如果暂时不理解这个概念也不要紧，我们会在后续的章节中专门讲解函数的定义和使用。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>使用type()检查变量的类型</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="5"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="6"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="7"></td><td><pre>a <span class="token operator">=</span> <span class="token number">100</span></pre></td></tr><tr><td data-num="8"></td><td><pre>b <span class="token operator">=</span> <span class="token number">12.345</span></pre></td></tr><tr><td data-num="9"></td><td><pre>c <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">5j</span></pre></td></tr><tr><td data-num="10"></td><td><pre>d <span class="token operator">=</span> <span class="token string">'hello, world'</span></pre></td></tr><tr><td data-num="11"></td><td><pre>e <span class="token operator">=</span> <span class="token boolean">True</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># &lt;class 'int'></span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># &lt;class 'float'></span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># &lt;class 'complex'></span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># &lt;class 'str'></span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># &lt;class 'bool'></span></pre></td></tr></table></figure><p>可以使用 Python 中内置的函数对变量类型进行转换。</p><ul><li><code>int()</code> ：将一个数值或字符串转换成整数，可以指定进制。</li><li><code>float()</code> ：将一个字符串转换成浮点数。</li><li><code>str()</code> ：将指定的对象转换成字符串形式，可以指定编码。</li><li><code>chr()</code> ：将整数转换成该编码对应的字符串（一个字符）。</li><li><code>ord()</code> ：将字符串（一个字符）转换成对应的编码（整数）。</li></ul><p>下面的代码通过键盘输入两个整数来实现对两个整数的算术运算。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>使用input()函数获取键盘输入(字符串)</pre></td></tr><tr><td data-num="3"></td><td><pre>使用int()函数将输入的字符串转换成整数</pre></td></tr><tr><td data-num="4"></td><td><pre>使用print()函数输出带占位符的字符串</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="7"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="8"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="9"></td><td><pre>a <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'a = '</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>b <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'b = '</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d + %d = %d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d - %d = %d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d * %d = %d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d / %d = %f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d // %d = %d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">//</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d %% %d = %d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d ** %d = %d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">**</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面的 print 函数中输出的字符串使用了占位符语法，其中 <code>%d</code>  是整数的占位符， <code>%f</code>  是小数的占位符， <code>%%</code>  表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成 <code>%%</code> ），字符串之后的 <code>%</code>  后面跟的变量值会替换掉占位符然后输出到终端中，运行上面的程序，看看程序执行结果就明白啦。</p></blockquote><h3 id="运算符"><a class="anchor" href="#运算符">#</a> 运算符</h3><p>Python 支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。除了我们之前已经用过的赋值运算符和算术运算符，我们稍后会陆续讲到其他运算符的使用。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code>   <code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code>   <code>+</code>   <code>-</code></td><td>按位取反，正负号</td></tr><tr><td><code>*</code>   <code>/</code>   <code>%</code>   <code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code>   <code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code>   <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code>   <code>\|</code></td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code>   <code>&lt;</code>   <code>&gt;</code>   <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code>   <code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code>    <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code>   <code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code>   <code>or</code>   <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code>   <code>+=</code>   <code>-=</code>   <code>*=</code>   <code>/=</code>   <code>%=</code>   <code>//=</code>   <code>**=</code>   <code>&amp;=</code>   <code>|=</code>   <code>^=</code>   <code>&gt;&gt;=</code>   <code>&lt;&lt;=</code></td><td>（复合）赋值运算符</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。</p></blockquote><h4 id="赋值运算符"><a class="anchor" href="#赋值运算符">#</a> 赋值运算符</h4><p>赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>赋值运算符和复合赋值运算符</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="5"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="6"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="7"></td><td><pre>a <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="8"></td><td><pre>b <span class="token operator">=</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="9"></td><td><pre>a <span class="token operator">+=</span> b        <span class="token comment"># 相当于：a = a + b</span></pre></td></tr><tr><td data-num="10"></td><td><pre>a <span class="token operator">*=</span> a <span class="token operator">+</span> <span class="token number">2</span>    <span class="token comment"># 相当于：a = a * (a + 2)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>      <span class="token comment"># 算一下这里会输出什么</span></pre></td></tr></table></figure><h3 id="比较运算符和逻辑运算符"><a class="anchor" href="#比较运算符和逻辑运算符">#</a> 比较运算符和逻辑运算符</h3><p>比较运算符有的地方也称为关系运算符，包括 <code>==</code> 、 <code>!=</code> 、 <code>&lt;</code> 、 <code>&gt;</code> 、 <code>&lt;=</code> 、 <code>&gt;=</code> ，我相信没有什么好解释的，大家一看就能懂，唯一需要提醒的是比较相等用的是 <code>==</code> ，请注意这个地方是两个等号，因为 <code>=</code>  是赋值运算符，我们在上面刚刚讲到过， <code>==</code>  才是比较相等的比较运算符。比较运算符会产生布尔值，要么是 <code>True</code>  要么是 <code>False</code> 。</p><p>逻辑运算符有三个，分别是 <code>and</code> 、 <code>or</code>  和 <code>not</code> 。 <code>and</code>  字面意思是 “而且”，所以 <code>and</code>  运算符会连接两个布尔值，如果两个布尔值都是 <code>True</code> ，那么运算的结果就是 <code>True</code> ；左右两边的布尔值有一个是 <code>False</code> ，最终的运算结果就是 <code>False</code> 。相信大家已经想到了，如果 <code>and</code>  左边的布尔值是 <code>False</code> ，不管右边的布尔值是什么，最终的结果都是 <code>False</code> ，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在 <code>and</code>  运算符左边为 <code>False</code>  的情况下，右边的表达式根本不会执行。 <code>or</code>  字面意思是 “或者”，所以 <code>or</code>  运算符也会连接两个布尔值，如果两个布尔值有任意一个是 <code>True</code> ，那么最终的结果就是 <code>True</code> 。当然， <code>or</code>  运算符也是有短路功能的，在它左边的布尔值为 <code>True</code>  的情况下，右边的表达式根本不会执行。 <code>not</code>  运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，后面的布尔值如果是 <code>True</code>  运算结果就是 <code>False</code> ，而后面的布尔值如果是 <code>False</code>  则运算结果就是 <code>True</code> 。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>比较运算符和逻辑运算符的使用</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="5"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="6"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="7"></td><td><pre>flag0 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="8"></td><td><pre>flag1 <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">></span> <span class="token number">2</span></pre></td></tr><tr><td data-num="9"></td><td><pre>flag2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="10"></td><td><pre>flag3 <span class="token operator">=</span> flag1 <span class="token keyword">and</span> flag2</pre></td></tr><tr><td data-num="11"></td><td><pre>flag4 <span class="token operator">=</span> flag1 <span class="token keyword">or</span> flag2</pre></td></tr><tr><td data-num="12"></td><td><pre>flag5 <span class="token operator">=</span> <span class="token keyword">not</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'flag0 ='</span><span class="token punctuation">,</span> flag0<span class="token punctuation">)</span>    <span class="token comment"># flag0 = True</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'flag1 ='</span><span class="token punctuation">,</span> flag1<span class="token punctuation">)</span>    <span class="token comment"># flag1 = True</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'flag2 ='</span><span class="token punctuation">,</span> flag2<span class="token punctuation">)</span>    <span class="token comment"># flag2 = False</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'flag3 ='</span><span class="token punctuation">,</span> flag3<span class="token punctuation">)</span>    <span class="token comment"># flag3 = False</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'flag4 ='</span><span class="token punctuation">,</span> flag4<span class="token punctuation">)</span>    <span class="token comment"># flag4 = True</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'flag5 ='</span><span class="token punctuation">,</span> flag5<span class="token punctuation">)</span>    <span class="token comment"># flag5 = False</span></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：比较运算符的优先级高于赋值运算符，所以 <code>flag0 = 1 == 1</code>  先做 <code>1 == 1</code>  产生布尔值 <code>True</code> ，再将这个值赋值给变量 <code>flag0</code> 。 <code>print</code>  函数可以输出多个值，多个值之间可以用 <code>,</code>  进行分隔，输出的内容之间默认以空格分开。</p></blockquote><h3 id="练习"><a class="anchor" href="#练习">#</a> 练习</h3><h4 id="练习1华氏温度转换为摄氏温度"><a class="anchor" href="#练习1华氏温度转换为摄氏温度">#</a> 练习 1：华氏温度转换为摄氏温度。</h4><blockquote><p>提示：华氏温度到摄氏温度的转换公式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mo stretchy="false">(</mo><mi>F</mi><mo>−</mo><mn>32</mn><mo stretchy="false">)</mo><mo>÷</mo><mn>1.8</mn></mrow><annotation encoding="application/x-tex">C=(F - 32) \div 1.8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">8</span></span></span></span>。</p></blockquote><p>参考答案：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>将华氏温度转换为摄氏温度</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="5"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="6"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="7"></td><td><pre>f <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入华氏温度: '</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>c <span class="token operator">=</span> <span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1.8</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%.1f华氏度 = %.1f摄氏度'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：在使用 <code>print</code>  函数输出时，也可以对字符串内容进行格式化处理，上面 <code>print</code>  函数中的字符串 <code>%.1f</code>  是一个占位符，稍后会由一个 <code>float</code>  类型的变量值替换掉它。同理，如果字符串中有 <code>%d</code> ，后面可以用一个 <code>int</code>  类型的变量值替换掉它，而 <code>%s</code>  会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中 <code>&#123;f:.1f&#125;</code>  和 <code>&#123;c:.1f&#125;</code>  可以先看成是 <code>&#123;f&#125;</code>  和 <code>&#123;c&#125;</code> ，表示输出时会用变量 <code>f</code>  和变量 <code>c</code>  的值替换掉这两个占位符，后面的 <code>:.1f</code>  表示这是一个浮点数，小数点后保留 1 位有效数字。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>f<span class="token punctuation">:</span><span class="token format-spec">.1f</span><span class="token punctuation">&#125;</span></span><span class="token string">华氏度 = </span><span class="token interpolation"><span class="token punctuation">&#123;</span>c<span class="token punctuation">:</span><span class="token format-spec">.1f</span><span class="token punctuation">&#125;</span></span><span class="token string">摄氏度'</span></span><span class="token punctuation">)</span></pre></td></tr></table></figure></blockquote><h4 id="练习2输入圆的半径计算计算周长和面积"><a class="anchor" href="#练习2输入圆的半径计算计算周长和面积">#</a> 练习 2：输入圆的半径计算计算周长和面积。</h4><p>参考答案：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>输入半径计算圆的周长和面积</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="5"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="6"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="7"></td><td><pre>radius <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入圆的半径: '</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>perimeter <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">3.1416</span> <span class="token operator">*</span> radius</pre></td></tr><tr><td data-num="9"></td><td><pre>area <span class="token operator">=</span> <span class="token number">3.1416</span> <span class="token operator">*</span> radius <span class="token operator">*</span> radius</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'周长: %.2f'</span> <span class="token operator">%</span> perimeter<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'面积: %.2f'</span> <span class="token operator">%</span> area<span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="练习3输入年份判断是不是闰年"><a class="anchor" href="#练习3输入年份判断是不是闰年">#</a> 练习 3：输入年份判断是不是闰年。</h4><p>参考答案：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>输入年份 如果是闰年输出True 否则输出False</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="5"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="6"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="7"></td><td><pre>year <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入年份: '</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 如果代码太长写成一行不便于阅读 可以使用 \ 对代码进行折行</span></pre></td></tr><tr><td data-num="9"></td><td><pre>is_leap <span class="token operator">=</span> year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> year <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token keyword">or</span> \</pre></td></tr><tr><td data-num="10"></td><td><pre>          year <span class="token operator">%</span> <span class="token number">400</span> <span class="token operator">==</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>is_leap<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：比较运算符会产生布尔值，而逻辑运算符 <code>and</code>  和 <code>or</code>  会对这些布尔值进行组合，最终也是得到一个布尔值，闰年输出 <code>True</code> ，平年输出 <code>False</code> 。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="/computer-science/java/javase/String%E7%B1%BB/"/>
      <url>/computer-science/java/javase/String%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="string类"><a class="anchor" href="#string类">#</a> String 类</h3><p>​ <code>String</code>  是 <code>Java</code>  中非常常用的一个类，它代表了一个字符串对象。在 <code>Java</code>  中，字符串是不可变的，也就是说，一旦一个字符串对象被创建，它的值就不能被改变。因此，每次对字符串进行修改，都会创建一个新的字符串对象。</p><h3 id="string类为什么是不可变的"><a class="anchor" href="#string类为什么是不可变的">#</a> String 类为什么是不可变的？</h3><p>​String 类的不可变特性指的是 String 实例的值一旦被创建就不能被修改。这意味着对一个 String 对象进行操作时，如果需要修改其值，实际上是创建了一个新的 String 对象，并将新对象的引用赋给原对象。这种特性有助于提高程序的性能和安全性。</p><p>​从源码层面来看，String 类中的不可变特性是通过使用 final 关键字和 private 修饰符来实现的。String 类中的每个方法都不会修改原有的 String 对象，而是返回一个新的 String 对象，以保持原有的 String 对象的不可变性。</p><p>​例如，String 类中的 <code>concat</code>  方法可以将两个字符串连接起来，返回一个新的 String 对象，而不会修改原有的字符串：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">String</span> str3 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建新的 String 对象，值为 "HelloWorld"</span></pre></td></tr></table></figure><p>​另外，String 类还有一种常用的创建方式，即使用字符串字面值创建对象。这种方式在 Java 虚拟机中被优化，称为字符串常量池（String Pool）。当使用字符串字面值创建一个 String 对象时，Java 虚拟机会首先在字符串常量池中查找是否已存在该值的字符串对象，如果存在则返回该对象的引用，否则创建一个新的 String 对象并加入字符串常量池。例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> <span class="token comment">// 创建新的 String 对象并加入字符串常量池</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> <span class="token comment">// 直接返回字符串常量池中的引用，与 str1 引用同一个对象</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建新的 String 对象，不在字符串常量池中</span></pre></td></tr></table></figure><p>​由于 String 的不可变特性和字符串常量池的存在，可以安全地共享字符串对象，从而提高程序的性能和安全性。</p><h3 id="string类有很多实用的方法例如"><a class="anchor" href="#string类有很多实用的方法例如">#</a> <strong>String 类有很多实用的方法，例如：</strong></h3><ul><li><code>length()</code> ：获取字符串的长度。</li><li><code>charAt(int index)</code> ：获取指定索引位置的字符。</li><li><code>substring(int beginIndex, int endIndex)</code> ：获取指定索引范围内的子字符串。</li><li><code>concat(String str)</code> ：将指定字符串连接到此字符串的末尾。</li><li><code>indexOf(String str)</code> ：返回指定子字符串第一次出现的索引。</li><li><code>equals(Object anObject)</code> ：将此字符串与指定对象进行比较。</li><li><code>toUpperCase()</code> ：将字符串中的所有字符转换为大写。</li><li><code>toLowerCase()</code> ：将字符串中的所有字符转换为小写。</li><li>...</li></ul><p><strong>以下是 String 类的常用方法的例子：</strong></p><ol><li><code>length()</code>  方法：获取字符串的长度。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// length = 12</span></pre></td></tr></table></figure><ol start="2"><li><code>charAt(int index)</code>  方法：获取指定位置的字符。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> c <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c = 'e'</span></pre></td></tr></table></figure><ol start="3"><li><code>substring(int beginIndex, int endIndex)</code>  方法：获取指定位置范围内的子字符串。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> subStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// subStr = "Hello"</span></pre></td></tr></table></figure><ol start="4"><li><code>indexOf(String str)</code>  方法：获取指定字符串在该字符串中第一次出现的位置。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> index <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// index = 6</span></pre></td></tr></table></figure><ol start="5"><li><code>lastIndexOf(String str)</code>  方法：获取指定字符串在该字符串中最后一次出现的位置。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> index <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"l"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// index = 9</span></pre></td></tr></table></figure><ol start="6"><li><code>equals(Object obj)</code>  方法：比较字符串是否相等。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">boolean</span> isEqual <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// isEqual = true</span></pre></td></tr></table></figure><ol start="7"><li><code>startsWith(String prefix)</code>  方法：判断字符串是否以指定字符串开头。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">boolean</span> startsWith <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// startsWith = true</span></pre></td></tr></table></figure><ol start="8"><li><code>endsWith(String suffix)</code>  方法：判断字符串是否以指定字符串结尾。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">boolean</span> endsWith <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// endsWith = true</span></pre></td></tr></table></figure><ol start="9"><li><code>replace(char oldChar, char newChar)</code>  方法：用指定字符替换字符串中的所有指定字符。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> newStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// newStr = "Hell* W*rld!"</span></pre></td></tr></table></figure><ol start="10"><li><code>toLowerCase()</code>  方法和 <code>toUpperCase()</code>  方法：将字符串转换为小写或大写。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> lowerCaseStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lowerCaseStr = "hello world!"</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">String</span> upperCaseStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// upperCaseStr = "HELLO WORLD!"</span></pre></td></tr></table></figure><h3 id="string类其他特性"><a class="anchor" href="#string类其他特性">#</a> String 类其他特性</h3><p>​ <code>String</code>  类还支持字符串拼接操作。在 <code>Java 5</code>  之前，通常使用字符串拼接操作符 <code>+</code>  来实现字符串拼接，例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello"</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token string">"world!"</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>​在 <code>Java 5</code>  及之后的版本中，还引入了 <code>StringBuilder</code>  和 <code>StringBuffer</code>  两个类来优化字符串拼接操作。这两个类可以动态地添加、修改和删除字符串中的字符，并且能够避免频繁创建新的字符串对象。例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>​当需要在多线程环境下使用字符串拼接操作时，应该使用 <code>StringBuffer</code>  类。如果在单线程环境下使用字符串拼接操作，或者需要更高的性能，应该使用 <code>StringBuilder</code>  类。</p><p>​总之， <code>String</code>  类是 <code>Java</code>  中非常常用的一个类，它不仅支持字符串的基本操作，还提供了丰富的字符串处理方法，对于 <code>Java</code>  程序开发来说是一个必不可少的类。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期类</title>
      <link href="/computer-science/java/javase/%E6%97%A5%E6%9C%9F%E7%B1%BB/"/>
      <url>/computer-science/java/javase/%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="java日期类"><a class="anchor" href="#java日期类">#</a> Java 日期类</h2><p>​ <code>Java</code>  日期类主要包括 <code>java.util.Date</code> 、 <code>java.util.Calendar</code>  和 <code>java.time</code>  包下的类。</p><p>​ <code>java.util.Date</code>  类是 <code>Java</code>  提供的最早的日期类，它表示自 1970 年 1 月 1 日 0 时 0 分 0 秒 (GMT) 起的毫秒数。但是它的设计存在缺陷，所以在 <code>Java 8</code>  之后，推荐使用 java.time 包下的日期类。</p><p>​ <code>java.util.Calendar</code>  类是一个抽象类，提供了一些基本的日期操作，比如获取某一时间的年、月、日、时、分、秒等。但是该类使用起来比较繁琐。</p><p>​ <code>Java 8</code>  之后推出了全新的日期时间 <code>API</code> ， <code>java.time</code>  包下的类，包括 <code>LocalDate</code> 、 <code>LocalTime</code> 、 <code>LocalDateTime</code> 、 <code>ZonedDateTime</code>  等，这些类提供了更简单易用的方法和更好的可读性，能够更方便地进行日期和时间的计算和格式化。</p><p>下面是一些常用的 Java 日期类的方法：</p><h3 id="date"><a class="anchor" href="#date">#</a> Date</h3><ul><li><code>Date()</code> ：创建一个表示当前时间的 Date 对象。</li><li><code>getTime()</code> ：返回自 1970 年 1 月 1 日 0 时 0 分 0 秒 (GMT) 起的毫秒数。</li><li><code>toString()</code> ：返回一个 String 类型的表示形式，格式为 <code>EEE MMM dd HH:mm:ss zzz yyyy</code> 。</li></ul><h3 id="calender"><a class="anchor" href="#calender">#</a> Calender</h3><ul><li><code>getInstance()</code> ：返回一个 Calendar 对象，表示当前时间。</li><li><code>get(int field)</code> ：获取指定的日期字段值，如 <code>Calendar.YEAR</code> 、 <code>Calendar.MONTH</code> 、 <code>Calendar.DAY_OF_MONTH</code>  等。</li><li><code>set(int field, int value)</code> ：设置指定的日期字段值。</li><li><code>getTime()</code> ：返回一个 Date 对象，表示当前时间。</li></ul><h2 id="jdk8新增的日期类"><a class="anchor" href="#jdk8新增的日期类">#</a> JDK8 新增的日期类</h2><p>​Java 8 中引入了  <code>java.time</code>  包，该包提供了一组全新的日期和时间 API，其中包括  <code>LocalDate</code> 、 <code>LocalDateTime</code> 、 <code>ZonedDateTime</code>  等类，它们比旧的  <code>java.util.Date</code>  和  <code>java.util.Calendar</code>  更加方便易用，同时也更加安全和健壮。</p><p>以下是  <code>LocalDate</code> 、 <code>LocalDateTime</code>  的详细介绍：</p><h3 id="localdate"><a class="anchor" href="#localdate">#</a> LocalDate</h3><p><code>LocalDate</code>  表示一个日期，不包含时间和时区信息。它可以用来表示一个生日、节日、合同签订日期等等。</p><p>创建  <code>LocalDate</code>  对象有多种方式，比如使用  <code>now()</code>  方法获取当前日期，或者使用  <code>of()</code>  方法指定年、月、日：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDate</span> today <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDate</span> date <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2023</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们可以通过  <code>getYear()</code> 、 <code>getMonth()</code> 、 <code>getDayOfMonth()</code>  等方法获取日期的年、月、日等信息：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> year <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> month <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">getMonthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> day <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>LocalDate</code>  还提供了很多方法，比如  <code>plusDays()</code> 、 <code>minusMonths()</code>  等，用于对日期进行加减操作。例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDate</span> tomorrow <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plusDays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDate</span> previousMonthSameDay <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">minusMonths</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>LocalDate</code>  也支持一些常用的比较方法，比如  <code>isBefore()</code> 、 <code>isAfter()</code> 、 <code>isEqual()</code> ，用于比较两个日期的先后顺序：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">boolean</span> isBefore <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>tomorrow<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">boolean</span> isAfter <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span>previousMonthSameDay<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">boolean</span> isEqual <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">isEqual</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="localdatetime"><a class="anchor" href="#localdatetime">#</a> LocalDateTime</h3><p><code>LocalDateTime</code>  表示一个日期时间，不包含时区信息。它可以用来表示一个会议时间、发布时间、交易时间等等。</p><p>创建  <code>LocalDateTime</code>  对象有多种方式，比如使用  <code>now()</code>  方法获取当前日期时间，或者使用  <code>of()</code>  方法指定年、月、日、时、分、秒等：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2023</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们可以通过  <code>getYear()</code> 、 <code>getMonth()</code> 、 <code>getDayOfMonth()</code> 、 <code>getHour()</code> 、 <code>getMinute()</code> 、 <code>getSecond()</code>  等方法获取日期时间的年、月、日、时、分、秒等信息：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> year <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> month <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getMonthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> day <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> hour <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getHour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> minute <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getMinute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> second <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>LocalDateTime</code>  类是 Java 8 中的日期时间类，表示日期和时间，不带时区信息。下面是 <code>LocalDateTime</code>  类中常用的一些方法：</p><ol><li><code>now()</code> ：获取当前日期时间。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="2"><li><code>of()</code> ：根据指定的年、月、日、时、分、秒、毫秒等参数创建一个 <code>LocalDateTime</code>  实例。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="3"><li><code>plusXxx()</code> ：在当前 <code>LocalDateTime</code>  的基础上增加指定的时间量，其中 Xxx 可以是 <code>Years、Months、Weeks、Days、Hours、Minutes、Seconds</code>  等。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDateTime</span> plusOneDay <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">plusDays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="4"><li><code>minusXxx()</code> ：在当前 <code>LocalDateTime</code>  的基础上减少指定的时间量，其中 Xxx 可以是 <code>Years、Months、Weeks、Days、Hours、Minutes、Seconds</code>  等。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDateTime</span> minusOneHour <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">minusHours</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="5"><li><code>getXxx()</code> ：获取 <code>LocalDateTime</code>  的指定部分，其中 Xxx 可以是 <code>Year、Month、DayOfMonth、DayOfWeek、DayOfYear、Hour、Minute、Second、NanoOfSecond</code>  等。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> year <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Month</span> month <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> dayOfMonth <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">DayOfWeek</span> dayOfWeek <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> hour <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getHour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> minute <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getMinute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> second <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> nano <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="6"><li><code>withXxx()</code> ：设置 <code>LocalDateTime</code>  的指定部分，其中 Xxx 可以是 <code>Year、Month、DayOfMonth、DayOfWeek、DayOfYear、Hour、Minute、Second、NanoOfSecond</code>  等。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDateTime</span> withYear2023 <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">withYear</span><span class="token punctuation">(</span><span class="token number">2023</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="7"><li><code>isXxx()</code> ：判断 <code>LocalDateTime</code>  的指定部分是否满足某个条件，其中 Xxx 可以是 <code>LeapYear、After、Before</code>  等。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">boolean</span> isLeapYear <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">toLocalDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="8"><li><code>toXxx()</code> ：将 <code>LocalDateTime</code>  转换为其他日期时间类，其中 Xxx 可以是 <code>LocalDate</code> 、 <code>LocalTime</code> 、 <code>Instant</code>  等。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDate</span> date <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">toLocalDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">LocalTime</span> time <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">toLocalTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token class-name">ZoneOffset</span><span class="token punctuation">.</span><span class="token constant">UTC</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这些是 <code>LocalDateTime</code>  类中比较常用的方法，可以方便地对日期时间进行操作和计算。</p><h3 id="instant"><a class="anchor" href="#instant">#</a> Instant</h3><p>Java 的 <code>Instant</code>  类是用来表示时刻的类，可以精确到纳秒级别。它是不可变的，线程安全的。 <code>Instant</code>  类是在 Java 8 中引入的，它提供了与时区无关的机制来处理日期和时间。</p><p><code>Instant</code>  类的实例可以从时钟获取当前时间，也可以从另一个 <code>Instant</code>  实例中创建，或者通过解析表示 ISO-8601 格式的字符串来创建。 <code>Instant</code>  类的 API 提供了许多方法来操作 <code>Instant</code>  实例，以下是一些常用方法：</p><ol><li><code>now()</code> ：获取当前时间戳的 <code>Instant</code>  实例。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Instant</span> now <span class="token operator">=</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="2"><li><code>ofEpochSecond()</code> ：根据秒数创建 <code>Instant</code>  实例。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochSecond</span><span class="token punctuation">(</span><span class="token number">1614305156</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="3"><li><code>ofEpochMilli()</code> ：根据毫秒数创建 <code>Instant</code>  实例。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span><span class="token number">1614305156000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="4"><li><code>getEpochSecond()</code> ：获取秒数。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">long</span> epochSecond <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">getEpochSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="5"><li><code>getNano()</code> ：获取纳秒数。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> nano <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">getNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="6"><li><code>plusSeconds()</code> ：添加指定的秒数。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Instant</span> newInstant <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">plusSeconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="7"><li><code>minusSeconds()</code> ：减去指定的秒数。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Instant</span> newInstant <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">minusSeconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="8"><li><code>isAfter()</code> ：判断是否在指定的 Instant 实例之后。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">boolean</span> isAfter <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span>anotherInstant<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="9"><li><code>isBefore()</code> ：判断是否在指定的 <code>Instant</code>  实例之前。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">boolean</span> isBefore <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>anotherInstant<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="10"><li><code>toString()</code> ：将 <code>Instant</code>  实例转换为字符串。</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>总之， <code>Instant</code>  类提供了一种简单而灵活的方式来处理日期和时间，它适用于需要精确处理时间戳的应用程序。</p><h3 id="timestamp"><a class="anchor" href="#timestamp">#</a> Timestamp</h3><p>Java 中的 <code>Timestamp</code>  类是用于处理数据库中日期时间类型的类，继承自 <code>java.util.Date</code>  类，但是它的精度要高于 <code>Date</code>  类，可以精确到纳秒级别。 <code>Timestamp</code>  类在 <code>JDBC</code>  程序中很常用，它可以表示精确到秒的时间戳。</p><p><code>Timestamp</code>  类的构造方法有以下几种：</p><ol><li><code>Timestamp(long time)</code> ：根据指定的时间创建一个 <code>Timestamp</code>  对象。</li><li><code>Timestamp(String s)</code> ：根据字符串表示的时间创建一个 <code>Timestamp</code>  对象。</li><li><code>Timestamp(int year, int month, int date, int hour, int minute, int second, int nano)</code> ：根据指定的年、月、日、时、分、秒和纳秒数创建一个 <code>Timestamp</code>  对象。</li></ol><p><code>Timestamp</code>  类中的常用方法包括：</p><ol><li><code>getTime()</code> ：返回以毫秒表示的 <code>Timestamp</code>  值。</li><li><code>valueOf(String s)</code> ：将指定的字符串转换为 <code>Timestamp</code>  类型。</li><li><code>valueOf(LocalDateTime dateTime)</code> ：将指定的 <code>LocalDateTime</code>  转换为 <code>Timestamp</code>  类型。</li><li><code>toLocalDateTime()</code> ：将 <code>Timestamp</code>  对象转换为 <code>LocalDateTime</code>  对象。</li><li><code>compareTo(Timestamp ts)</code> ：比较两个 <code>Timestamp</code>  对象的大小。</li><li><code>equals(Object ts)</code> ：判断当前 <code>Timestamp</code>  对象是否与指定对象相等。</li><li><code>toString()</code> ：将 <code>Timestamp</code>  对象转换为字符串表示。</li><li><code>setNanos(int n)</code> ：设置 <code>Timestamp</code>  对象的纳秒数。</li><li><code>setYear(int year)</code> ：设置 <code>Timestamp</code>  对象的年份。</li><li><code>setMonth(int month)</code> ：设置 <code>Timestamp</code>  对象的月份。</li><li><code>setDate(int date)</code> ：设置 <code>Timestamp</code>  对象的日期。</li><li><code>setHours(int hours)</code> ：设置 <code>Timestamp</code>  对象的小时。</li><li><code>setMinutes(int minutes)</code> ：设置 <code>Timestamp</code>  对象的分钟。</li><li><code>setSeconds(int seconds)</code> ：设置 <code>Timestamp</code>  对象的秒数。</li></ol><p>总之， <code>Timestamp</code>  类是 Java 中处理时间戳的一个重要类，它可以很方便地将时间戳转换为日期时间类型，或者将日期时间类型转换为时间戳。在开发中，我们通常会使用 <code>Timestamp</code>  来操作数据库中的时间类型数据。</p><h3 id="locale"><a class="anchor" href="#locale">#</a> Locale</h3><p>Java 中的 <code>Locale</code>  类表示了特定地理、政治或文化区域的信息，比如国家、语言、货币等。通过 <code>Locale</code>  类，Java 程序可以获取与地区相关的信息，例如日期和时间格式、货币符号、语言环境等。 <code>Locale</code>  类的实例表示一个特定的地理、政治或文化区域，由语言代码和国家（或地区）代码组成，例如 “en_US” 表示美国英语环境。</p><p><code>Locale</code>  类提供了多个构造函数和静态方法，用于创建和获取特定的地理、政治或文化区域。常用的构造函数和方法包括：</p><ol><li><code>Locale(String language) </code> 通过指定的语言代码创建一个 <code>Locale</code>  实例，国家代码默认为 &quot;&quot;。</li><li><code>Locale(String language, String country)</code>  通过指定的语言代码和国家代码创建一个 <code>Locale</code>  实例。</li><li><code>Locale(String language, String country, String variant)</code>  通过指定的语言代码、国家代码和变量创建一个 <code>Locale</code>  实例。</li><li><code>Locale.getDefault() </code> 获取当前默认的 <code>Locale</code>  实例。</li><li><code>Locale.getAvailableLocales()</code>  获取所有可用的 <code>Locale</code>  实例。</li><li><code>getCountry()</code>  获取 <code>Locale</code>  实例的国家代码。</li><li><code>getLanguage() </code> 获取 <code>Locale</code>  实例的语言代码。</li><li><code>getDisplayName() </code> 获取 <code>Locale</code>  实例的显示名称。</li><li><code>getDisplayName(Locale inLocale) </code> 获取在指定 Locale 环境下的 <code>Locale</code>  实例的显示名称。</li></ol><p><code>Locale</code>  类的应用场景包括但不限于以下几种：</p><ol><li>本地化日期、时间、货币等格式</li><li>国际化应用程序的开发</li><li>区域性数据的处理</li><li>多语言文本的翻译和处理</li></ol><h3 id="zone相关的类"><a class="anchor" href="#zone相关的类">#</a> Zone 相关的类</h3><p>在 Java 中，关于时区的相关操作主要是通过  <code>java.time.Zone</code>  相关的类来完成的。</p><p>首先， <code>ZoneId</code>  类表示了一个时区标识符，可以使用  <code>ZoneId.of()</code>  方法来获取。比如，以下代码可以获取表示 &quot;Asia/Shanghai&quot; 时区的  <code>ZoneId</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ZoneId</span> zoneId <span class="token operator">=</span> <span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Asia/Shanghai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>ZoneOffset</code>  类表示了一个以秒为单位的时间偏移量，可以使用  <code>ZoneOffset.ofTotalSeconds()</code>  方法来获取。比如，以下代码可以获取表示东八区的  <code>ZoneOffset</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ZoneOffset</span> offset <span class="token operator">=</span> <span class="token class-name">ZoneOffset</span><span class="token punctuation">.</span><span class="token function">ofTotalSeconds</span><span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token number">3600</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>ZonedDateTime</code>  类表示了一个带时区的日期和时间。可以使用  <code>ZonedDateTime.of()</code>  方法来创建一个  <code>ZonedDateTime</code>  对象。比如，以下代码可以创建表示当前时间在东八区的  <code>ZonedDateTime</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ZonedDateTime</span> zonedDateTime <span class="token operator">=</span> <span class="token class-name">ZonedDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Asia/Shanghai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>另外，Java 还提供了一些方便的方法来进行时区转换。比如， <code>LocalDateTime</code>  可以使用  <code>atZone()</code>  方法将其转换为  <code>ZonedDateTime</code> ，然后使用  <code>withZoneSameInstant()</code>  方法将其转换为另一个时区的  <code>ZonedDateTime</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> localDateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">ZonedDateTime</span> shanghaiTime <span class="token operator">=</span> localDateTime<span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Asia/Shanghai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">ZonedDateTime</span> newYorkTime <span class="token operator">=</span> shanghaiTime<span class="token punctuation">.</span><span class="token function">withZoneSameInstant</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"America/New_York"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>类似的， <code>Instant</code>  可以使用  <code>atZone()</code>  方法将其转换为  <code>ZonedDateTime</code> ，然后使用  <code>toInstant()</code>  方法将其转换为  <code>Instant</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">ZonedDateTime</span> zonedDateTime <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Asia/Shanghai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Instant</span> newYorkTime <span class="token operator">=</span> zonedDateTime<span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最后，需要注意的是，在处理时区相关的操作时，一定要注意时间的格式化和解析。比如，在使用  <code>SimpleDateFormat</code>  进行时间格式化时，应该使用带时区的格式化器来避免时区转换时的问题。</p><h3 id="日期格式化"><a class="anchor" href="#日期格式化">#</a> 日期格式化</h3><p>在 Java 中，可以使用格式化来将日期对象格式化为字符串。Java 提供了两种格式化方式：</p><ol><li>使用 <code>java.text.SimpleDateFormat</code>  类，该类可以根据指定的格式将日期格式化为字符串。</li></ol><p>例如，下面的代码将 <code>Date</code>  对象格式化为字符串：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span><span class="token class-name">SimpleDateFormat</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DateFormatExample</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">Date</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">SimpleDateFormat</span> dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">String</span> strDate <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strDate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre>2022<span class="token punctuation">-</span>08<span class="token punctuation">-</span>22 16<span class="token punctuation">:</span><span class="token datetime number">32:11</span></pre></td></tr></table></figure><ol><li>使用 <code>java.time.format.DateTimeFormatter</code>  类，该类是 Java 8 新引入的日期时间格式化类，使用方式类似于 <code>SimpleDateFormat</code> 。</li></ol><p>例如，下面的代码将 <code>LocalDateTime</code>  对象格式化为字符串：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">LocalDateTime</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span><span class="token class-name">DateTimeFormatter</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DateTimeFormatterExample</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">DateTimeFormatter</span> formatter <span class="token operator">=</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">String</span> strDate <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>formatter<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strDate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre>2022<span class="token punctuation">-</span>08<span class="token punctuation">-</span>22 16<span class="token punctuation">:</span><span class="token datetime number">32:11</span></pre></td></tr></table></figure><p>需要注意的是，在使用 <code>DateTimeFormatter</code>  格式化 <code>java.time</code>  包中的日期时间类时，要使用对应的格式化模式，例如年份用大写的 <code>yyyy</code>  表示，月份用小写的 <code>mm</code>  表示等。</p><p>另外，如果需要将字符串转换为日期对象，可以使用 <code>SimpleDateFormat</code>  或 <code>DateTimeFormatter</code>  中的 <code>parse</code>  方法，例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> strDate <span class="token operator">=</span> <span class="token string">"2022-08-22 16:32:11"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">SimpleDateFormat</span> dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Date</span> date <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>strDate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> strDate <span class="token operator">=</span> <span class="token string">"2022-08-22 16:32:11"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">DateTimeFormatter</span> formatter <span class="token operator">=</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">LocalDateTime</span> dateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>strDate<span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>需要注意的是，在使用 <code>SimpleDateFormat</code>  解析日期字符串时，要使用与格式化模式相同的模式进行解析。而使用 <code>DateTimeFormatter</code>  时，可以根据需要指定格式化模式。</p><h3 id="日期类的相互转化"><a class="anchor" href="#日期类的相互转化">#</a> 日期类的相互转化</h3><p>​在 Java 中，我们可以使用各种日期类进行日期的操作。这些日期类包括  <code>java.util.Date</code> 、 <code>java.sql.Date</code> 、 <code>java.util.Calendar</code> 、 <code>java.time.LocalDate</code> 、 <code>java.time.LocalDateTime</code> 、 <code>java.time.Instant</code>  等。为了进行不同日期类之间的相互转化，Java 提供了一些方法。</p><p>下面是一些常见的日期类之间的转化方法：</p><ol><li><p><code>java.util.Date</code>  和  <code>java.sql.Date</code>  的转化</p><ul><li><p>将  <code>java.util.Date</code>  转换成  <code>java.sql.Date</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span>Date</span> sqlDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>将  <code>java.sql.Date</code>  转换成  <code>java.util.Date</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span>Date</span> sqlDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span>sqlDate<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></li><li><p><code>java.util.Date</code>  和  <code>java.time.LocalDateTime</code>  的转化</p><ul><li><p>将  <code>java.util.Date</code>  转换成  <code>java.time.LocalDateTime</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">LocalDateTime</span> localDateTime <span class="token operator">=</span> instant<span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocalDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>将  <code>java.time.LocalDateTime</code>  转换成  <code>java.util.Date</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> localDateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> localDateTime<span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> date <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></li><li><p><code>java.util.Calendar</code>  和  <code>java.time.LocalDateTime</code>  的转化</p><ul><li><p>将  <code>java.util.Calendar</code>  转换成  <code>java.time.LocalDateTime</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Calendar</span> calendar <span class="token operator">=</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDateTime</span> localDateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">ofInstant</span><span class="token punctuation">(</span>calendar<span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> calendar<span class="token punctuation">.</span><span class="token function">getTimeZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toZoneId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>将  <code>java.time.LocalDateTime</code>  转换成  <code>java.util.Calendar</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDateTime</span> localDateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Calendar</span> calendar <span class="token operator">=</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>calendar<span class="token punctuation">.</span><span class="token function">setTimeInMillis</span><span class="token punctuation">(</span>localDateTime<span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEpochMilli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></li><li><p><code>java.util.Date</code>  和  <code>java.time.Instant</code>  的转化</p><ul><li><p>将  <code>java.util.Date</code>  转换成  <code>java.time.Instant</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>将  <code>java.time.Instant</code>  转换成  <code>java.util.Date</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> date <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></li><li><p><code>java.util.Date</code>  和  <code>java.time.LocalDate</code>  的转化</p><ul><li><p>将  <code>java.util.Date</code>  转换成  <code>java.time.LocalDate</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">LocalDate</span> localDate <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocalDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>将  <code>java.time.LocalDate</code>  转换成  <code>java.util.Date</code> ：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">LocalDate</span> localDate <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Instant</span> instant <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">atStartOfDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> date <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本数据类型</title>
      <link href="/computer-science/java/javase/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/computer-science/java/javase/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="java八大基本数据类型"><a class="anchor" href="#java八大基本数据类型">#</a> Java 八大基本数据类型</h2><table><thead><tr><th>数据类型</th><th>大小</th><th>默认值</th><th>取值范围</th><th>描述</th></tr></thead><tbody><tr><td>byte</td><td>1 字节</td><td>0</td><td>-128 到 127</td><td>有符号整数</td></tr><tr><td>short</td><td>2 字节</td><td>0</td><td>-32,768 到 32,767</td><td>有符号整数</td></tr><tr><td>int</td><td>4 字节</td><td>0</td><td>-2,147,483,648 到 2,147,483,647</td><td>有符号整数</td></tr><tr><td>long</td><td>8 字节</td><td>0L</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td>有符号整数</td></tr><tr><td>float</td><td>4 字节</td><td>0.0f</td><td>1.4E-45 到 3.4028235E38</td><td>浮点数</td></tr><tr><td>double</td><td>8 字节</td><td>0.0d</td><td>4.9E-324 到 1.7976931348623157E308</td><td>双精度浮点数</td></tr><tr><td>char</td><td>2 字节</td><td>'\u0000'</td><td>'\u0000' 到 '\uffff' (0 到 65,535)</td><td>Unicode 字符</td></tr><tr><td>boolean</td><td>没有固定大小</td><td>false</td><td>true 或 false</td><td>true 或 false 值</td></tr></tbody></table><h3 id="java基本数据类型对应的包装类"><a class="anchor" href="#java基本数据类型对应的包装类">#</a> Java 基本数据类型对应的包装类</h3><table><thead><tr><th>数据类型</th><th>对应包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h3 id="包装类常用方法和特别设计"><a class="anchor" href="#包装类常用方法和特别设计">#</a> 包装类常用方法和特别设计</h3><ul><li><code>Byte</code><ul><li>常用方法：valueOf (byte b)、byteValue ()、compareTo (Byte anotherByte)、equals (Object obj)、toString ()、hashCode ()</li><li>特别设计：缓存了 - 128~127 之间的所有 Byte 对象，可以使用 Byte.valueOf (byte b) 方法直接返回缓存的对象，避免重复创建对象</li></ul></li><li><code>Short</code><ul><li>常用方法：valueOf (short s)、shortValue ()、compareTo (Short anotherShort)、equals (Object obj)、toString ()、hashCode ()</li><li>特别设计：缓存了 - 128~127 之间的所有 Short 对象，可以使用 Short.valueOf (short s) 方法直接返回缓存的对象，避免重复创建对象</li></ul></li><li><code>Integer</code><ul><li>常用方法：valueOf (int i)、intValue ()、compareTo (Integer anotherInteger)、equals (Object obj)、toString ()、hashCode ()</li><li>特别设计：缓存了 - 128~127 之间的所有 Integer 对象，可以使用 Integer.valueOf (int i) 方法直接返回缓存的对象，避免重复创建对象</li></ul></li><li><code>Long</code><ul><li>常用方法：valueOf (long l)、longValue ()、compareTo (Long anotherLong)、equals (Object obj)、toString ()、hashCode ()</li><li>特别设计：缓存了 - 128~127 之间的所有 Long 对象，可以使用 Long.valueOf (long l) 方法直接返回缓存的对象，避免重复创建对象</li></ul></li><li><code>Float</code><ul><li>常用方法：valueOf (float f)、floatValue ()、compareTo (Float anotherFloat)、equals (Object obj)、toString ()、hashCode ()</li><li>特别设计：没有特别设计</li></ul></li><li><code>Double</code><ul><li>常用方法：valueOf (double d)、doubleValue ()、compareTo (Double anotherDouble)、equals (Object obj)、toString ()、hashCode ()</li><li>特别设计：没有特别设计</li></ul></li><li><code>Character</code><ul><li>常用方法：valueOf (char c)、charValue ()、compareTo (Character anotherCharacter)、equals (Object obj)、toString ()、hashCode ()</li><li>特别设计：缓存了 0~127 之间的所有 Character 对象，可以使用 Character.valueOf (char c) 方法直接返回缓存的对象，避免重复创建对象</li></ul></li><li><code>Boolean</code><ul><li>常用方法：valueOf (boolean b)、booleanValue ()、compareTo (Boolean anotherBoolean)、equals (Object obj)、toString ()、hashCode ()</li><li>特别设计：缓存了 Boolean 类型的 TRUE 和 FALSE 两个对象</li></ul></li></ul><p>​当 Java 自动装箱时，会重用对象，将一些常见的包装类对象缓存起来以提高性能和降低内存占用。下面是几个常用的包装类缓存示例：</p><h3 id="包装类缓存示例"><a class="anchor" href="#包装类缓存示例">#</a> 包装类缓存示例</h3><ol><li><strong>Integer 类的缓存示例：</strong></li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true，因为 10 在缓存范围内</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false，因为 128 不在缓存范围内</span></pre></td></tr></table></figure><p>​<strong>解释</strong>：在 Integer 类中，缓存了 -128 到 127 的 Integer 对象。因此，当值为在这个范围内时，自动装箱后的对象会直接从缓存中获取，而不是新建一个对象。因此，a 和 b 的值都是 10，因为它们共享了同一个对象，所以比较时结果为 true。而 c 和 d 的值都是 128，但由于它们不在缓存范围内，所以自动装箱后会新建两个对象，所以比较时结果为 false。</p><ol><li><strong>Boolean 类的缓存示例：</strong></li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Boolean</span> a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Boolean</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true，因为 true 和 false 都有缓存</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Boolean</span> c <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">Boolean</span> d <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true，因为 true 和 false 都有缓存</span></pre></td></tr></table></figure><p>​<strong>解释</strong>：在 Boolean 类中，缓存了 true 和 false 两个对象。因此，当自动装箱时，这两个对象会直接从缓存中获取，而不是新建对象。因此，a 和 b 都是 true，且共享了同一个对象，所以比较时结果为 true。而 c 和 d 都是 false，且共享了同一个对象，所以比较时结果为 true。</p><ol><li><strong>Character 类的缓存示例：</strong></li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Character</span> a <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Character</span> b <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true，因为 a 在缓存范围内</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Character</span> c <span class="token operator">=</span> <span class="token char">'中'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">Character</span> d <span class="token operator">=</span> <span class="token char">'中'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false，因为 ' 中 ' 不在缓存范围内</span></pre></td></tr></table></figure><p>​<strong>解释</strong>：在 Character 类中，缓存了 Unicode 编码从 0 到 127 的字符。因此，当自动装箱时，这些字符会直接从缓存中获取，而不是新建对象。因此，a 和 b 的值都是 'a'，且共享了同一个对象，所以比较时结果为 true。而 c 和 d 的值都是 ' 中 '，但由于它们不在缓存范围内，所以自动装箱后会新建两个对象，所以比较时结果为 false。</p><p>​需要注意的是，虽然自动装箱时会重用对象，但如果使用构造函数手动创建对象，则不会使用缓存，每次都会新建一个对象。</p><h3 id="包装类对象的相互转化"><a class="anchor" href="#包装类对象的相互转化">#</a> 包装类对象的相互转化</h3><p>​当我们需要在基本数据类型和包装类之间进行转换时，可以使用 Java 中提供的自动装箱和自动拆箱机制，也可以手动调用包装类提供的转换方法。以下是一些常见的基本数据类型和包装类之间的转换示例：</p><ol><li>基本数据类型转换成对应的包装类：</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Integer</span> numWrapper <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="2"><li>包装类转换成对应的基本数据类型：</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Double</span> doubleWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">double</span> num <span class="token operator">=</span> doubleWrapper<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="3"><li>使用自动装箱和自动拆箱：</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Integer</span> numWrapper <span class="token operator">=</span> num<span class="token punctuation">;</span>  <span class="token comment">// 自动装箱</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> newNum <span class="token operator">=</span> numWrapper<span class="token punctuation">;</span>   <span class="token comment">// 自动拆箱</span></pre></td></tr></table></figure><ol start="4"><li>字符串转换成包装类：</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Integer</span> numWrapper <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="5"><li>包装类转换成字符串：</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Integer</span> numWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> numWrapper<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>​需要注意的是，在进行基本数据类型和字符串之间的转换时，也可以使用  <code>parseInt()</code>  和  <code>valueOf()</code>  等方法。例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="自动装箱和自动拆箱"><a class="anchor" href="#自动装箱和自动拆箱">#</a> 自动装箱和自动拆箱</h3><p>​在 Java 中，自动装箱和自动拆箱是指基本数据类型与其对应的包装类之间的自动转换，使得它们在使用上可以互相替换，从而使代码更加简洁和易读。</p><p>​具体来说，自动装箱是指将基本数据类型自动转换为对应的包装类，而自动拆箱则是指将包装类自动转换为对应的基本数据类型。这样一来，程序员在使用时就无需手动进行类型转换，编译器会自动帮助完成。</p><p>​下面是自动装箱和自动拆箱的示例代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 自动装箱</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 相当于 Integer i = Integer.valueOf (10);</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 自动拆箱</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 相当于 int j = i.intValue ();</span></pre></td></tr></table></figure><p>​从上面的示例代码可以看出，自动装箱和自动拆箱让代码更加简洁，减少了程序员的工作量，提高了代码的可读性和可维护性。</p><p>​其原理是编译器自动在编译时将代码进行转换。对于自动装箱，编译器会将基本数据类型转换为对应的包装类类型，调用相应的 valueOf 方法进行装箱；对于自动拆箱，编译器会将包装类类型转换为对应的基本数据类型，调用相应的 xxxValue 方法进行拆箱。这样一来，程序员就可以像操作基本数据类型一样操作包装类类型了。</p><p>​需要注意的是，自动装箱和自动拆箱虽然方便了编程，但是也会带来性能问题。在大量使用时，建议手动进行类型转换，以提高程序性能。</p><h3 id="其他注意项"><a class="anchor" href="#其他注意项">#</a> 其他注意项</h3><ol><li><strong>类型转换</strong>：Java 中的数据类型有不同的大小和精度，如果将一个大的数据类型转换为一个小的数据类型，会导致数据精度的丢失，这就需要进行类型转换。类型转换可以分为隐式类型转换和显式类型转换两种。</li><li><strong>final 关键字</strong>：final 关键字可以用来修饰变量、方法和类。final 修饰的变量不能被修改，final 修饰的方法不能被覆盖，final 修饰的类不能被继承。对于基本数据类型，final 修饰的变量必须被初始化，一旦被初始化后就不能再次被修改。</li><li><strong>枚举类型</strong>：Java 中的枚举类型可以列出一组常量，并为这些常量赋予特定的值。枚举类型可以用来取代常量，使代码更加可读和易于维护。枚举类型也是一种特殊的类，可以有构造函数、方法和字段。</li><li><strong>变量作用域</strong>：在 Java 中，变量有不同的作用域，变量的作用域决定了变量在程序中可以被访问的范围。Java 中有四种作用域：类作用域、方法作用域、块作用域和局部作用域。</li><li><strong>常量池</strong>：Java 中的常量池是指在编译时确定的、存储在.class 文件中的常量集合。常量池中可以包含字符串、数字、类名、方法名等常量。Java 的数据类型也有对应的常量池，例如 Integer 类型的常量池中包含了 - 128~127 之间的整数。常量池可以提高程序的运行效率，减少内存的占用。</li></ol><p><strong>这些内容也是 Java 数据类型中比较重要的一些方面，需要开发者在日常的开发中注意。</strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/computer-science/java/javase/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/computer-science/java/javase/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="java8新特性"><a class="anchor" href="#java8新特性">#</a> Java8 新特性</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java发展历程</title>
      <link href="/computer-science/java/javase/Java%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
      <url>/computer-science/java/javase/Java%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么叫java"><a class="anchor" href="#为什么叫java">#</a> 为什么叫 Java？</h3><p>​Java 平台和语言最开始只是 SUN 公司在 1990 年 12 月开始研究的一个内部项目。SUN 公司的一个叫做帕特里克・诺顿的工程师被自己开发的 C 和 C 语言编译器搞得焦头烂额，因为其中的 API 极其难用。帕特里克决定改用 NeXT，同时他也获得了研究公司的一个叫做 “Stealth 计划” 的项目的机会。<br />   “Stealth 计划” 后来改名为 “Green 计划”，JGosling (詹姆斯・高斯林）和麦克・舍林丹也加入了帕特里克的工作小组。他们和其他几个工程师一起在加利福尼亚州门罗帕克市沙丘路的一个小工作室里面研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，SUN 公司预料未来科技将在家用电器领域大显身手。团队最初考虑使用 C 语言，但是很多成员包括 SUN 的首席科学家比尔・乔伊，发现 C 和可用的 API 在某些方面存在很大问题。<br />   工作小组使用的是内嵌类型平台，可以用的资源极其有限。很多成员发现 C 太复杂以至很多开发者经常错误使用。他们发现 C 缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。<br />   根据可用的资金，比尔・乔伊决定开发一种集 C 语言和 Mesa 语言搭成的新语言，在一份报告上，乔伊把它叫做 “未来”，他提议 SUN 公司的工程师应该在 C 的基础上，开发一种面向对象的环境。最初，高斯林试图修改和扩展 C 的功能，他自己称这种新语言为 C –，但是后来他放弃了。他将要创造出一种全新的语言，被他命名为 “Oak”（橡树），以他的办公室外的树而命名。<br />就像很多开发新技术的秘密的工程一样，工作小组没日没夜地工作到了 1992 年的夏天，他们能够演示新平台的一部分了，包括 Green 操作系统，Oak 的程序设计语言，类库，和其硬件。最初的尝试是面向一种类 PDA 设备，被命名为 Star7，这种设备有鲜艳的图形界面和被称为 “Duke” 的智能代理来帮助用户。1992 年 12 月 3 日，这台设备进行了展示。<br />   同年 11 月，Green 计划被转化成了 “FirstPerson 有限公司”，一个 SUN 公司的全资子公司，团队也被重新安排到了帕洛阿尔托。FirstPerson 团队对建造一种高度互动的设备感兴趣，当时代华纳发布了一个关于电视机顶盒的征求提议书时（Request for proposal），FirstPerson 改变了他们的目标，作为对征求意见书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得 FirstPerson 的平台给予用户过多地控制权，因此 FirstPerson 的投标败给了 SGI。与 3DO 公司的另外一笔关于机顶盒的交易也没有成功，由于他们的平台不能在电视工业产生任何效益，公司再并回 SUN 公司。<br />   JAVA 应用 1994 年 6、7 月间，在经历了一场历时三天的头脑风暴的讨论之后，约翰・盖吉、詹姆斯・高斯林、比尔・乔伊、帕特里克・诺顿、韦恩・罗斯因和埃里克・斯库米，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于万维网。他们认为随着 Mosaic 浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克・诺顿写了一个小型万维网浏览器，WebRunner，后来改名为 HotJava。同年，Oak 改名为 Java。商标搜索显示，Oak 已被一家显卡制造商注册，因此团队找到了一个新名字。这个名字是在很多成员常去的本地咖啡馆中杜撰出来的。名字是不是首字母缩写还不清楚，很大程度上来说不是。虽然有人声称是开发人员名字的组合：James Gosling（詹姆斯・高斯林）Arthur Van Hoff（阿瑟・凡・霍夫）Andy Bechtolsheim（安迪・贝克托克姆），或 “Just Another Vague Acronym”（只是另外一个含糊的缩写）。还有一种比较可信的说法是这个名字是出于对咖啡的喜爱，所以以 Java 咖啡来命名。类文件的前四个字节如果用十六进制阅读的话，分别为 CA FE BA BE，就会拼出两个单词 “CAFE BABE”（咖啡宝贝）。<br />   1994 年 10 月，HotJava 和 Java 平台为公司高层进行演示。1994 年，Java 1.0a 版本已经可以提供下载，但是 Java 和 HotJava 浏览器的第一次公开发布却是在 1995 年 5 月 23 日 SunWorld 大会上进行的。SUN 公司的科学指导约翰・盖吉宣告 Java 技术。这个发布是与网景公司的执行副总裁马克・安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对 Java 的支持。1996 年 1 月，升阳公司成立了 Java 业务集团，专门开发 Java 技术。</p><h3 id="jdk发展历程"><a class="anchor" href="#jdk发展历程">#</a> JDK 发展历程</h3><p>​1996 年 1 月，Sun 公司发布了 Java 的第一个开发工具包（JDK 1.0），这是 Java 发展历程中的重要里程碑，标志着 Java 成为一种独立的开发工具。9 月，约 8.3 万个网页应用了 Java 技术来制作。10 月，Sun 公司发布了 Java 平台的第一个即时（JIT）编译器。</p><p>​1997 年 2 月，JDK 1.1 面世，在随后的 3 周时间里，达到了 22 万次的下载量。4 月 2 日，Java One 会议召开，参会者逾一万人，创当时全球同类会议规模之纪录。9 月，Java Developer Connection 社区成员超过 10 万。</p><p>​1998 年 12 月 8 日，第二代 Java 平台的企业版 J2EE 发布。1999 年 6 月，Sun 公司发布了第二代 Java 平台（简称为 Java2）的 3 个版本：J2ME（Java2 Micro Edition，Java2 平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2 平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2 平台的企业版），应用于基于 Java 的应用服务器。Java 2 平台的发布，是 Java 发展过程中最重要的一个里程碑，标志着 Java 的应用开始普及。</p><p>​1999 年 4 月 27 日，HotSpot 虚拟机发布。HotSpot 虚拟机发布时是作为 JDK 1.2 的附加程序提供的，后来它成为了 JDK 1.3 及之后所有版本的 Sun JDK 的默认虚拟机  。</p><p>​2000 年 5 月，JDK1.3、JDK1.4 和 J2SE1.3 相继发布，几周后其获得了苹果公司 Mac OS X 的工业标准的支持。2001 年 9 月 24 日，J2EE1.3 发布。2002 年 2 月 26 日，J2SE1.4 发布。自此 Java 的计算能力有了大幅提升，与 J2SE1.3 相比，其多了近 62% 的类和接口。在这些新特性当中，还提供了广泛的 XML 支持、安全套接字（Socket）支持（通过 SSL 与 TLS 协议）、全新的 I/OAPI、正则表达式、日志与断言。2004 年 9 月 30 日，J2SE1.5 发布，成为 Java 语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE 1.5 更名为 Java SE 5.0（内部版本号 1.5.0），代号为 “Tiger”，Tiger 包含了从 1996 年发布 1.0 版本以来的最重大的更新，其中包括泛型支持、基本类型的自动装箱、改进的循环、枚举类型、格式化 I/O 及可变参数。</p><p>​2005 年 6 月，在 Java One 大会上，Sun 公司发布了 Java SE 6。此时，Java 的各种版本已经更名，已取消其中的数字 2，如 J2EE 更名为 JavaEE，J2SE 更名为 JavaSE，J2ME 更名为 JavaME。</p><p>​2006 年 11 月 13 日，Java 技术的发明者 Sun 公司宣布，将 Java 技术作为免费软件对外发布。Sun 公司正式发布的有关 Java 平台标准版的第一批源代码，以及 Java 迷你版的可执行源代码。从 2007 年 3 月起，全世界所有的开发人员均可对 Java 源代码进行修改 。</p><p>​2009 年，甲骨文公司宣布收购 Sun   。2010 年，Java 编程语言的共同创始人之一詹姆斯・高斯林从 Oracle 公司辞职。2011 年，甲骨文公司举行了全球性的活动，以庆祝 Java7 的推出，随后 Java7 正式发布。</p><p>​2014 年，甲骨文公司发布了 Java8 正式版</p><p>​2017 年，甲骨文公司发布了 Java9 正式版</p><h3 id="java发展史上发生的大事件具体概括如下表"><a class="anchor" href="#java发展史上发生的大事件具体概括如下表">#</a> Java 发展史上发生的大事件具体概括如下表</h3><p>各版本 JDK 引入的主要新特性<br /> JDK Version 1.0<br /> 开发代号为 Oak（橡树），于 1996-01-23 发行。</p><table><thead><tr><th>时间</th><th>事件</th></tr></thead><tbody><tr><td>1996 年 1 月</td><td>第一个 JDK-JDK1.0 诞生；</td></tr><tr><td>1996 年 4 月</td><td>10 个最主要的操作系统供应商申明将在其产品中嵌入 Java 技术；</td></tr><tr><td>1996 年 9 月</td><td>约 8.3 万个网页应用了 Java 技术来制作</td></tr><tr><td>1997 年 2 月 18 日</td><td>JDK1.1 发布</td></tr><tr><td>1997 年 4 月 2 日</td><td>JavaOne 会议召开，参与者逾一万人，创当时全球同类会议纪录</td></tr><tr><td>1997 年 9 月</td><td>JavaDeveloperConnection 社区成员超过十万</td></tr><tr><td>1998 年 2 月</td><td>JDK1.1 被下载超过 2,000,000 次</td></tr><tr><td>1998 年 12 月 8 日</td><td>Java 2 企业平台 J2EE 发布 (J2EE1.2)</td></tr><tr><td>1999 年 6 月</td><td>SUN 公司发布 Java 三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME）</td></tr><tr><td>2000 年 5 月 8 日</td><td>JDK1.3 发布</td></tr><tr><td>2000 年 5 月 29 日</td><td>JDK1.4 发布</td></tr><tr><td>2001 年 6 月 5 日</td><td>Nokia 宣布到 2003 年将出售 1 亿部支持 Java 的手机</td></tr><tr><td>2001 年 9 月 24 日</td><td>J2EE1.3 发布</td></tr><tr><td>2002 年 2 月 26 日</td><td>J2SE1.4 发布，此后 Java 的计算能力有了大幅提升</td></tr><tr><td>2004 年 9 月 30 日</td><td>J2SE1.5 发布，成为 Java 语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5 更名为 Java SE 5.0；</td></tr><tr><td>2005 年 6 月</td><td>JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 “2”： J2ME 更名为 Java ME， J2SE 更名为 Java SE，J2EE 更名为 Java EE</td></tr><tr><td>2006 年 12 月</td><td>SUN 公司发布 JRE6.0</td></tr><tr><td>2009 年 12 月</td><td>SUN 公司发布 Java EE 6</td></tr><tr><td>2010 年 11 月</td><td>由于甲骨文对 Java 社区的不友善，因此 Apache 扬言将退出 JCP</td></tr><tr><td>2011 年 7 月</td><td>甲骨文发布 Java SE 7</td></tr><tr><td>2014 年 3 月</td><td>甲骨文发表 Java SE 8</td></tr><tr><td>2017 年 9 月</td><td>甲骨文发表 Java SE 9</td></tr><tr><td>2018 年 3 月</td><td>甲骨文发布 Java SE 10</td></tr></tbody></table><h3 id="j2se-version-12"><a class="anchor" href="#j2se-version-12">#</a> J2SE Version 1.2</h3><p>开发代号为 Playground（操场），于 1998-12-08 发行。<br />引入的新特性包括：</p><ul><li>引入集合（Collection）框架；</li><li>对字符串常量做内存映射；</li><li>引入 JIT（Just In Time）编译器；</li><li>引入对打包的 Java 文件进行数字签名；</li><li>引入控制授权访问系统资源的策略工具；</li><li>引入 JFC（Java Foundation Classes），包括 Swing 1.0、拖放和 Java 2D 类库；</li><li>引入 Java 插件；</li><li>在 JDBC 中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型；</li><li>在 Applet 中添加声音支持。</li></ul><h3 id="j2se-version-13"><a class="anchor" href="#j2se-version-13">#</a> J2SE Version 1.3</h3><p>开发代号为 Kestrel（红隼），于 2000-05-08 发行。<br />引入的新特性包括：</p><ul><li>引入 Java Sound API；</li><li>jar 文件索引；</li><li>对 Java 的各个方面都做了大量优化和增强。</li></ul><h3 id="j2se-version-14"><a class="anchor" href="#j2se-version-14">#</a> J2SE Version 1.4</h3><p>开发代号为 Merlin（隼），于 2004-02-06 发行（首次在 JCP 下发行）。<br />引入的新特性包括:</p><ul><li>XML 处理；</li><li>Java 打印服务；</li><li>引入 Logging API；<br />引入 Java Web Start；</li><li>引入 JDBC 3.0 API；</li><li>引入断言；</li><li>引入 Preferences API；</li><li>引入链式异常处理；</li><li>支持 IPv6；</li><li>支持正则表达式；</li><li>引入 Image I/O slot machine API。</li></ul><h3 id="java-version-se-50"><a class="anchor" href="#java-version-se-50">#</a> Java Version SE 5.0</h3><p>开发代号为 Tiger（老虎），于 2004-09-30 发行。<br />引入的新特性包括:</p><ul><li>引入泛型；</li><li>增强循环，可以使用迭代方式；</li><li>自动装箱与自动拆箱；</li><li>类型安全的枚举；</li><li>可变参数；</li><li>静态引入；</li><li>元数据（注解）；</li><li>引入 Instrumentation。</li></ul><h3 id="java-version-se-6"><a class="anchor" href="#java-version-se-6">#</a> Java Version SE 6</h3><p>开发代号为 Mustang（野马），于 2006-12-11 发行。<br />引入的新特性包括：</p><ul><li>支持脚本语言；</li><li>引入 JDBC 4.0 API；</li><li>引入 Java Compiler API；</li><li>可插拔注解；</li><li>增加对 Native PKI (Public Key Infrastructure)、Java GSS (Generic Security Service)、Kerberos 和 LDAP (Lightweight Directory Access Protocol) 的支持；</li><li>继承 Web Services；做了很多优化。</li></ul><h3 id="java-version-se-7"><a class="anchor" href="#java-version-se-7">#</a> Java Version SE 7</h3><p>开发代号是 Dolphin（海豚），于 2011-07-28 发行。<br />引入的新特性包括：</p><ul><li>switch 语句块中允许以字符串作为分支条件；</li><li>在创建泛型对象时应用类型推断；</li><li>在一个语句块中捕获多种异常；</li><li>支持动态语言；</li><li>支持 try-with-resources；</li><li>引入 Java NIO.2 开发包；</li><li>数值类型可以用 2 进制字符串表示，并且可以在字符串表示中添加下划线；</li><li>钻石型语法；</li><li>null 值的自动处理。</li></ul><h3 id="java-version-se-8"><a class="anchor" href="#java-version-se-8">#</a> Java Version SE 8</h3><p>开发代号是 Spider（蜘蛛），于 2014-03-18 发行。</p><ul><li>支持 lambda 支持；</li><li>增强日期与时间 API 的功能；</li><li>对垃圾回收的性能也进行了改进；</li><li>并且移除了 permgen 区。</li><li>Lambdas 表达式与 Functional 接口。</li><li>接口的默认与静态方法。</li><li>方法引用。</li><li>重复注解。</li><li>更好的类型推测机制。</li><li>扩展注解的支持。</li></ul><h3 id="java-version-se-90"><a class="anchor" href="#java-version-se-90">#</a> Java Version SE 9.0</h3><ul><li>Java 平台级模块系统。</li><li>Linking。</li><li>JShell : 交互式 Java REPL。</li><li>改进的 Javadoc。</li><li>集合工厂方法。</li><li>改进的 Stream API。</li><li>私有接口方法。</li><li>HTTP/2。</li><li>多版本兼容 JAR。</li></ul><h3 id="java-version-se-100"><a class="anchor" href="#java-version-se-100">#</a> Java Version SE 10.0</h3><p>​本地变量类型推断，可以使用本地变量的初始化去推荐对应变量的类型。提升了并行垃圾收集器 G1 的性能，降低了收集延时。应用优化了启动时刻的数据共享，已经存在的类更好的共享。一个试用的即时编译器 Grral，只支持 linux x64 平台能够感知到 docker 的存在，如果运行在 linux 平台，可以感知到是否运行在 docker 容器中，可以查询到操作系统给容器分配的 cpu 和内存等等物理资源信息.<br /> 修复从主机 Java 线程连接到容器内 Java 线程的一个问题。更短的 jShell REPL tool 启动时间。提供了新接口，可以获取可变化的集合类，copyOf,Set.copyOf, 和 Map.copyOf 等方法创建一个新的集合对象，toUnmodifiableList, toUnmodifiableSet, 和 toUnmodifiableMap 获取不可修改对象，让 Stream 操作可以获取到不可变对象。<br />​本地变量类型推断。可以减少类型的生命，同时也保证了 static 类型的安全性。提供一个垃圾收集的接口去提供各个垃圾收集器隔离的能力，这样可以让内置的垃圾收集器正常运行，同时可以更容易向 hotspot 添加新的垃圾收集器。改进的并行的垃圾收集器 G1, 可以有效降低延迟。让 hotspot 支持寻找可用的任何内存，例如 NVDIMM 存储模块，用户可以去指定它，这也是为未来的异构内存提供支持。在 Linux/x64 平台提供一个实验性的即时编译器。让 jdk 使用单一仓库管理，现在分离在不同的仓库，这样给源码管理带来了一些困难。提升了内存的共享，减少了应用的启动时间。本地线程握手，可以在虚拟机的全局安全点暂停而不用等待其他的任何线程。为 openJDK 提供 Oracle 根认证，这样可以吸引更多的开发者使用 openJDK。</p><p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doc2NhcmVjcm93L2FydGljbGUvZGV0YWlscy84MjMxODYzNg==">https://blog.csdn.net/ghscarecrow/article/details/82318636</span></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面对对象程序设计</title>
      <link href="/computer-science/java/javase/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/computer-science/java/javase/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="java面对对象编程的概念"><a class="anchor" href="#java面对对象编程的概念">#</a> Java 面对对象编程的概念</h4><h5 id="类"><a class="anchor" href="#类">#</a> 类</h5><h5 id="类的概念"><a class="anchor" href="#类的概念">#</a> 类的概念</h5><p>类是描述世间万物的框架，在 java 中世间万物都可以用类来定义。</p><p>将数据及对数据的操作封装在一起，成为一个不可分割的整体。</p><p>同时将具有相同特征的对象抽象成一种新的数据类型 ---------- 类；</p><p>通过对象间的消息传递使整个系统运转，通过类的继承实现代码重用。</p><h5 id="类的创建格式"><a class="anchor" href="#类的创建格式">#</a> 类的创建格式</h5><p>[public] [修饰符] class [类名] extends (可选) [父类名] implements [接口 1 名],[接口 2 名],...{<br />// 类的成员<br />}</p><h5 id="注意"><a class="anchor" href="#注意">#</a> 注意：</h5><p>1.public 可选，当 java 文件名跟类名一致时，public 必须有<br /> 2. 第二个可选关键字有 final (子类不可继承)、abstract (无法实例化)<br /> 3. 第三个参数类名是定义的类名 (要符合 Java 类名命名规范)</p><h5 id="类的初始化"><a class="anchor" href="#类的初始化">#</a> 类的初始化</h5><p>【类名】 对象名 = new 【类名】();<br />【类名】 对象名 = new 【类名】(参数一...);</p><h5 id="类的组成"><a class="anchor" href="#类的组成">#</a> 类的组成</h5><p>类 = 字段 + 方法；</p><ol><li>字段（属性）</li></ol><pre><code>描述一类对象的特征值。比如，人拥有姓名、性别、年龄等特征。</code></pre><ol start="2"><li>方法</li></ol><pre><code>描述一类对象的行为。比如，人会说话，会学习，会唱歌等行为。</code></pre><h5 id="对象"><a class="anchor" href="#对象">#</a> 对象</h5><p>对象是类的实例。在 Java 中万物皆可看成是对象</p><h5 id="类与对象的区别"><a class="anchor" href="#类与对象的区别">#</a> 类与对象的区别</h5><p>类是同等对象的集合与抽象。它是一块创建现实<strong>对象的模板</strong>。<strong>对象是类的实例</strong>，对象是面向对象编程的核心部分，是实际存在的具体实体，具有明确定义的状态和行为。</p><h5 id="例子"><a class="anchor" href="#例子">#</a> 例子</h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> age <span class="token punctuation">;</span><span class="token comment">// 字段</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> name <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> sex <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 方法</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"同学在学习"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 类 = 方法 + 字段 </span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 声明类的对象</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="构造函数"><a class="anchor" href="#构造函数">#</a> 构造函数</h5><p>构造函数是特殊的函数，函数名与类名一致，不能有返回值，包括 void；</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>声明格式为：[修饰符] 类名(参数列表)&#123; //... &#125;</pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="分类"><a class="anchor" href="#分类">#</a> 分类</h5><h5 id="无参构造"><a class="anchor" href="#无参构造">#</a> 无参构造</h5><p>如果类中没有有参构造，也没有无参构造，则系统会默认给该类添加一个无参构造</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>      <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="有参构造"><a class="anchor" href="#有参构造">#</a> 有参构造</h5><p>如果没有无参构造，则有参构造函数则是初始化对象的构造函数（即必须传入参数才能完成初始化）</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>      <span class="token keyword">private</span> <span class="token class-name">String</span> name <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token keyword">private</span> <span class="token keyword">int</span> age <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>          <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="构造函数的重载"><a class="anchor" href="#构造函数的重载">#</a> 构造函数的重载</h5><p>构造函数允许重载，可以根据需求重载构造函数。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> name <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> age <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Studnet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="面对对象的三大特征"><a class="anchor" href="#面对对象的三大特征">#</a> 面对对象的三大特征</h5><ul><li><p><strong>封装</strong><br />把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<br />在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象<br />封装的作用<br />封装把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象编程始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在 java 中通过控制成员的访问权限实现封装，即使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 ** 适当的封装可以让代码更容易理解和维护，也加强了代码的安全性。</p></li><li><p><strong>继承</strong></p><ul><li>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法</li><li>一个新类可以从现有的类中派生，这个过程称为类继承，新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）</li><li>派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>多态</strong></p><ul><li>多态性是指允许不同类的对象对同一消息作出响应</li><li>多态性语言具有灵活、抽象、行为共享、代码共享的优势</li></ul></li></ul><h3 id="static关键字"><a class="anchor" href="#static关键字">#</a> static 关键字</h3><p><code>static</code>  修饰符只能修饰类的成员</p><ul><li>特点<ul><li><code>static</code>  只能修饰类成员（字段，方法）, 另外构造函数不允许 <code>static</code>  修饰</li><li><code>static</code>  修饰的类成员是属于所有类对象，这些成员所有对象共享 (即所有对象的该成员都在同一块内存区域)</li><li><code>static</code>  在类初始化前就已经加载完成了，所以它不能使用对象级别的其他成员</li><li><code>staitc</code>  表示静态成员，而静态成员只能使用静态成员 (无法在类中直接调用类的普通成员)</li></ul></li></ul><h3 id="final关键字"><a class="anchor" href="#final关键字">#</a> final 关键字</h3><p><code>final</code>  在 Java 的原意是不可变，很多场合下都会和 <code>static</code>  一起使用，表示静态不可变成员</p><ul><li><code>final</code>  修饰的字段称为常量；常量在声明的时候就必须初始化完；常量一经确定无法更改；</li><li><code>final</code>  修饰的方法无法被重写<ul><li><code>final</code>  修饰的类无法被继承 (如 <code>String</code>  类、 <code>LocalDate</code>  类等等)</li></ul></li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> age <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="抽象类"><a class="anchor" href="#抽象类">#</a> 抽象类</h3><ul><li><p><strong>抽象类对多态的实现</strong></p><ul><li>接口</li><li>抽象类</li><li>重写父类方法</li></ul></li><li><p><strong>抽象类的特点</strong></p><ul><li>抽象类中没有实例，即不能声明调用自己的构造方法</li><li>抽象类中可以有普通方法，抽象方法不能在抽象类中实现</li><li>继承了抽象类的子类必须实现该抽象类中所有的抽象方法，如果不实现，子类也必须定义为抽象类</li></ul></li></ul><h3 id="接口"><a class="anchor" href="#接口">#</a> 接口</h3><ul><li><p><strong>接口对多态的实现</strong></p></li><li><p><strong>接口的特征</strong></p><ul><li>接口没有构造方法，也不能实例化。</li><li>接口中的抽象方法和默认为公开的，变量默认为公开静态常量（建议不要再写这些修饰符）</li><li>接口中允许静态方法和默认 ( <code>default</code> ) 方法（JDK1.8）</li><li>接口可以多继承（只允许接口之间）</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">Action</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">/**</pre></td></tr><tr><td data-num="5"></td><td><pre>    * 下面的方法写法是在 JDK1.8 开始有的</pre></td></tr><tr><td data-num="6"></td><td><pre>    */</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">see</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><h3 id="对象转型"><a class="anchor" href="#对象转型">#</a> 对象转型</h3><ul><li><p><strong>向上转型</strong></p><p>父类对象或者实现类对象使用子类的引用</p><p>特点：</p><ol><li>使用子类或实现类引用的父类对象或接口对象无法调用子类或实现类的方法，只能调用父类或接口中的方法和字段。</li><li>编译时引用是父类对象或接口对象，运行时引用是子类对象或实现类对象</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">Action</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">act</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Action</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 父类对象使用子类的引用</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">Action</span> action <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 接口对象使用子类的引用</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><h3 id="抽象类和接口的区别"><a class="anchor" href="#抽象类和接口的区别">#</a> 抽象类和接口的区别</h3><ul><li>抽象类对属性没有限制，而接口的属性只能是公开静态常量</li><li>抽象类和接口都不能实例化，但是抽象类可以有构造方法 (仅供子类使用)，而接口不能有构造方法</li><li>抽象类可以有普通方法，但接口不能有普通方法，接口只能有静态方法 (JDK8) 和默认方法 (JDK8)</li><li>抽象类只能单继承，而接口之间可以多继承 (只能接口之间)</li></ul><h3 id="内部类"><a class="anchor" href="#内部类">#</a> 内部类</h3><p>​    <strong>什么是内部类？</strong></p><p>​    内部类就是嵌套在<strong>类或者方法代码块</strong>内部的类</p><ul><li><p><strong>内部类的作用</strong></p><p>我们为什么需要内部类？或者说内部类为啥要存在？其主要原因有如下几点：</p><ul><li><p><strong>内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据</strong></p><p><strong>为什么内部类可以无条件地访问外围类的所有元素</strong>？</p><p>解答：</p><p><strong>为什么可以引用？：</strong></p><p><strong>内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的 class 文件，内部类通过 this 访问外部类的成员。</strong></p><ol><li>编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象 this 的引用；</li><li>编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为内部类中添加的成员变量赋值；</li><li>在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。</li></ol><p>编译指令 javac classpath (.java 文件的路径)<br /> 反编译指令 javap -v (详细信息) classpath (.class 文件的路径)</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> a <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> b <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">int</span> a <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">int</span> b <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Outer</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过 外部类名.this. 字段名 来访问外部重名字段</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>内部类可以对同一包中的其他类隐藏起来</strong></p><p><strong>实现隐藏</strong></p><p>​    关于内部类的第二个好处其实很显而易见，我们都知道外部类即普通的类不能使用  <code>private</code> , <code>protected</code>  访问权限符来修饰的，而内部类则可以使用  <code>private</code>  和  <code>protected </code> 来修饰。当我们使用 <code>private</code>  来修饰内部类的时候这个类就对外隐藏了。这看起来没什么作用，但是当内部类实现某个接口的时候，在进行<strong>向上转型</strong>，对外部来说，就完全隐藏了接口的实现了</p><ul><li><strong>内部类可以解决 java 单继承的缺陷</strong><br />当我们想要<strong>定义一个回调函数却不想写大量代码的时候</strong>我们可以选择使用<strong>匿名内部类</strong>来实现<br />我们知道 java 是不允许使用  <code>extends</code>  去继承多个类的。内部类的引入可以很好的解决这个事情。<br />我的理解 Java 只能继承一个类这个学过基本语法的人都知道，而在有内部类之前它的多重继承方式是用接口来实现的。但使用接口有时候有很多不方便的地方。<strong>比如我们实现一个接口就必须实现它里面的所有方法</strong>。</li></ul></li></ul></li><li><p><strong>内部类和外部类的关系</strong></p><ul><li><strong>对于非静态内部类，内部类的创建依赖外部类的实例对象，在没有外部类实例之前是无法创建内部类的</strong></li><li><strong>内部类是一个相对独立的实体，与外部类不是 is-a (依赖) 关系</strong></li><li><strong>创建内部类的时刻 并不依赖于 外部类 的创建</strong></li></ul></li><li><p><strong>内部类的分类</strong></p><ul><li><p><strong>静态内部类</strong></p></li><li><p><strong>非静态内部类</strong></p><ul><li><p><strong>非静态内部类访问权限的问题</strong></p></li><li><p><strong>非静态内部类和静态内部类的区别</strong></p><table><thead><tr><th></th><th>静态内部类</th><th>非静态内部类</th></tr></thead><tbody><tr><td><strong>是否可以拥有静态成员</strong></td><td><strong>是</strong></td><td><strong>否</strong></td></tr><tr><td><strong>是否可以访问外部类的静态成员</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td><strong>是否可以访问外部类的非静态成员</strong></td><td><strong>否</strong></td><td><strong>是</strong></td></tr><tr><td><strong>创建是否依赖外部类</strong></td><td><strong>否</strong></td><td><strong>是</strong></td></tr></tbody></table></li></ul></li><li><p><strong>匿名内部类 (属于非静态内部类)</strong></p><p>在定义时，要么给出<strong>类的超类</strong>，要么给出<strong>类要实现的接口（只能有一个）</strong>；对外部类的访问权限同本地内部类相同；常见的用途是在建立 GUI 应用程序时为组件添加事件监听器对象</p><ul><li><p>匿名内部类是没有访问修饰符的。</p></li><li><p><strong>匿名内部类必须继承一个抽象类或者实现一个接口</strong></p></li><li><p>匿名内部类中<strong>不能存在任何静态成员或方法</strong></p></li><li><p>匿名内部类是<strong>没有构造方法的</strong>，因为它没有类名。</p></li><li><p>与局部内部类相同匿名内部类也可以引用局部变量。此变量也必须声明为 <code> final</code></p><p><strong>为什么局部变量需要 final 修饰呢？</strong></p><ul><li><p>因为局部变量和匿名内部类的生命周期不同。</p></li><li><p>匿名内部类是创建后是存储在堆中的，而方法中的局部变量是存储在 Java 栈中，当方法执行完毕后，就进行退栈，同时局部变量也会消失。</p></li></ul><p><strong>那么此时匿名内部类还有可能在堆中存储着，那么匿名内部类要到哪里去找这个局部变量呢？</strong></p><p>为了解决这个问题编译器为自动地帮我们在匿名内部类中创建了一个局部变量的备份，也就是说即使方法执结束，匿名内部类中还有一个备份，自然就不怕找不到了。<br />但是问题又来了。<br />如果局部变量中的 <code>a</code>  不停的在变化。那么岂不是也要让备份的 <code>a</code>  变量无时无刻的变化。为了保持局部变量与匿名内部类中备份域保持一致。编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。<br />所以为什么匿名内部类应用外部方法的域必须是常量域的原因所在了。<br /><strong>特别注意</strong><br />在 Java8 中已经去掉要对 final 的修饰限制，但其实只要在匿名内部类使用了，该变量还是会自动变为 final 类型（<strong>只能使用，不能赋值</strong>）。</p></li></ul><p><strong>匿名类的创建示例</strong>：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NickClass</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匿名内部类的抽象类无参构造创建方式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">new</span> <span class="token class-name">Outer1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匿名内部类的抽象有参构造创建方式"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">new</span> <span class="token class-name">Outer2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 这里的接口匿名类创建方式，重写时必须将 public 修饰符加上，否则报错</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匿名内部类的接口创建方式"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 匿名内部类中可以访问原</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Outer1</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">int</span> i <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Outer1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">return</span> i <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">Outer2</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>匿名类使用局部变量</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NickClassTest</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">;</span><span class="token comment">// 匿名类允许使用常量</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 匿名类可以使用局部变量，但是不能改变其值</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">new</span> <span class="token class-name">Listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> i1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//                j = j+ 1; 编译错误，不能改变局部变量的值</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用局部变量i="</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">",j="</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1="</span><span class="token operator">+</span>i1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这里可以将需要传入方法的实参传入</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Listener</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>成员内部类 (属于非静态内部类)</strong></p></li><li><p><strong>本地内部类 (局部内部类)(属于非静态内部类)</strong></p><p>如果一个内部类只在一个方法中使用到了，那么我们可以将这个类定义在方法内部，这种内部类被称为局部内部类。其作用域仅限于该方法。</p><p>局部内部类有两点值得我们注意的地方：</p><ul><li>局部内类不允许使用访问权限修饰符 <code> public</code> , <code>private</code> , <code>protected </code> 均不允许</li><li>局部内部类对外完全隐藏，除了创建这个类的方法可以访问它其他的地方是不允许访问的。</li><li>局部内部类与成员内部类不同之处是他可以引用成员变量，但该成员必须声明为 final，并内部不允许修改该变量的值。（这句话并不准确，因为如果不是基本数据类型的时候，只是不允许修改引用指向的对象，而对象本身是可以被就修改的）</li></ul></li></ul></li><li><p><strong>内部类可能造成的问题</strong></p><p><strong>内部类会造成程序的内存泄漏</strong><br />相信做 Android 的朋友看到这个例子一定不会陌生，我们经常使用的 Handler 就无时无刻不给我们提示着这样的警告。</p><p>我们先来看下内部类为什么会造成内存泄漏。</p><p>​    要想了解为啥内部类为什么会造成内存泄漏我们就必须了解 <strong>java 虚拟机的回收机制</strong>，但是我们这里不会详尽的介绍 java 的内存回收机制，我们只需要了解 java 的内存回收机制通过「可达性分析」来实现的。</p><p>即 java 虚拟机会通过内存回收机制来判定引用是否可达，如果不可达就会在某些时刻去回收这些引用。</p><p>那么内部类在什么情况下会造成内存泄漏的可能呢？</p><ul><li>如果一个匿名内部类没有被任何引用持有，那么匿名内部类对象用完就有机会被回收。</li><li>如果内部类仅仅只是在外部类中被引用，当外部类的不再被引用时，外部类和内部类就可以都被 GC 回收。</li><li>如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被 GC 回收的情况，即使外部类没有被引用，<strong>因为内部类持有指向外部类的引用）</strong>。</li></ul></li></ul><h3 id="java包"><a class="anchor" href="#java包">#</a> Java 包</h3><ul><li><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间</p></li><li><p><strong>包的作用：</strong></p><ul><li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</li><li>如同<strong>文件夹一样</strong>，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li><li>包也提供了限定了访问权限的一个控制范围，拥有包访问权限的类才能访问某个包中的类</li></ul></li><li><p>Java 使用包这种机制是为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注</p><p>解等，它把不同的 java 程序分类保存，更方便的被其他 java 程序调用</p><ul><li>以下是一些 JDK 中的包：</li><li>java.lang：打包基础的类</li><li><span class="exturl" data-url="aHR0cDovL2phdmEuaW8=">java.io</span>：包含输入输出功能的函数</li><li>java.util：包含一些重要的工具类</li><li>…</li></ul></li><li><p>开发者可以自己把一组类等组合定义自己的包。而且在实际开发中这样做是值得提倡的，将</p></li></ul><p>相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注解等是相关的 。</p><ul><li>由于包创建了新的命名空间，所以不会跟其他包中的任何名字产生命名冲突。使用包这种机</li></ul><p>制，更容易实现访问控制，并且让定位相关类更加简单。</p><h3 id="package与import关键字"><a class="anchor" href="#package与import关键字">#</a> package 与 import 关键字</h3><ul><li><p>Java 中用 package 语句来将一个 Java 源文件中的类打成一个包</p></li><li><p>package 语句必须作为 Java 源文件的第一条语句，指明该文件中定义的类</p><p>所在的包。(若忽略该语句，则指定为无名包)。它的格式为：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>package pkg1[.pkg2[.pkg3…]];</pre></td></tr></table></figure></li><li><p>Java 编译器把包对应于<strong>文件系统的目录</strong>管理</p></li><li><p>package 语句中，用 “.” 来指明目录的层次</p></li><li><p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它</p></li><li><p>为了能够使用其他包的成员，需要在 Java 程序中明确导入该包</p></li><li><p>使用 &quot;<strong>import</strong>&quot; 语句可完成此功能</p></li><li><p>在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：</p></li></ul><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>import package1[.package2…].(classname|);</pre></td></tr></table></figure><ul><li><p>如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略</p></li><li><p>import 语句中类名部分可以使用通配符 “*”</p></li><li><p>符号 * 表示直接导入包中所有的类</p></li><li><p>如： <code>import java.util.*;</code>  表示导入 <code>java.util</code>  包中所有的类</p></li><li><p>注意：包和子包之间不存在继承关系，只要两个类不直接在同一个文件中即认为位于不同的包，因此 * 号只能包含本包中的类而不能包含子包中的类</p></li><li><p><strong>包的命名规则</strong></p><ul><li><p>创建包的时候，你需要为这个包取一个合适的名字，根据 Java 包的约定，名字内的所有字母都应小写，之后，如果非同包的其他的一个源文件使用了这个包提供的类、接口、枚举或者注释类型的时候，都必须在这个源文件的开头说明所引用的包名</p></li><li><p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名。例如：互联网域名是 <span class="exturl" data-url="aHR0cDovL2NoaW5hc29mdGkuY29t">chinasofti.com</span>，所有的包名都以 com.chinasofti 开头</p></li></ul></li></ul><h3 id="访问控制符"><a class="anchor" href="#访问控制符">#</a> 访问控制符</h3><ul><li><p><strong>private</strong></p><p>本类友好</p></li><li><p><strong>public</strong></p><p>所有友好</p></li><li><p><strong>缺省的</strong></p><p>同包类友好</p></li><li><p><strong>protected</strong></p><p>同包类友好，不同包的子类友好</p></li><li><p><strong>访问权限示意图</strong></p></li></ul><table><thead><tr><th></th><th>本类</th><th>同包类</th><th>不同包子类</th><th>不同包类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>缺省的</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="枚举"><a class="anchor" href="#枚举">#</a> 枚举</h3><p>​ <code>Java</code>  枚举（ <code>Enum</code> ）是一种特殊的类，用于表示一组相关的常量。枚举常量是预定义的，不允许添加或删除。枚举在 <code>Java</code>  中是一种基本数据类型，可以单独定义或嵌套在类或接口中。</p><h4 id="枚举示例"><a class="anchor" href="#枚举示例">#</a> 枚举示例</h4><p>​以下是一个枚举类的示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">DayOfWeek</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token constant">MONDAY</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token constant">TUESDAY</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token constant">WEDNESDAY</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token constant">THURSDAY</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token constant">FRIDAY</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token constant">SATURDAY</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token constant">SUNDAY</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>​这个枚举类表示一周中的每一天，包括星期一至星期日。枚举常量（例如 MONDAY）是 DayOfWeek 类的实例，它们是 final、static 和 public 类型的。这意味着它们是不可修改的常量，可以在没有类实例的情况下访问。</p><p>​枚举常量可以有属性和方法。以下是一个带有属性和方法的示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Gender</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">MALE</span><span class="token punctuation">(</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">FEMALE</span><span class="token punctuation">(</span><span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">Gender</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>​这个枚举类表示性别，包括男和女。枚举常量 MALE 和 FEMALE 都有一个名为 name 的属性，它们在构造函数中被初始化。此外，Gender 类还有一个名为 getName 的方法，用于返回枚举常量的 name 属性。</p><p>​枚举可以用于 switch 语句。以下是一个使用 switch 语句的示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printDay</span><span class="token punctuation">(</span><span class="token class-name">DayOfWeek</span> day<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">case</span> <span class="token constant">MONDAY</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"星期一"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">case</span> <span class="token constant">TUESDAY</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"星期二"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">case</span> <span class="token constant">WEDNESDAY</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"星期三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">case</span> <span class="token constant">THURSDAY</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"星期四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">case</span> <span class="token constant">FRIDAY</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"星期五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">case</span> <span class="token constant">SATURDAY</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"星期六"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">case</span> <span class="token constant">SUNDAY</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"星期日"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">default</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"无效的日期"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>​这个方法使用 switch 语句打印给定日期的星期几。使用枚举作为 switch 语句的参数可以使代码更清晰易读。</p><p>​枚举类也可以实现接口、继承其他类或枚举，或者被其他类继承。这使得枚举类更加灵活和可扩展。</p><ul><li><strong>为什么要有枚举？枚举的作用</strong></li></ul><p>​ <code>Java</code>  引入枚举是为了提高代码的可读性和可维护性。枚举类型在 <code>Java</code>  中表示一组固定的常量，可以在代码中使用这些常量，而不必担心拼写错误或者传递无效的参数。这样可以减少由于错误参数而引起的问题，同时也使代码更加清晰和易于维护。</p><p>​枚举的主要用处包括：</p><ol><li>限制变量的取值范围，提高代码的可读性和可维护性。</li><li>枚举常量在代码中使用时具有类型安全性，可以防止类型转换错误。</li><li>枚举常量可以拥有自己的属性和行为，类似于类的实例，可以实现更复杂的功能。</li><li>枚举常量可以作为参数传递给方法，可以提高代码的可读性和可维护性，同时也可以防止传递无效的参数。</li><li>枚举常量可以作为集合类型的元素，可以更方便地对集合进行操作。</li></ol><p>总之， <code>Java</code>  中的枚举类型可以帮助程序员编写更可读、更可维护、更类型安全和更清晰的代码，提高程序的可靠性和可维护性。</p><ul><li><strong>枚举的使用</strong></li></ul><p>​Java 枚举的使用可以分为以下几个方面：</p><ol><li>定义枚举类型</li></ol><p>​Java 枚举类型通过关键字 <code>enum</code>  定义，语法如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">EnumName</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token constant">ENUM_VALUE1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token constant">ENUM_VALUE2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token constant">ENUM_VALUE3</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中， <code>EnumName</code>  表示枚举类型的名称， <code>ENUM_VALUE1</code> 、 <code>ENUM_VALUE2</code> 、 <code>ENUM_VALUE3</code>  等表示枚举常量。</p><ol><li>枚举常量的使用</li></ol><p>枚举常量通过 <code>EnumName.ENUM_VALUE</code>  的方式访问，例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">EnumName</span> enumValue <span class="token operator">=</span> <span class="token class-name">EnumName</span><span class="token punctuation">.</span><span class="token constant">ENUM_VALUE1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol><li>枚举类型的方法</li></ol><p>枚举类型可以定义自己的方法，例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">EnumName</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token constant">ENUM_VALUE1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token constant">ENUM_VALUE2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token constant">ENUM_VALUE3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is my method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在枚举类型中，每个枚举常量都是一个实例对象，因此可以在枚举常量上调用枚举类型中的方法：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">EnumName</span> enumValue <span class="token operator">=</span> <span class="token class-name">EnumName</span><span class="token punctuation">.</span><span class="token constant">ENUM_VALUE1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>enumValue<span class="token punctuation">.</span><span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "This is my method."</span></pre></td></tr></table></figure><ol><li>枚举类型的构造函数</li></ol><p>​枚举类型也可以有自己的构造函数，但是枚举常量必须在枚举类型定义的最开始处定义。例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">EnumName</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">ENUM_VALUE1</span><span class="token punctuation">(</span><span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">ENUM_VALUE2</span><span class="token punctuation">(</span><span class="token string">"value2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">ENUM_VALUE3</span><span class="token punctuation">(</span><span class="token string">"value3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">EnumName</span><span class="token punctuation">(</span><span class="token class-name">String</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>​在这个例子中，枚举类型 <code>EnumName</code>  有一个私有成员变量 <code>value</code> ，并且定义了一个有参数的构造函数，每个枚举常量都必须在定义时指定对应的参数。在枚举类型中，可以通过调用 <code>getValue()</code>  方法获取枚举常量对应的参数值。</p><ol><li>枚举类型的比较</li></ol><p>​枚举类型可以通过 <code>==</code>  符号进行比较，例如：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">EnumName</span> enumValue1 <span class="token operator">=</span> <span class="token class-name">EnumName</span><span class="token punctuation">.</span><span class="token constant">ENUM_VALUE1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">EnumName</span> enumValue2 <span class="token operator">=</span> <span class="token class-name">EnumName</span><span class="token punctuation">.</span><span class="token constant">ENUM_VALUE1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>enumValue1 <span class="token operator">==</span> enumValue2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "true"</span></pre></td></tr></table></figure><p>以上是 Java 枚举的基本使用方法。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Python</title>
      <link href="/computer-science/python/basic/01.%E5%88%9D%E8%AF%86Python/"/>
      <url>/computer-science/python/basic/01.%E5%88%9D%E8%AF%86Python/</url>
      
        <content type="html"><![CDATA[<h3 id="python简介"><a class="anchor" href="#python简介">#</a> Python 简介</h3><h4 id="python的历史"><a class="anchor" href="#python的历史">#</a> Python 的历史</h4><ol><li><p>1989 年圣诞节： <code>Guido von Rossum</code>  开始写 <code>Python</code>  语言的编译器。</p><ol><li>1991 年 2 月：第一个 <code>Python</code>  编译器（同时也是解释器）诞生，它是用 C 语言实现的（后面），可以调用 C 语言的库函数。在最早的版本中， <code>Python</code>  已经提供了对 “类”，“函数”，“异常处理” 等构造块的支持，还有对列表、字典等核心数据类型，同时支持以模块为基础来构造应用程序。</li></ol></li><li><p>1994 年 1 月： <code>Python 1.0</code>  正式发布。</p></li><li><p>2000 年 10 月 16 日： <code>Python 2.0</code>  发布，增加了完整的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlFJTgzJUU1JTlDJUJFJUU1JTlCJTlFJUU2JTk0JUI2XyglRTglQTglODglRTclQUUlOTclRTYlQTklOUYlRTclQTclOTElRTUlQUQlQjgp">垃圾回收</span>，提供了对<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVW5pY29kZQ=="> Unicode</span> 的支持。与此同时， <code>Python</code>  的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。</p></li><li><p>2008 年 12 月 3 日： <code>Python 3.0</code>  发布，它并不完全兼容之前的 Python 代码，不过因为目前还有不少公司在项目和运维中使用 Python 2.x 版本，所以 <code>Python 3.x</code>  的很多新特性后来也被移植到 <code>Python 2.6/2.7</code>  版本中。</p></li></ol><p>目前我使用的 <code>Python 3.7.x</code>  的版本是在 2018 年发布的， <code>Python</code>  的版本号分为三段，形如 A.B.C。其中 A 表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加 A；B 表示功能更新，出现新功能时增加 B；C 表示小的改动（例如：修复了某个 <code>Bug</code> ），只要有修改就增加 C。如果对 <code>Python</code>  的历史感兴趣，可以阅读名为<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS92YW1laS9hcmNoaXZlLzIwMTMvMDIvMDYvMjg5MjYyOC5odG1s">《Python 简史》</span>的网络文章。</p><h4 id="python的优缺点"><a class="anchor" href="#python的优缺点">#</a> Python 的优缺点</h4><p><code>Python</code>  的优点很多，简单的可以总结为以下几点。</p><ol><li>简单明了，学习曲线低，比很多编程语言都容易上手。</li><li>开放源代码，拥有强大的社区和生态圈，尤其是在数据分析和机器学习领域。</li><li>解释型语言，天生具有平台可移植性，代码可以工作于不同的操作系统。</li><li>对两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。</li><li>代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。</li></ol><p><code>Python</code>  的缺点主要集中在以下几点。</p><ol><li>执行效率稍低，对执行效率要求高的部分可以由其他语言（如：C、C++）编写。</li><li>代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被弱化。</li><li>在开发时可以选择的框架太多（如 Web 框架就有 100 多个），有选择的地方就有错误。</li></ol><h4 id="python的应用领域"><a class="anchor" href="#python的应用领域">#</a> Python 的应用领域</h4><p>目前 <code>Python</code>  在 <code>Web</code>  应用后端开发、云基础设施建设、 <code>DevOps</code> 、网络数据采集（爬虫）、自动化测试、数据分析、机器学习等领域都有着广泛的应用。</p><h3 id="安装python解释器"><a class="anchor" href="#安装python解释器">#</a> 安装 Python 解释器</h3><p>想要开始 <code>Python</code>  编程之旅，首先得在自己使用的计算机上安装 <code>Python</code>  解释器环境，下面将以安装官方的 <code>Python</code>  解释器为例，讲解如何在不同的操作系统上安装 <code>Python</code>  环境。官方的 <code>Python</code>  解释器是用 C 语言实现的，也是使用最为广泛的 Python 解释器，通常称之为 <code>CPython</code> 。除此之外， <code>Python</code>  解释器还有 <code>Java</code>  语言实现的 <code>Jython</code> 、C# 语言实现的 <code>IronPython</code>  以及 <code>PyPy</code> 、 <code>Brython</code> 、 <code>Pyston</code>  等版本，有兴趣的读者可以自行了解。</p><h4 id="windows环境"><a class="anchor" href="#windows环境">#</a> Windows 环境</h4><p>可以在<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZw=="> Python 官方网站</span>下载到 <code>Python</code>  的 <code>Windows</code>  安装程序（exe 文件），需要注意的是如果在 Windows 7 环境下安装 <code>Python 3.x</code> ，需要先安装 <code>Service Pack 1</code>  补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选 “ <code>Add Python 3.x to PATH</code> ”（将 Python 3.x 添加到 PATH 环境变量）并选择自定义安装，在设置 “ <code>Optional Features</code> ” 界面最好将 “ <code>pip</code> ”、“ <code>tcl/tk</code> ”、“ <code>Python test suite</code> ” 等项全部勾选上。强烈建议选择自定义的安装路径并保证路径中没有中文。安装完成会看到 “ <code>Setup was successful</code> ” 的提示。如果稍后运行 Python 程序时，出现因为缺失一些动态链接库文件而导致 Python 解释器无法工作的问题，可以按照下面的方法加以解决。</p><p>如果系统显示 api-ms-win-crt*.dll 文件缺失，可以参照<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjA4NzEzNQ==">《api-ms-win-crt*.dll 缺失原因分析和解决方法》</span>一文讲解的方法进行处理或者直接在<span class="exturl" data-url="aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS96aC1jbi9kb3dubG9hZC9kZXRhaWxzLmFzcHg/aWQ9NDgxNDU=">微软官网</span>下载 <code>Visual C++ Redistributable for Visual Studio 2015</code>  文件进行修复；如果是因为更新 Windows 的 DirectX 之后导致某些动态链接库文件缺失问题，可以下载一个<span class="exturl" data-url="aHR0cHM6Ly9kbC5wY29ubGluZS5jb20uY24vZG93bmxvYWQvMzYwMDc0LTEuaHRtbA=="> DirectX 修复工具</span>进行修复。</p><h4 id="linux环境"><a class="anchor" href="#linux环境">#</a> Linux 环境</h4><p><code>Linux</code>  环境自带了 <code>Python 2.x</code>  版本，但是如果要更新到 3.x 的版本，可以在<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZw=="> Python 的官方网站</span>下载 <code>Python</code>  的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示（以 <code>CentOS</code>  为例）。</p><ol><li>安装依赖库（因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败）。</li></ol><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>yum <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">wget</span> gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</pre></td></tr></table></figure><ol start="2"><li>下载 <code>Python</code>  源代码并解压缩到指定目录。</li></ol><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">wget</span> https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tar.xz</pre></td></tr><tr><td data-num="2"></td><td><pre>xz <span class="token parameter variable">-d</span> Python-3.7.6.tar.xz</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">tar</span> <span class="token parameter variable">-xvf</span> Python-3.7.6.tar</pre></td></tr></table></figure><ol start="3"><li>切换至 Python 源代码目录并执行下面的命令进行配置和安装。</li></ol><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin class-name">cd</span> Python-3.7.6</pre></td></tr><tr><td data-num="2"></td><td><pre>./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/python37 --enable-optimizations</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span></pre></td></tr></table></figure><ol start="4"><li>修改用户主目录下名为.bash_profile 的文件，配置 PATH 环境变量并使其生效。</li></ol><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin class-name">cd</span> ~</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">vim</span> .bash_profile</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># ... 此处省略上面的代码 ...</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/local/python37/bin</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># ... 此处省略下面的代码 ...</span></pre></td></tr></table></figure><ol start="5"><li>激活环境变量。</li></ol><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin class-name">source</span> .bash_profile</pre></td></tr></table></figure><h4 id="macos环境"><a class="anchor" href="#macos环境">#</a> macOS 环境</h4><p><code>macOS</code>  也自带了 <code>Python 2.x</code>  版本，可以通过<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZw=="> Python 的官方网站</span>提供的安装文件（pkg 文件）安装 <code>Python 3.x</code>  的版本。默认安装完成后，可以通过在终端执行 <code>python</code>  命令来启动 2.x 版本的 <code>Python</code>  解释器，启动 3.x 版本的 <code>Python</code>  解释器需要执行 <code>python3</code>  命令。</p><h3 id="运行python程序"><a class="anchor" href="#运行python程序">#</a> 运行 Python 程序</h3><h4 id="确认python的版本"><a class="anchor" href="#确认python的版本">#</a> 确认 Python 的版本</h4><p>可以 Windows 的命令行提示符中键入下面的命令。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>python <span class="token parameter variable">--version</span></pre></td></tr></table></figure><p>在 Linux 或 macOS 系统的终端中键入下面的命令。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>python3 <span class="token parameter variable">--version</span></pre></td></tr></table></figure><p>当然也可以先输入 <code>python</code>  或 <code>python3</code>  进入交互式环境，再执行以下的代码检查 Python 的版本。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> sys</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>version_info<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>version<span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="编写python源代码"><a class="anchor" href="#编写python源代码">#</a> 编写 Python 源代码</h4><p>可以用文本编辑工具（推荐使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3VibGltZXRleHQuY29tLw=="> Sublime</span>、<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">Visual Studio Code</span> 等高级文本编辑工具）编写 Python 源代码并用 py 作为后缀名保存该文件，代码内容如下所示。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello, world!'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="运行程序"><a class="anchor" href="#运行程序">#</a> 运行程序</h4><p>切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了 &quot;hello, world!&quot;。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>python hello.py</pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>python3 hello.py</pre></td></tr></table></figure><h4 id="代码中的注释"><a class="anchor" href="#代码中的注释">#</a> 代码中的注释</h4><p>注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。</p><ol><li>单行注释 - 以 #和空格开头的部分</li><li>多行注释 - 三个引号开头，三个引号结尾</li></ol><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token triple-quoted-string string">"""</pre></td></tr><tr><td data-num="2"></td><td><pre>第一个Python程序 - hello, world!</pre></td></tr><tr><td data-num="3"></td><td><pre>向伟大的Dennis M. Ritchie先生致敬</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>Version: 0.1</pre></td></tr><tr><td data-num="6"></td><td><pre>Author: 骆昊</pre></td></tr><tr><td data-num="7"></td><td><pre>"""</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello, world!'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment"># print ("你好，世界！")</span></pre></td></tr></table></figure><h3 id="python开发工具"><a class="anchor" href="#python开发工具">#</a> Python 开发工具</h3><h4 id="idle-自带的集成开发工具"><a class="anchor" href="#idle-自带的集成开发工具">#</a> IDLE - 自带的集成开发工具</h4><p><code>IDLE</code>  是安装 <code>Python</code>  环境时自带的集成开发工具，如下图所示。但是由于 <code>IDLE</code>  的用户体验并不是那么好所以很少在实际开发中被采用。</p><p><img data-src="./res/python-idle.png" alt="" /></p><h4 id="ipython-更好的交互式编程工具"><a class="anchor" href="#ipython-更好的交互式编程工具">#</a> IPython - 更好的交互式编程工具</h4><p><code>IPython</code>  是一种基于 <code>Python</code>  的交互式解释器。相较于原生的 Python 交互式环境， <code>IPython</code>  提供了更为强大的编辑和交互功能。可以通过 Python 的包管理工具 pip 安装 <code>IPython</code> ，具体的操作如下所示。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>pip <span class="token function">install</span> ipython</pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>pip3 <span class="token function">install</span> ipython</pre></td></tr></table></figure><p>安装成功后，可以通过下面的 ipython 命令启动 <code>IPython</code> ，如下图所示。</p><p><img data-src="./res/python-ipython.png" alt="" /></p><h4 id="sublime-text-高级文本编辑器"><a class="anchor" href="#sublime-text-高级文本编辑器">#</a> Sublime Text - 高级文本编辑器</h4><p><img data-src="./res/python-sublime.png" alt="" /></p><ul><li><p>首先可以通过<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3VibGltZXRleHQuY29tLw==">官方网站</span>下载安装程序安装 <code>Sublime Text 3</code>  或 <code>Sublime Text 2</code> 。</p></li><li><p>安装包管理工具。</p><ol><li>通过快捷键 <code>Ctrl+</code>  或者在 View 菜单中选择 <code>Show Console</code>  打开控制台，输入下面的代码。</li></ol><ul><li><code>Sublime 3</code></li></ul><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span>  urllib<span class="token punctuation">.</span>request<span class="token punctuation">,</span>os<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>pf<span class="token operator">=</span><span class="token string">'Package Control.sublime-package'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>ipp<span class="token operator">=</span>sublime<span class="token punctuation">.</span>installed_packages_path<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>install_opener<span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>build_opener<span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>ProxyHandler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token builtin">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>ipp<span class="token punctuation">,</span>pf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span><span class="token string">'http://sublime.wbond.net/'</span><span class="token operator">+</span>pf<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">'%20'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>Sublime 2</li></ul><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span>  urllib2<span class="token punctuation">,</span>os<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>pf<span class="token operator">=</span><span class="token string">'Package Control.sublime-package'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>ipp<span class="token operator">=</span>sublime<span class="token punctuation">.</span>installed_packages_path<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>ipp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span> notos<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>ipp<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">pass</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token boolean">None</span></pre></td></tr><tr><td data-num="9"></td><td><pre>urllib2<span class="token punctuation">.</span>install_opener<span class="token punctuation">(</span>urllib2<span class="token punctuation">.</span>build_opener<span class="token punctuation">(</span>urllib2<span class="token punctuation">.</span>ProxyHandler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token builtin">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>ipp<span class="token punctuation">,</span>pf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span><span class="token string">'http://sublime.wbond.net/'</span><span class="token operator">+</span>pf<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">'%20'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Please restart Sublime Text to finish installation'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ol start="2"><li>在浏览器中输入  <span class="exturl" data-url="aHR0cHM6Ly9zdWJsaW1lLndib25kLm5ldC9QYWNrYWdlJTIwQ29udHJvbC5zdWJsaW1lLXBhY2thZ2U=">https://sublime.wbond.net/Package Control.sublime-package</span> 下载包管理工具的安装包，并找到安装 Sublime 目录下名为 &quot;Installed Packages&quot; 的目录，把刚才下载的文件放到这个文件加下，然后重启 Sublime Text 就搞定了。</li></ol></li><li><p>安装插件。通过 <code>Preference</code>  菜单的 <code>Package Control</code>  或快捷键 <code>Ctrl+Shift+P</code>  打开命令面板，在面板中输入 <code>Install Package</code>  就可以找到安装插件的工具，然后再查找需要的插件。我们推荐大家安装以下几个插件：</p><ul><li><code>SublimeCodeIntel</code>  - 代码自动补全工具插件。</li><li><code>Emmet</code>  - 前端开发代码模板插件。</li><li><code>Git</code>  - 版本控制工具插件。</li><li><code>Python PEP8 Autoformat</code>  -  <code>PEP8</code>  规范自动格式化插件。</li><li><code>ConvertToUTF8</code>  - 将本地编码转换为 <code>UTF-8</code> 。</li></ul></li></ul><blockquote><p><strong>说明</strong>：事实上<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v"> Visual Studio Code</span> 可能是更好的选择，它不用花钱并提供了更为完整和强大的功能，有兴趣的读者可以自行研究。</p></blockquote><h4 id="pycharm-python开发神器"><a class="anchor" href="#pycharm-python开发神器">#</a> PyCharm - Python 开发神器</h4><p>PyCharm 的安装、配置和使用在<a href="../%E7%95%AA%E5%A4%96%E7%AF%87/%E7%8E%A9%E8%BD%ACPyCharm.md">《玩转 PyCharm》</a>进行了介绍，有兴趣的读者可以选择阅读。</p><p><img data-src="./res/python-pycharm.png" alt="" /></p><h3 id="练习"><a class="anchor" href="#练习">#</a> 练习</h3><ol><li><p>在 <code>Python</code>  交互式环境中输入下面的代码并查看结果，请尝试将看到的内容翻译成中文。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> this</pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：输入上面的代码，在 <code>Python</code>  的交互式环境中可以看到 Tim Peter 撰写的<a href="../Python%E4%B9%8B%E7%A6%85.md"> “Python 之禅”</a>，里面讲述的道理不仅仅适用于 Python，也适用于其他编程语言。</p></blockquote></li><li><p>学习使用 turtle 在屏幕上绘制图形。</p><blockquote><p><strong>说明</strong>：turtle 是 Python 内置的一个非常有趣的模块，特别适合对计算机程序设计进行初体验的小伙伴，它最早是 Logo 语言的一部分，Logo 语言是 Wally Feurzig 和 Seymour Papert 在 1966 发明的编程语言。</p></blockquote><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> turtle</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>turtle<span class="token punctuation">.</span>pensize<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>turtle<span class="token punctuation">.</span>pencolor<span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>turtle<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>turtle<span class="token punctuation">.</span>right<span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>turtle<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>turtle<span class="token punctuation">.</span>right<span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>turtle<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>turtle<span class="token punctuation">.</span>right<span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>turtle<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>turtle<span class="token punctuation">.</span>mainloop<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：本章提供的代码中还有画国旗和画小猪佩奇的代码，有兴趣的读者请自行研究。</p></blockquote></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
